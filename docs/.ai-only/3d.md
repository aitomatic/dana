# 3D Methodology (Design-Driven Development)

**3D = Design-Driven Development**: A rigorous methodology ensuring quality through comprehensive design documentation, iterative implementation phases, and strict quality gates.

Core principle: Think before you build, build with intention, ship with confidence.

## ğŸ› ï¸ Common Commands
```bash
# Core development workflow
uv run ruff check . && uv run ruff format .    # Lint and format
uv run pytest tests/ -v                        # Run tests with verbose output
uv run python -m opendxa.dana.exec.repl        # Dana REPL for testing
```

## ğŸ“‹ ALWAYS Create Design Document First

For any feature/system implementation, create two documents:

1. **Design Document**: `[feature_name].md`
   - Contains the design specification
   - Documents the architecture and approach
   - Defines requirements and constraints

2. **Implementation Tracker**: `[feature_name]-implementation.md`
   - Tracks implementation progress
   - Contains design review status
   - Monitors quality gates
   - Records decisions and changes

### Design Document Template
```markdown
# Design Document: [Feature Name]

<!-- text markdown -->
Author: [Name]
Version: 1.0
Date: [Date]
Status: [Design Phase | Implementation Phase | Review Phase]
Implementation Tracker: [feature_name]-implementation.md
<!-- end text markdown -->

## Problem Statement
**Brief Description**: [1-2 sentence summary of the problem]
- Current situation and pain points
- Impact of not solving this problem  
- Relevant context and background

## Goals
**Brief Description**: [What we want to achieve]
- Specific, measurable objectives (SMART goals)
- Success criteria and metrics
- Key requirements

## Non-Goals
**Brief Description**: [What we explicitly won't do]
- Explicitly state what's out of scope
- Clarify potential misunderstandings

## Proposed Solution
**Brief Description**: [High-level approach in 1-2 sentences]
- High-level approach and key components
- Why this approach was chosen
- Main trade-offs and system fit
- **KISS/YAGNI Analysis**: Justify complexity vs. simplicity choices

## Proposed Design
**Brief Description**: [System architecture overview]

### System Architecture Diagram
<!-- mermaid markdown -->
[Create ASCII or Mermaid diagram showing main components and their relationships]
<!-- end mermaid markdown -->

### Component Details
**Brief Description**: [Overview of each major component and its purpose]
- System architecture and components
- Data models, APIs, interfaces
- Error handling and security considerations
- Performance considerations

**Motivation and Explanation**: Each component section must include:
- **Why this component exists** and what problem it solves
- **How it fits into the overall system** architecture
- **Key design decisions** and trade-offs made
- **Alternatives considered** and why they were rejected
- **Don't rely on code to be self-explanatory** - explain the reasoning

### Data Flow Diagram (if applicable)
<!-- mermaid markdown -->
[Show how data moves through the system]
<!-- end mermaid markdown -->

## Proposed Implementation
**Brief Description**: [Technical approach and key decisions]
- Technical specifications and code organization
- Key algorithms and testing strategy
- Dependencies and monitoring requirements
```

### Implementation Tracker Template
```markdown
# Implementation Tracker: [Feature Name]

<!-- text markdown -->
Author: [Name]
Version: 1.0
Date: [Date]
Status: [Design Phase | Implementation Phase | Review Phase]
Design Document: [feature_name].md
<!-- end text markdown -->

## Design Review Status
- [ ] **Problem Alignment**: Does solution address all stated problems?
- [ ] **Goal Achievement**: Will implementation meet all success criteria?
- [ ] **Non-Goal Compliance**: Are we staying within defined scope?
- [ ] **KISS/YAGNI Compliance**: Is complexity justified by immediate needs?
- [ ] **Security review completed**
- [ ] **Performance impact assessed**
- [ ] **Error handling comprehensive**
- [ ] **Testing strategy defined**
- [ ] **Documentation planned**
- [ ] **Backwards compatibility checked**

## Implementation Progress
**Overall Progress**: [ ] 0% | [ ] 20% | [ ] 40% | [ ] 60% | [ ] 80% | [ ] 100%

### Phase 1: Foundation & Architecture (~15-20%)
- [ ] Define core components and interfaces
- [ ] Create basic infrastructure and scaffolding
- [ ] Establish architectural patterns and conventions
- [ ] **Phase Gate**: Run tests - ALL tests pass
- [ ] **Phase Gate**: Update implementation progress checkboxes

[Other phases remain the same...]

## Quality Gates
âš ï¸  DO NOT proceed to next phase until ALL criteria met:
âœ… 100% test pass rate - ZERO failures allowed
âœ… No regressions detected in existing functionality
âœ… Error handling complete and tested with failure scenarios
âœ… Examples created and validated (Phase 6 only)
âœ… Documentation updated and cites working examples (Phase 6 only)
âœ… Performance within defined bounds
âœ… Implementation progress checkboxes updated
âœ… Design review completed (if in Phase 1)

## Technical Debt & Maintenance
- [ ] **Code Analysis**: Run automated analysis tools
- [ ] **Complexity Review**: Assess code complexity metrics
- [ ] **Test Coverage**: Verify test coverage targets
- [ ] **Documentation**: Update technical documentation
- [ ] **Performance**: Validate performance metrics
- [ ] **Security**: Complete security review

## Recent Updates
- [Date] [Update description]
- [Date] [Update description]

## Notes & Decisions
- [Date] [Important decision or note]
- [Date] [Important decision or note]

## Upcoming Milestones
- [Date] [Milestone description]
- [Date] [Milestone description]
```

## ğŸ”„ 3D Process: Think â†’ Build â†’ Ship

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Phase 1:      â”‚    â”‚   Phase 2-5:    â”‚    â”‚   Phase 6:      â”‚
â”‚ Design & Test   â”‚ -> â”‚ Implement &     â”‚ -> â”‚ Examples, Docs  â”‚
â”‚                 â”‚    â”‚ Validate        â”‚    â”‚ & Polish        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“Š Implementation Tracking

For design review and implementation tracking, see:
- [3D Build Tracker](3d-build.md) - Active project tracking and progress monitoring

The build tracker includes:
- Design review status and checklists
- Implementation progress by phase
- Quality gates and validation criteria
- Technical debt monitoring
- Project status overview
- Recent updates and decisions
- Upcoming milestones

## ğŸ“ Documentation & Examples Organization

For detailed directory structures and organization guidelines, see:
- [Documentation Structure Reference](documentation_structure.md)
- [Examples Structure Reference](examples_structure.md)

### Organization Guidelines
- **Major Features**: Independent systems that warrant their own directory (e.g., POET, Dana Language)
- **Subsystems**: Components of larger systems (e.g., parser, interpreter within Dana)
- **Examples Mirror Documentation**: Same directory structure for easy cross-referencing
- **Documentation Cites Examples**: All user-facing docs should reference working examples

## ğŸ“š Example Creation Guidelines

### ğŸ¯ Purpose-Driven Examples

Examples are created in **Phase 6** after core implementation is complete and stable. Every example must serve a **specific learning objective** and follow the **Progressive Disclosure** principle:

```
ğŸ“ **LEARNING PROGRESSION**:
1. Start with minimal working example
2. Add complexity gradually
3. Explain each addition
4. Show real-world usage
5. Demonstrate best practices
```

### Example Structure
```
examples/
â”œâ”€â”€ [major_feature]/         # For large efforts (e.g., examples/poet/)
â”‚   â”œâ”€â”€ README.md           # Overview and navigation
â”‚   â”œâ”€â”€ 01_hello_world/     # Minimal working examples
â”‚   â”œâ”€â”€ 02_basic_usage/     # Common patterns
â”‚   â”œâ”€â”€ 03_real_world/      # Production-like scenarios
â”‚   â”œâ”€â”€ 04_advanced/        # Complex scenarios
â”‚   â”œâ”€â”€ troubleshooting.md  # Common issues
â”‚   â””â”€â”€ tests/              # Example validation tests
```

### Example Requirements
- **Working Code**: All examples must be runnable and tested
- **Clear Purpose**: Each example demonstrates specific concepts
- **Progressive Complexity**: Build from simple to complex
- **Real-World Context**: Show practical applications
- **Best Practices**: Demonstrate recommended patterns
- **Error Handling**: Include error cases and recovery
- **Documentation**: Clear explanations and comments
- **Tests**: Validation tests for each example

## ğŸ¤– AI Collaboration Optimization

[Previous AI collaboration section content remains unchanged]
