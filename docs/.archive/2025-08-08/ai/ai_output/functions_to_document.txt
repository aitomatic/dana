44:    def to_dict(self) -> dict[str, any]:
62:def create_dana_exception(exc: Exception, error_context=None) -> DanaException:
42:    def find_spec(self, fullname: str, path: Sequence[str | bytes] | None = None, target: Module | None = None) -> PyModuleSpec | None:
67:    def _find_spec_with_context(self, fullname: str, importing_module_path: str | None = None) -> PyModuleSpec | None:
300:    def _setup_package_attributes(self, spec: ModuleSpec) -> None:
333:    def create_module(self, spec: PyModuleSpec) -> Module | None:
375:    def exec_module(self, module: Module) -> None:
473:    def _setup_module_function_context(self, module: Module, interpreter: DanaInterpreter, context: SandboxContext) -> None:
516:    def _find_module_in_directory(self, module_name: str, directory: Path) -> Path | None:
538:    def _find_module_file(self, module_name: str) -> Path | None:
75:def show_help():
96:def execute_file(file_path, debug=False):
145:async def start_repl(debug=False):
166:def handle_start_command(args):
212:def main():
318:def handle_main_command():
364:def handle_deploy_command(args):
391:def handle_config_command(args):
420:def deploy_thru_mcp(file_path, args):
437:def deploy_thru_a2a(file_path, args):
450:def configure_debug_logging():
457:def validate_na_file(file_path):
114:    def run_configuration_wizard(self) -> bool:
160:    def _select_providers(self) -> list[str]:
210:    def _configure_provider(self, provider_key: str) -> dict[str, str] | None:
262:    def _write_env_file(self, env_vars: dict[str, str]):
299:    def validate_configuration(self) -> bool:
355:    def _load_env_file(self):
11:def validate_agent_module(na_file_path: str, na_module):
59:def make_agent_class(agent_name: str, agent_description: str, entry_func: Callable):
77:        def solve_query(self, query: str) -> str:
85:        def handle_task(self, task):
103:def color_text(text, color_code):
107:def print_a2a_server_banner(host, port, agent_name, agent_description):
129:def deploy_dana_agents_thru_a2a(na_file_path, host, port):
8:def validate_agent_module(na_file_path: str, na_module):
48:def create_mcp_server_for_file(na_file_path):
68:        def solve(query: str) -> str:
84:def color_text(text, color_code):
88:def print_mcp_server_banner(host, port, agent_name):
110:def deploy_dana_agents_thru_mcp(na_file_path, host, port):
142:    async def lifespan(app: FastAPI):
52:    def detect_assignment_context(self, assignment_node: Assignment) -> TypeContext | None:
84:    def detect_function_call_context(self, func_call_node: FunctionCall) -> TypeContext | None:
143:    def detect_function_parameter_context(self, param_name: str, param_type: str) -> TypeContext:
163:    def detect_conditional_context(self, condition_node: Any) -> TypeContext:
182:    def infer_context_from_usage(self, variable_name: str, usage_context: str) -> TypeContext | None:
215:    def get_cached_context(self, cache_key: str) -> TypeContext | None:
226:    def cache_context(self, cache_key: str, context: TypeContext) -> None:
236:    def clear_cache(self) -> None:
241:    def get_cache_size(self) -> int:
245:    def detect_current_context(self, context: Any) -> TypeContext | None:
293:    def _infer_from_execution_context(self, context: Any) -> TypeContext | None:
346:    def analyze_assignment_chain(self, assignments: list[Assignment]) -> list[TypeContext]:
365:    def find_strongest_context(self, contexts: list[TypeContext]) -> TypeContext | None:
381:    def merge_contexts(self, contexts: list[TypeContext]) -> TypeContext | None:
431:def detect_assignment_context(assignment_node: Assignment) -> TypeContext | None:
437:def detect_conditional_context(condition_node: Any) -> TypeContext:
443:def analyze_contexts(assignments: list[Assignment]) -> list[TypeContext]:
55:    def push_location(self, location: ExecutionLocation) -> None:
60:    def pop_location(self) -> ExecutionLocation | None:
68:    def set_file(self, filename: str | Path) -> None:
73:    def load_source(self, filename: str) -> list[str] | None:
87:    def get_source_line(self, filename: str, line_num: int) -> str | None:
94:    def format_stack_trace(self) -> str:
48:def _patched_format_user_error(e, user_input=None):
87:    def _init_function_registry(self):
108:    def function_registry(self) -> FunctionRegistry:
122:    def _run(self, file_path: str | Path, source_code: str, context: SandboxContext) -> Any:
136:    def _eval(self, source_code: str, context: SandboxContext, filename: str | None = None) -> Any:
155:    def _execute(self, ast: Program, context: SandboxContext) -> Any:
192:    def evaluate_expression(self, expression: Any, context: SandboxContext) -> Any:
204:    def execute_program(self, program: Program, context: SandboxContext) -> Any:
217:    def execute_statement(self, statement: Any, context: SandboxContext) -> Any:
230:    def get_and_clear_output(self) -> str:
234:    def get_evaluated(self, key: str, context: SandboxContext) -> Any:
250:    def call_function(
278:    def evaluate_ast(self, ast: Program, context: SandboxContext) -> Any:
294:    def _process_function_definition(self, func_def: FunctionDefinition, context: SandboxContext) -> None:
325:    def _create_dana_function(self, func_def: FunctionDefinition, context: SandboxContext, register: bool = True):
339:        def dana_function(*args, **kwargs):
362:    def _bind_function_parameters(self, parameters: list, args: tuple, kwargs: dict, context: SandboxContext) -> None:
376:    def _register_function_normally(self, func_def: FunctionDefinition, context: SandboxContext) -> None:
381:    def is_repl_mode(self) -> bool:
18:    def format_error(error: Exception, error_context: ErrorContext | None = None, show_traceback: bool = True) -> str:
86:    def format_developer_error(error: Exception, error_context: ErrorContext | None = None, show_traceback: bool = True) -> str:
164:    def format_simple_error(error: Exception, filename: str | None = None) -> str:
36:    def _build_boolean_patterns(self) -> dict[str, bool]:
87:    def _build_numeric_patterns(self) -> dict[str, re.Pattern]:
97:    def coerce_to_bool(self, value: Any, context: str | None = None) -> bool:
126:    def _coerce_string_to_bool(self, text: str) -> bool:
160:    def _is_zero_equivalent(self, text: str) -> bool:
165:    def _is_positive_numeric(self, text: str) -> bool:
173:    def _apply_contextual_boolean_logic(self, text: str) -> bool | None:
192:    def coerce_value(self, value: Any, target_type: str, context: str | None = None) -> Any:
237:    def _coerce_to_dict(self, value: Any, context: str | None = None) -> dict:
278:    def _coerce_to_list(self, value: Any, context: str | None = None) -> list:
319:    def _extract_final_answer(self, text: str) -> str:
338:    def _try_coerce_to_struct(self, value: Any, target_type: str, context: str | None = None) -> Any | None:
396:    def _coerce_string_to_struct(self, text: str, target_type: str, context: str | None = None) -> Any:
440:    def _coerce_dict_to_struct(self, data: dict, target_type: str, context: str | None = None) -> Any:
466:    def _clean_json_string(self, value: str) -> str:
487:    def test_semantic_equivalence(self, left: Any, right: Any) -> bool:
513:def coerce_value(value: Any, target_type: str, context: str | None = None) -> Any:
518:def semantic_bool(value: Any) -> bool:
523:def semantic_equals(left: Any, right: Any) -> bool:
49:    def prepare_context(self, context: SandboxContext | Any, args: list[Any], kwargs: dict[str, Any]) -> SandboxContext:
108:    def restore_context(self, context: SandboxContext, original_context: SandboxContext) -> None:
121:    def execute(self, context: Any, *args: Any, **kwargs: Any) -> Any:
56:    def prepare_context(self, context: SandboxContext, args: list[Any], kwargs: dict[str, Any]) -> SandboxContext:
73:    def restore_context(self, context: SandboxContext, original_context: SandboxContext) -> None:
86:    def execute(self, context: SandboxContext, *args: Any, **kwargs: Any) -> Any:
108:    def _resolve_function(self, func: SandboxFunction | str | Callable, context: SandboxContext) -> SandboxFunction:
167:    def _wrap_callable(self, func: callable, func_name: str, context: SandboxContext) -> SandboxFunction:
185:            def execute(self, context: SandboxContext, *args, **kwargs):
208:            def restore_context(self, context: SandboxContext, original_context: SandboxContext) -> None:
81:    def register_handlers(self):
102:    def execute_assignment(self, node: Assignment, context: SandboxContext) -> Any:
114:    def execute_compound_assignment(self, node: CompoundAssignment, context: SandboxContext) -> Any:
126:    def execute_assert_statement(self, node: AssertStatement, context: SandboxContext) -> None:
141:    def _execute_python_import(self, module_name: str, context_name: str, context: SandboxContext) -> None:
168:    def _execute_dana_import(self, module_name: str, context_name: str, context: SandboxContext) -> None:
210:    def _execute_python_from_import(self, module_name: str, names: list[tuple[str, str | None]], context: SandboxContext) -> None:
253:    def _execute_dana_from_import(self, module_name: str, names: list[tuple[str, str | None]], context: SandboxContext) -> None:
315:    def _register_imported_function(self, func: callable, context_name: str, module_name: str, original_name: str) -> None:
385:    def execute_import_statement(self, node: ImportStatement, context: SandboxContext) -> Any:
397:    def execute_import_from_statement(self, node: ImportFromStatement, context: SandboxContext) -> Any:
409:    def execute_pass_statement(self, node: PassStatement, context: SandboxContext) -> None:
421:    def execute_raise_statement(self, node: RaiseStatement, context: SandboxContext) -> None:
436:    def execute_use_statement(self, node: UseStatement, context: SandboxContext) -> Any:
448:    def execute_export_statement(self, node: ExportStatement, context: SandboxContext) -> None:
460:    def execute_struct_definition(self, node: StructDefinition, context: SandboxContext) -> None:
472:    def execute_agent_definition(self, node: AgentDefinition, context: SandboxContext) -> None:
484:    def execute_agent_statement(self, node: AgentStatement, context: SandboxContext) -> Any:
496:    def execute_agent_pool_statement(self, node: AgentPoolStatement, context: SandboxContext) -> Any:
508:    def execute_function_definition(self, node: "FunctionDefinition", context: SandboxContext) -> Any:
523:    def execute_method_definition(self, node: "MethodDefinition", context: SandboxContext) -> Any:
541:            func_def = FunctionDefinition(
551:    def execute_declarative_function_definition(self, node: "DeclarativeFunctionDefinition", context: SandboxContext) -> Any:
570:        def create_declarative_function():
571:            def wrapper(*args, **kwargs):
615:    def _bind_declarative_function_parameters(self, parameters: list, args: tuple, kwargs: dict, func_context: SandboxContext) -> None:
674:    def _execute_composition(self, composition, func_context: SandboxContext, args: tuple) -> Any:
698:    def _extract_annotations(self, parameters: list, return_type) -> dict[str, type]:
720:    def _map_dana_type_to_python(self, dana_type: str) -> type:
745:    def _create_signature(self, parameters: list, return_type):
68:    def register_handlers(self):
76:    def execute_function_definition(self, node: FunctionDefinition, context: SandboxContext) -> Any:
142:    def execute_method_definition(self, node: MethodDefinition, context: SandboxContext) -> Any:
221:    def _apply_decorators(self, func, decorators, context):
249:    def _evaluate_expression(self, expr, context):
260:    def _resolve_decorator(self, decorator, context):
292:    def _ensure_fully_evaluated(self, value: Any, context: SandboxContext) -> Any:
314:    def execute_function_call(self, node: FunctionCall, context: SandboxContext) -> Any:
522:    def _get_current_function_context(self, context: SandboxContext) -> str | None:
560:    def _assign_and_coerce_result(self, raw_result: Any, function_name: str) -> Any:
578:    def _apply_function_result_coercion(self, result: Any, function_name: str) -> Any:
609:    def _execute_user_defined_function(self, func_data: dict[str, Any], args: list[Any], context: SandboxContext) -> Any:
42:    def execute_agent_statement(self, node: AgentStatement, context: SandboxContext) -> Any:
87:    def execute_agent_pool_statement(self, node: AgentPoolStatement, context: SandboxContext) -> Any:
132:    def execute_use_statement(self, node: UseStatement, context: SandboxContext) -> Any:
169:    def execute_export_statement(self, node: ExportStatement, context: SandboxContext) -> None:
200:    def execute_struct_definition(self, node: StructDefinition, context: SandboxContext) -> None:
235:            def struct_constructor(**kwargs):
248:    def execute_agent_definition(self, node: AgentDefinition, context: SandboxContext) -> None:
273:            def agent_constructor(**kwargs):
288:    def execute_function_definition(self, node: FunctionDefinition, context: SandboxContext) -> Any:
352:    def _apply_decorators(self, func, decorators, context):
380:    def _resolve_decorator(self, decorator, context):
390:    def _trace_resource_operation(self, operation_type: str, resource_name: str, arg_count: int, kwarg_count: int) -> None:
406:    def get_stats(self) -> dict[str, Any]:
56:    def execute_import_statement(self, node: ImportStatement, context: SandboxContext) -> Any:
93:    def execute_import_from_statement(self, node: ImportFromStatement, context: SandboxContext) -> Any:
123:    def _execute_python_import(self, module_name: str, context_name: str, context: SandboxContext) -> None:
157:    def _execute_dana_import(self, module_name: str, context_name: str, context: SandboxContext) -> None:
229:    def _execute_python_from_import(self, module_name: str, names: list[tuple[str, str | None]], context: SandboxContext) -> None:
276:    def _execute_dana_from_import(self, module_name: str, names: list[tuple[str, str | None]], context: SandboxContext) -> None:
364:    def _register_imported_function(self, func: callable, context_name: str, module_name: str, original_name: str) -> None:
402:    def _ensure_module_system_initialized(self) -> None:
418:    def _create_parent_namespaces(self, context_name: str, module: Any, context: SandboxContext) -> None:
480:    def _resolve_relative_import(self, module_name: str, context: SandboxContext) -> str:
557:    def _trace_import(self, import_type: str, module_name: str, context_info: str) -> None:
572:    def clear_cache(self) -> None:
581:    def get_cache_stats(self) -> dict[str, Any]:
49:    def execute_assignment(self, node: Assignment, context: SandboxContext) -> Any:
89:    def execute_compound_assignment(self, node: CompoundAssignment, context: SandboxContext) -> Any:
167:    def _process_type_hint(self, node: Assignment, context: SandboxContext) -> type | None:
212:    def _apply_type_coercion(self, value: Any, target_type: type | str, target_node: Any) -> Any:
263:    def _execute_assignment_by_target(self, target: Any, value: Any, context: SandboxContext) -> None:
287:    def _execute_subscript_assignment(self, target: SubscriptExpression, value: Any, context: SandboxContext) -> None:
320:    def _execute_slice_assignment(self, target_obj: Any, slice_expr: Any, value: Any, context: SandboxContext) -> None:
342:    def _execute_multidim_slice_assignment(self, target_obj: Any, slice_tuple: Any, value: Any, context: SandboxContext) -> None:
376:    def _execute_attribute_assignment(self, target: AttributeAccess, value: Any, context: SandboxContext) -> None:
397:    def _get_assignment_target_name(self, target: Any) -> str:
417:    def _trace_assignment(self, target: Any, value: Any) -> None:
433:    def clear_cache(self) -> None:
438:    def get_cache_stats(self) -> dict[str, Any]:
73:    def parse_function_name(self, func_name: str) -> FunctionNameInfo:
103:    def resolve_function(self, name_info: FunctionNameInfo, context: SandboxContext, registry: Any) -> ResolvedFunction | None:
133:    def _resolve_from_context_hierarchy(self, name_info: FunctionNameInfo, context: SandboxContext) -> ResolvedFunction | None:
175:    def _create_resolved_function_from_context(self, func_data: Any, name_info: FunctionNameInfo) -> ResolvedFunction:
218:    def _resolve_from_context(self, name_info: FunctionNameInfo, context: SandboxContext) -> ResolvedFunction | None:
252:    def _resolve_from_registry(self, name_info: FunctionNameInfo, registry: Any) -> ResolvedFunction | None:
289:    def execute_resolved_function(
321:    def list_available_functions(self, namespace: str | None = None) -> list[str]:
85:    def _register_all_handlers(self):
99:    def execute(self, node: Any, context: SandboxContext) -> Any:
146:    def _execute_hook(
168:    def get_and_clear_output(self) -> str:
178:    def extract_value(self, node: Any) -> Any:
197:    def configure_optimizations(self, **kwargs) -> None:
206:    def get_optimization_statistics(self) -> dict[str, Any] | None:
216:    def log_optimization_report(self) -> None:
223:    def clear_optimization_caches(self) -> None:
228:    def is_optimization_healthy(self) -> bool:
238:    def execute_with_location_context(self, method: Callable, node: Any, context: SandboxContext) -> Any:
22:    def track_execution(self, node_description: str):
38:    def check_depth_safety(self) -> None:
51:    def get_statistics(self) -> dict[str, Any]:
62:    def reset_statistics(self) -> None:
75:    def visit_node(self, node: Any):
95:    def get_current_path(self) -> list[str]:
99:    def clear(self) -> None:
99:    def register_handlers(self):
118:    def execute_literal_expression(self, node: LiteralExpression, context: SandboxContext) -> Any:
134:    def execute_identifier(self, node: Identifier, context: SandboxContext) -> Any:
147:    def execute_binary_expression(self, node: BinaryExpression, context: SandboxContext) -> Any:
167:    def execute_unary_expression(self, node: UnaryExpression, context: SandboxContext) -> Any:
188:    def execute_tuple_literal(self, node: TupleLiteral, context: SandboxContext) -> tuple:
200:    def execute_dict_literal(self, node: DictLiteral, context: SandboxContext) -> dict:
212:    def execute_set_literal(self, node: SetLiteral, context: SandboxContext) -> set:
224:    def execute_fstring_expression(self, node: FStringExpression, context: SandboxContext) -> str:
236:    def execute_attribute_access(self, node: AttributeAccess, context: SandboxContext) -> Any:
305:    def run_function(self, func: Callable, *args, **kwargs) -> Any:
311:    def execute_object_function_call(self, node: Any, context: SandboxContext) -> Any:
425:    def execute_subscript_expression(self, node: SubscriptExpression, context: SandboxContext) -> Any:
472:    def _execute_slice(self, target: Any, slice_expr: Any, context: SandboxContext) -> Any:
504:    def _evaluate_slice_components(self, slice_expr: Any, context: SandboxContext) -> dict[str, Any]:
545:    def _validate_slice_operation(self, target: Any, components: dict[str, Any]) -> None:
573:    def _validate_sequence_slice_bounds(self, components: dict[str, Any], length: int) -> None:
606:    def _execute_validated_slice(self, target: Any, components: dict[str, Any]) -> Any:
648:    def _execute_slice_tuple(self, target: Any, slice_tuple: Any, context: SandboxContext) -> Any:
699:    def _get_safe_length(self, obj: Any) -> str:
713:    def execute_list_literal(self, node: ListLiteral, context: SandboxContext) -> list:
725:    def execute_placeholder_expression(self, node: PlaceholderExpression, context: SandboxContext) -> Any:
740:    def _resolve_pipeline_function(self, identifier: Identifier, context: SandboxContext) -> Any:
771:    def execute_pipeline_expression(self, node: PipelineExpression, context: SandboxContext) -> Any:
783:            def identity_function(initial_value):
789:        def composed_function(initial_value):
803:    def _execute_pipeline_stage(self, current_value: Any, stage: Any, context: SandboxContext) -> Any:
856:                    def error_function(value):
907:    def _execute_function_call_stage(self, current_value: Any, func_call: FunctionCall, context: SandboxContext) -> Any:
964:    def _contains_placeholder(self, expr: Any) -> bool:
52:    def execute_try_block(self, node: TryBlock, context: SandboxContext) -> Any:
162:    def _execute_statement_list(self, statements: list[Any], context: SandboxContext) -> Any:
187:    def _add_exception_trace(self, block_type: str, exception_type: str, action: str) -> None:
208:    def clear_cache(self) -> None:
215:    def get_performance_stats(self) -> dict[str, Any]:
232:    def get_exception_traces(self) -> list[dict[str, Any]]:
240:    def _matches_exception(self, exception: Exception, except_block: ExceptBlock, context: SandboxContext) -> bool:
51:    def resolve_identifier(self, node: Identifier, context: SandboxContext) -> Any:
125:    def _try_direct_context_lookup(self, name: str, context: SandboxContext) -> Any | None:
136:    def _try_cross_scope_search(self, name: str, context: SandboxContext) -> Any | None:
151:    def _try_scoped_resolution(self, name: str, context: SandboxContext) -> Any | None:
163:    def _resolve_colon_notation(self, name: str, context: SandboxContext) -> Any | None:
190:    def _resolve_dot_notation(self, name: str, context: SandboxContext) -> Any | None:
218:    def _try_fallback_scope_search(self, var_name: str, specified_scope: str, context: SandboxContext) -> Any | None:
231:    def _resolve_scoped_attribute_access(self, var_name: str, scope_name: str, context: SandboxContext) -> Any | None:
255:    def _access_attribute_path(self, base_value: Any, attribute_path: str) -> Any:
262:    def _try_function_registry_resolution(self, name: str, context: SandboxContext) -> Any | None:
310:    def _create_registry_wrapper(self, name: str, resolved_func: Any, context: SandboxContext) -> Any:
313:        def registry_function(*args, **kwargs):
324:    def _try_dotted_attribute_access(self, name: str, context: SandboxContext) -> Any | None:
364:    def _try_struct_type_resolution(self, name: str) -> Any | None:
389:    def _cache_result(self, cache_key: tuple, result: Any) -> None:
399:    def clear_cache(self) -> None:
406:    def get_cache_stats(self) -> dict[str, int | float]:
41:    def execute(self, context: SandboxContext, *args, **kwargs) -> list[Any]:
61:    def restore_context(self, context: SandboxContext, original_context: SandboxContext) -> None:
66:    def _call_function(self, func: Any, context: SandboxContext, *args, **kwargs) -> Any:
107:    def execute_pipe(self, left: Any, right: Any, context: SandboxContext) -> Any:
128:    def _resolve_to_function(self, expr: Any, context: SandboxContext) -> Any:
167:    def _resolve_function_call(self, func_call: FunctionCall, context: SandboxContext) -> Any:
206:    def _resolve_list_literal(self, list_literal: ListLiteral, context: SandboxContext) -> Any:
218:    def _resolve_identifier(self, identifier: Identifier, context: SandboxContext) -> Any:
31:    def execute_binary_expression(self, node: BinaryExpression, context: SandboxContext) -> Any:
100:    def _apply_binary_coercion(self, left: Any, right: Any, operator: str) -> tuple:
118:    def _extract_value(self, raw_value: Any) -> Any:
124:    def clear_cache(self) -> None:
130:    def get_cache_stats(self) -> dict[str, Any]:
63:    def _initialize_resolvers(self) -> None:
78:    def resolve_function(self, name_info: FunctionNameInfo, context: SandboxContext) -> ResolvedFunction:
145:    def execute_function(
181:    def _execute_registry_function(
197:    def _execute_dana_function(
209:    def _execute_python_function(
221:    def _execute_callable_function(
233:    def _assign_and_coerce_result(self, raw_result: Any, func_name: str) -> Any:
242:    def get_resolution_history(self) -> list[ResolutionAttempt]:
250:    def get_stats(self) -> dict[str, Any]:
258:    def clear_history(self) -> None:
262:    def _raise_function_not_found_error(self, name_info: FunctionNameInfo, attempts: list[ResolutionAttempt]) -> None:
38:    def handle_function_call_error(self, error: Exception, node: FunctionCall, context: Any) -> Any:
64:    def _is_positional_argument_error(self, error: Exception) -> bool:
77:    def _handle_registry_error(self, error: FunctionRegistryError, node: FunctionCall) -> Any:
89:    def _convert_to_user_friendly_name(self, function_name: str) -> str:
108:    def format_error_message(self, error: Exception, function_name: str, context: str = "") -> str:
127:    def handle_registry_execution_error(
171:    def _create_enhanced_sandbox_error(self, error: Exception, node: FunctionCall, func_name: str) -> SandboxError:
204:    def attempt_recovery(self, error: Exception, node: FunctionCall, context: Any) -> Any:
233:    def _try_keyword_conversion(self, node: FunctionCall, context: Any) -> Any:
263:    def _try_reduced_args(self, node: FunctionCall, context: Any) -> Any:
292:    def get_recovery_suggestions(self, error: Exception, function_name: str) -> list[str]:
322:    def can_handle(self, error: Exception, evaluated_kwargs: dict[str, Any]) -> bool:
334:    def _is_positional_argument_error(self, error: Exception) -> bool:
347:    def recover(
52:    def validate_instantiation(self, args: dict[str, Any]) -> bool:
86:    def _validate_field_type(self, field_name: str, value: Any, expected_type: str) -> bool:
123:    def get_field_type(self, field_name: str) -> str | None:
127:    def get_field_comment(self, field_name: str) -> str | None:
131:    def get_field_description(self, field_name: str) -> str:
178:    def struct_type(self) -> StructType:
235:    def _coerce_value(self, value: Any, field_type: str | None) -> Any:
247:    def _find_similar_field(self, name: str, available_fields: list[str]) -> str | None:
253:        def similarity_score(field: str) -> float:
301:    def get_field_names(self) -> list[str]:
305:    def get_field_value(self, field_name: str) -> Any:
309:    def get_field(self, field_name: str) -> Any:
313:    def set_field_value(self, field_name: str, value: Any) -> None:
317:    def to_dict(self) -> dict[str, Any]:
321:    def call_method(self, method_name: str, *args: Any, **kwargs: Any) -> Any:
360:    def register_method(cls, receiver_types: list[str], method_name: str, function: Any) -> None:
375:    def get_method(cls, type_name: str, method_name: str) -> Any | None:
380:    def has_method(cls, type_name: str, method_name: str) -> bool:
385:    def get_methods_for_type(cls, type_name: str) -> dict[str, Any]:
394:    def clear(cls) -> None:
412:    def register(cls, struct_type: StructType) -> None:
428:    def get(cls, struct_name: str) -> StructType | None:
433:    def exists(cls, struct_name: str) -> bool:
438:    def list_types(cls) -> list[str]:
443:    def clear(cls) -> None:
448:    def create_instance(cls, struct_name: str, values: dict[str, Any]) -> StructInstance:
458:    def get_schema(cls, struct_name: str) -> dict[str, Any]:
494:    def _type_to_json_schema(cls, type_name: str) -> dict[str, Any]:
518:    def validate_json(cls, json_data: dict[str, Any], struct_name: str) -> bool:
544:    def create_instance_from_json(cls, json_data: dict[str, Any], struct_name: str) -> StructInstance:
564:def create_struct_type_from_ast(struct_def, context=None) -> StructType:
608:def register_struct_from_ast(struct_def) -> StructType:
615:def create_struct_instance(struct_name: str, **kwargs) -> StructInstance:
36:    def enhance_prompt(self, prompt: str, type_context: TypeContext | None = None) -> str:
58:    def _get_type_handler(self, expected_type: str) -> Callable[[str, TypeContext], str]:
71:    def _build_type_handlers(self) -> dict[str, Callable[[str, TypeContext], str]]:
80:    def _apply_enhancement(self, prompt: str, enhancement: str, type_name: str) -> str:
90:    def _enhance_for_boolean(self, prompt: str, context: TypeContext) -> str:
97:    def _enhance_for_integer(self, prompt: str, context: TypeContext) -> str:
102:    def _enhance_for_float(self, prompt: str, context: TypeContext) -> str:
107:    def _enhance_for_string(self, prompt: str, context: TypeContext) -> str:
117:    def _enhance_for_structure(self, prompt: str, context: TypeContext) -> str:
127:    def _enhance_for_dana_struct(self, prompt: str, context: TypeContext) -> str:
145:    def _get_struct_info(self, expected_type: str) -> dict | None:
171:    def _build_struct_enhancement(self, struct_name: str, struct_info: dict) -> str:
202:    def _build_field_descriptions(self, struct_type) -> list[str]:
210:    def _build_enhancement_patterns(self) -> dict[str, dict[str, str]]:
279:    def get_enhancement_preview(self, prompt: str, expected_type: str) -> str:
304:def enhance_prompt_for_type(prompt: str, type_context: TypeContext | None = None) -> str:
318:def preview_enhancement(prompt: str, expected_type: str) -> str:
30:def main():
51:        async def _validate_document(self, uri: str, text: str):
71:        def _get_document_text(self, uri: str) -> str | None:
84:    async def did_open(ls: DanaLanguageServer, params: lsp.DidOpenTextDocumentParams):
90:    async def did_change(ls: DanaLanguageServer, params: lsp.DidChangeTextDocumentParams):
98:    async def did_save(ls: DanaLanguageServer, params: lsp.DidSaveTextDocumentParams):
120:    async def hover(ls: DanaLanguageServer, params: lsp.HoverParams) -> lsp.Hover | None:
137:    async def completion(ls: DanaLanguageServer, params: lsp.CompletionParams) -> lsp.CompletionList:
132:    async def analyze(self, text: str) -> list[Any]:
165:    def _analyze_dana_specific_rules(self, text: str, program: Program):
176:    def _analyze_line(self, line: str, line_num: int):
221:    def _has_incorrect_scope_syntax(self, line: str) -> bool:
226:    def _has_string_concatenation(self, line: str) -> bool:
234:    def _has_unscoped_assignment(self, line: str) -> bool:
248:    async def get_hover(self, text: str, line: int, character: int) -> str | None:
272:    def _get_word_at_position(self, line: str, character: int) -> str | None:
290:    def _get_dana_hover_info(self, word: str) -> str | None:
315:    async def get_completions(self, text: str, line: int, character: int) -> list[dict[str, Any]]:
357:    def _should_suggest_scope_prefixes(self, prefix: str) -> bool:
362:    def _parse_error_to_diagnostic(self, error: ParseError):
109:    def set_filename(self, filename: str | None) -> None:
127:    def program(self, items):
145:    def _fix_function_boundary_bug(self, statements):
176:    def _fix_nested_statements(self, statements):
239:    def _is_local_scoped_assignment(self, assignment):
247:    def statement(self, items):
263:    def conditional(self, items):
267:    def if_part(self, items):
271:    def else_part(self, items):
275:    def while_stmt(self, items):
279:    def for_stmt(self, items):
283:    def _transform_item(self, item):
309:    def function_def(self, items):
313:    def method_def(self, items):
317:    def decorators(self, items):
321:    def decorator(self, items):
325:    def struct_definition(self, items):
329:    def struct_field(self, items):
333:    def agent_definition(self, items):
337:    def agent_field(self, items):
341:    def try_stmt(self, items):
345:    def if_stmt(self, items):
349:    def elif_stmts(self, items):
353:    def elif_stmt(self, items):
358:    def assignment(self, items):
367:    def declarative_function_assignment(self, items):
374:    def expr_stmt(self, items):
378:    def return_stmt(self, items):
382:    def break_stmt(self, items):
386:    def continue_stmt(self, items):
390:    def pass_stmt(self, items):
394:    def raise_stmt(self, items):
398:    def assert_stmt(self, items):
402:    def use_stmt(self, items):
406:    def agent_stmt(self, items):
410:    def agent_pool_stmt(self, items):
415:    def import_stmt(self, items):
419:    def simple_import(self, items):
423:    def from_import(self, items):
428:    def arg_list(self, items):
432:    def positional_args(self, items):
436:    def named_args(self, items):
440:    def named_arg(self, items):
445:    def _filter_body(self, items):
452:    def identifier(self, items):
456:    def _transform_block(self, block):
493:    def _process_statements_with_boundary_detection(self, statements):
520:    def _is_program_level_statement(self, stmt):
543:    def _is_assignment_to_local_scope(self, assignment_tree):
556:    def _target_uses_local_scope(self, target_tree):
575:    def parameters(self, items):
579:    def parameter(self, items):
583:    def binary_expr(self, items):
597:    def _filter_relevant_items(self, items):
618:    def basic_type(self, items):
622:    def typed_assignment(self, items):
626:    def simple_assignment(self, items):
630:    def function_call_assignment(self, items):
634:    def compound_assignment(self, items):
638:    def compound_op(self, items):
642:    def return_object_stmt(self, items):
646:    def typed_parameter(self, items):
650:    def mixed_arguments(self, items):
654:    def with_arg(self, items):
658:    def with_context_manager(self, items):
662:    def with_stmt(self, items):
666:    def create_location(self, item: Any) -> Location | None:
675:    def statements(self, items):
76:    def set_declarative_function_context(self, in_declarative_function: bool):
80:    def expression(self, items):
115:            def custom_transformer(node: Any) -> Any:
174:    def _extract_operator_string(self, op_token):
178:    def _op_tree_to_str(self, tree):
189:    def _left_associative_binop(self, items, operator_getter):
197:    def _get_binary_operator(self, op_str):
225:    def or_expr(self, items):
236:    def and_expr(self, items):
247:    def placeholder_expression(self, items):
251:    def pipe_expr(self, items):
294:                "Use 'def function_name() = expr1 | expr2' syntax instead of assignment."
300:    def _is_in_declarative_function_context(self):
304:    def _is_literal_expression(self, expr):
324:    def not_expr(self, items):
366:    def comparison(self, items):
369:    def sum_expr(self, items):
373:    def term(self, items):
377:    def factor(self, items):
429:    def power(self, items):
465:    def atom(self, items):
513:    def _atom_from_token(self, token):
551:    def literal(self, items):
555:    def identifier(self, items):
561:    def argument(self, items):
574:    def _process_function_arguments(self, arg_children):
599:    def tuple(self, items):
611:    def list(self, items):
626:    def dict(self, items):
639:    def set(self, items):
651:    def TRUE(self, items=None):
654:    def FALSE(self, items=None):
657:    def NONE(self, items=None):
660:    def trailer(self, items):
698:    def _get_full_attribute_name(self, attr):
710:    def key_value_pair(self, items):
716:    def expr(self, items):
720:    def string(self, items):
797:    def product(self, items):
805:    def POW(self, token):
809:    def ADD(self, token):
813:    def SUB(self, token):
817:    def MUL(self, token):
821:    def DIV(self, token):
825:    def FDIV(self, token):
829:    def MOD(self, token):
833:    def string_literal(self, items):
886:    def slice_or_index(self, items):
890:    def slice_start_only(self, items):
894:    def slice_stop_only(self, items):
898:    def slice_start_stop(self, items):
902:    def slice_start_stop_step(self, items):
906:    def slice_all(self, items):
910:    def slice_step_only(self, items):
914:    def slice_expr(self, items):
919:    def slice_list(self, items):
931:    def function_composition_expr(self, items):
936:    def function_pipe_expr(self, items):
951:    def function_expr(self, items):
956:    def function_name(self, items):
961:    def function_call(self, items):
968:    def function_list_literal(self, items):
46:    def assignment(self, items):
55:    def typed_assignment(self, items):
64:    def simple_assignment(self, items):
72:    def compound_assignment(self, items):
124:    def compound_op(self, items):
129:    def function_call_assignment(self, items):
153:    def declarative_function_assignment(self, items):
202:    def _transform_function_composition(self, composition_tree):
223:    def _transform_parameter(self, param_tree):
240:    def _transform_type_hint(self, type_tree):
254:    def return_object_stmt(self, items):
268:    def basic_type(self, items):
272:    def typed_parameter(self, items):
5:- Function definitions (def statements)
45:    def function_def(self, items):
81:    def method_def(self, items):
150:    def _extract_decorators_and_name(self, relevant_items):
171:    def _resolve_function_parameters(self, relevant_items, current_index):
195:    def _extract_return_type(self, relevant_items, current_index):
214:    def _extract_function_body(self, relevant_items, current_index):
229:    def decorators(self, items):
233:    def decorator(self, items):
237:    def _transform_decorators(self, decorators_tree):
245:    def _transform_decorator(self, decorator_tree):
251:    def _transform_decorator_from_items(self, items):
268:    def _parse_decorator_arguments(self, arguments_tree):
291:    def _transform_parameters(self, parameters_tree):
297:    def _transform_parameter(self, param_tree):
306:    def parameters(self, items):
342:    def parameter(self, items):
364:    def struct_definition(self, items):
385:    def struct_field(self, items):
423:    def agent_definition(self, items):
444:    def agent_field(self, items):
38:    def expr_stmt(self, items):
42:    def return_stmt(self, items):
46:    def break_stmt(self, items):
50:    def continue_stmt(self, items):
54:    def pass_stmt(self, items):
58:    def raise_stmt(self, items):
62:    def assert_stmt(self, items):
68:    def import_stmt(self, items):
73:    def simple_import(self, items):
117:    def from_import(self, items):
211:    def arg_list(self, items):
215:    def positional_args(self, items):
219:    def named_args(self, items):
228:    def named_arg(self, items):
43:    def conditional(self, items):
53:    def if_part(self, items):
59:    def else_part(self, items):
63:    def if_stmt(self, items):
111:    def elif_stmts(self, items):
142:    def elif_stmt(self, items):
152:    def while_stmt(self, items):
161:    def for_stmt(self, items):
209:    def try_stmt(self, items):
239:    def except_clause(self, items):
258:    def except_spec(self, items):
278:    def exception_type(self, items):
295:    def exception_list(self, items):
30:    def variable(self, items):
38:    def scoped_var(self, items):
54:        def raw_name(item):
72:    def simple_name(self, items):
84:    def dotted_access(self, items):
123:    def identifier(self, items):
137:    def _extract_name(self, item):
158:    def _join_dotted(self, parts):
164:    def _insert_scope_if_missing(self, name):
31:    def set_filename(self, filename: str | None) -> None:
35:    def _parse_literal(self, text):
39:    def _create_literal(self, token):
43:    def _insert_local_scope(self, parts: list[str] | str) -> Any:
48:    def get_leaf_node(item: Tree | Token | ASTNode) -> Token | ASTNode:
52:    def flatten_items(self, items):
59:    def unwrap_single_child_tree(self, item, stop_at=None):
73:    def get_location(self, item: Any) -> tuple[int, int] | None:
89:    def create_location(self, item: Any) -> Location | None:
29:    def set_filename(self, filename: str | None) -> None:
42:    def transform(self, tree):
29:    def trailer(self, items):
160:    def argument(self, items):
175:    def _process_function_arguments(self, arg_children):
202:    def slice_or_index(self, items):
206:    def slice_start_only(self, items):
210:    def slice_stop_only(self, items):
214:    def slice_start_stop(self, items):
218:    def slice_start_stop_step(self, items):
222:    def slice_all(self, items):
226:    def slice_step_only(self, items):
230:    def slice_expr(self, items):
235:    def slice_list(self, items):
246:    def _get_full_attribute_name(self, attr):
24:    def extract_operator_string(op_token):
47:    def op_tree_to_str(tree):
55:    def left_associative_binop(items, operator_getter):
79:    def get_binary_operator(op_str):
114:    def atom_from_token(token):
138:    def process_string_literal(item):
179:    def get_full_attribute_name(attr):
27:    def _extract_operator_string(self, op_token):
38:    def _op_tree_to_str(self, tree):
45:    def _left_associative_binop(self, items, operator_getter):
69:    def _get_binary_operator(self, op_str):
99:    def or_expr(self, items):
103:    def and_expr(self, items):
107:    def pipe_expr(self, items):
111:    def not_expr(self, items):
136:    def comparison(self, items):
140:    def sum_expr(self, items):
144:    def term(self, items):
148:    def factor(self, items):
173:    def power(self, items):
193:    def ADD(self, token):
197:    def SUB(self, token):
201:    def MUL(self, token):
205:    def DIV(self, token):
209:    def FDIV(self, token):
213:    def MOD(self, token):
217:    def POW(self, token):
221:    def PIPE(self, token):
225:    def EQ_OP(self, token):
229:    def NE_OP(self, token):
233:    def LT_OP(self, token):
237:    def GT_OP(self, token):
241:    def LE_OP(self, token):
245:    def GE_OP(self, token):
249:    def IN_OP(self, token):
253:    def NOT_IN_OP(self, token):
257:    def IS_OP(self, token):
261:    def IS_NOT_OP(self, token):
265:    def NOT_OP(self, token):
35:    def validate_function_call_trailer(trailer: Any) -> None:
47:    def validate_attribute_trailer(trailer: Any) -> None:
66:    def handle_function_call(self, current_base: Expression, trailer: Any) -> ObjectFunctionCall | FunctionCall:
94:    def _create_method_call(self, attribute_access: AttributeAccess, args: dict[str, Any]) -> ObjectFunctionCall:
103:    def _create_function_call(self, base: Expression, args: dict[str, Any]) -> FunctionCall:
119:    def handle_attribute_access(self, current_base: Expression, trailer: Any) -> AttributeAccess:
149:    def handle_indexing(self, current_base: Expression, trailer: Any) -> SubscriptExpression:
170:    def analyze_chain(self, trailers: list[Any]) -> dict[str, Any]:
198:    def _count_trailer_types(self, trailers: list[Any]) -> dict[str, int]:
230:    def process_trailers(self, base: Expression, trailers: list[Any]) -> Expression:
267:    def _process_single_trailer(self, current_base: Expression, trailer: Any, position: int) -> Expression:
76:    def from_type_hint(type_hint: "TypeHint") -> "DanaType":
103:    def get(self, name: str) -> DanaType | None:
111:    def set(self, name: str, type_: DanaType) -> None:
115:    def register(self, name: str, type_: DanaType) -> None:
119:    def push_scope(self):
123:    def pop_scope(self):
134:    def check_program(self, program: Program) -> None:
139:    def check_statement(self, statement: Any) -> None:
185:    def check_assignment(self, node: Assignment) -> None:
225:    def check_compound_assignment(self, node: CompoundAssignment) -> None:
256:    def check_conditional(self, node: Conditional) -> None:
267:    def check_while_loop(self, node: WhileLoop) -> None:
276:    def check_for_loop(self, node: ForLoop) -> None:
306:    def check_try_block(self, node: TryBlock) -> None:
316:    def check_except_block(self, node: ExceptBlock) -> None:
321:    def check_function_definition(self, node: FunctionDefinition) -> None:
376:    def check_method_definition(self, node: MethodDefinition) -> None:
427:    def check_struct_definition(self, node: StructDefinition) -> None:
442:    def check_import_statement(self, node: ImportStatement) -> None:
446:    def check_import_from_statement(self, node: ImportFromStatement) -> None:
450:    def check_expression(self, expression: Any) -> DanaType:
492:    def check_literal_expression(self, node: LiteralExpression) -> DanaType:
496:    def check_identifier(self, node: Identifier) -> DanaType:
514:    def check_binary_expression(self, node: BinaryExpression) -> DanaType:
580:    def check_unary_expression(self, node: UnaryExpression) -> DanaType:
589:    def check_attribute_access(self, node: AttributeAccess) -> DanaType:
596:    def check_subscript_expression(self, node: SubscriptExpression) -> DanaType:
614:    def check_dict_literal(self, node: DictLiteral) -> DanaType:
623:    def check_set_literal(self, node: SetLiteral) -> DanaType:
629:    def check_tuple_literal(self, node: TupleLiteral) -> DanaType:
635:    def check_list_literal(self, node: ListLiteral) -> DanaType:
641:    def check_function_call(self, node: FunctionCall) -> DanaType:
651:    def check_assert_statement(self, node: AssertStatement) -> None:
661:    def check_raise_statement(self, node: RaiseStatement) -> None:
671:    def check_return_statement(self, node: ReturnStatement) -> None:
677:    def check_use_statement(self, node: UseStatement) -> DanaType:
688:    def check_types(program: Program) -> None:
52:    def is_valid(self) -> bool:
129:    def parse(self, program_text: str, do_transform: bool = True, do_type_check: bool = False, filename: str | None = None) -> Any:
156:    def transform(self, parse_tree: Tree, do_type_check: bool = False) -> Program:
184:    def parse_expression(self, expr_text: str):
208:    def _deprecated_transform_identifier(self, node: Tree) -> Identifier:
224:def parse_program(program_text: str, do_type_check: bool = ENABLE_TYPE_CHECK) -> Program:
103:    def _register_cleanup(self):
109:    def _create_default_context(self) -> SandboxContext:
115:        def feedback_placeholder(result: Any, feedback_data: Any):
123:    def _ensure_initialized(self):
155:    def _can_reuse_shared_resources(self) -> bool:
163:    def _use_shared_resources(self):
171:    def _initialize_new_resources(self):
203:    def _cleanup(self):
247:    def _cleanup_instance_resources(self):
274:    def _cleanup_shared_resources(cls):
301:    def _cleanup_on_deletion(weakref_obj):
322:    def _cleanup_all_instances(cls):
338:    def cleanup_all(cls):
346:    def is_healthy(self) -> bool:
359:    def run_file(self, file_path: str | Path) -> ExecutionResult:
445:    def eval(self, source_code: str, filename: str | None = None) -> ExecutionResult:
529:    def quick_run(cls, file_path: str | Path, debug_mode: bool = False, context: SandboxContext | None = None) -> ExecutionResult:
545:    def quick_eval(
587:    def context(self) -> SandboxContext:
591:    def load_file(self, file_path: str) -> None:
598:    def function_registry(self):
31:    def evaluate(self, context) -> Any:
152:    def type(self):
457:    """Method definition statement with explicit receiver (e.g., def (point: Point) translate(dx, dy):)."""
470:    """Declarative function definition statement (e.g., def func(x: int) -> str = f1 | f2)."""
89:    def parent_context(self) -> Optional["SandboxContext"]:
94:    def manager(self) -> Optional["ContextManager"]:
99:    def manager(self, manager: "ContextManager") -> None:
104:    def interpreter(self) -> "DanaInterpreter":
111:    def interpreter(self, interpreter: "DanaInterpreter"):
120:    def error_context(self):
124:    def get_interpreter(self) -> Optional["DanaInterpreter"]:
132:    def _validate_key(self, key: str) -> tuple[str, str]:
163:    def _normalize_key(self, scope: str, var_name: str) -> str:
175:    def set(self, key: str, value: Any) -> None:
201:    def get(self, key: str, default: Any = None) -> Any:
234:    def get_execution_status(self) -> ExecutionStatus:
242:    def set_execution_status(self, status: ExecutionStatus) -> None:
250:    def add_execution_history(self, entry: dict[str, Any]) -> None:
261:    def reset_execution_state(self) -> None:
267:    def from_dict(cls, data: dict[str, Any], base_context: Optional["SandboxContext"] = None) -> "SandboxContext":
308:    def set_in_scope(self, var_name: str, value: Any, scope: str = "local") -> None:
333:    def has(self, key: str) -> bool:
353:    def delete(self, key: str) -> None:
375:    def clear(self, scope: str | None = None) -> None:
392:    def get_state(self) -> dict[str, dict[str, Any]]:
400:    def set_state(self, state: dict[str, dict[str, Any]]) -> None:
418:    def merge(self, other: "SandboxContext") -> None:
427:    def copy(self) -> "SandboxContext":
456:    def sanitize(self) -> "SandboxContext":
550:    def get_scope(self, scope: str) -> dict[str, Any]:
561:    def set_scope(self, scope: str, context: dict[str, Any] | None = None) -> None:
570:    def get_from_scope(self, var_name: str, scope: str = "local") -> Any:
605:    def get_assignment_target_type(self) -> Any | None:
627:    def set_resource(self, name: str, resource: BaseResource) -> None:
641:    def get_resource(self, name: str) -> BaseResource:
647:    def get_resources(self, included: list[str | BaseResource] | None = None) -> dict[str, BaseResource]:
677:    def soft_delete_resource(self, name: str) -> None:
684:    def list_resources(self) -> list[str]:
693:    def delete_from_scope(self, var_name: str, scope: str = "local") -> None:
721:    def set_agent(self, name: str, agent: BaseResource) -> None:
735:    def get_agent(self, name: str) -> BaseResource:
741:    def get_agents(self, included: list[str | BaseResource] | None = None) -> dict[str, BaseResource]:
757:    def soft_delete_agent(self, name: str) -> None:
764:    def list_agents(self) -> list[str]:
773:    def get_self_agent_card(self, included_resources: list[str | BaseResource] | None = None) -> dict[str, dict[str, Any]]:
810:    def get_other_agent_cards(self, included_agents: list[str | BaseResource] | None = None) -> dict[str, dict[str, Any]]:
816:    def startup(self) -> None:
821:    def shutdown(self) -> None:
37:    def _smart_max(*args):
55:    def _smart_min(*args):
73:    def _smart_sum(*args):
405:    def _semantic_bool_wrapper(cls, value):
416:    def create_function(cls, name: str):
431:        def dana_wrapper(context: SandboxContext, *args, **kwargs):
446:    def _raise_unsupported_error(cls, name: str):
470:    def _handle_unknown_builtin(cls, name: str):
575:    def _validate_args(cls, name: str, args: tuple, expected_signatures: list[tuple]):
618:    def _execute_with_guards(cls, func: callable, args: tuple):
625:    def get_available_functions(cls) -> list[str]:
630:    def get_function_info(cls, name: str) -> dict[str, Any]:
637:    def get_unsupported_functions(cls) -> list[str]:
642:    def get_unsupported_info(cls, name: str) -> dict[str, Any]:
649:    def is_supported(cls, name: str) -> bool:
654:    def is_unsupported(cls, name: str) -> bool:
659:    def get_functions_by_reason(cls, reason: UnsupportedReason) -> list[str]:
664:    def get_security_report(cls) -> dict[str, Any]:
696:def register_pythonic_builtins(registry: FunctionRegistry) -> None:
735:        def create_unsupported_handler(name):
736:            def unsupported_handler(context: SandboxContext, *args, **kwargs):
9:def create_function_with_better_doc_string(func: Callable, doc_string: str) -> Callable:
13:    def wrapper(*args, **kwargs):
17:    async def async_wrapper(*args, **kwargs):
28:def use_function(context: SandboxContext, function_name: str, *args, _name: str | None = None, **kwargs) -> BaseResource:
19:def cast_function(context: SandboxContext, target_type: Any, value: Any) -> Any:
15:def noop_function(
7:def agent_function(context: SandboxContext, *args, _name: str | None = None, **kwargs) -> AbstractDanaAgent:
31:def _create_module_agent(context: SandboxContext, name: str, module, **kwargs) -> AbstractDanaAgent:
60:def _create_a2a_agent(context: SandboxContext, name: str, *args, **kwargs) -> AbstractDanaAgent:
94:def agent_pool_function(context: SandboxContext, *args, _name: str | None = None, **kwargs) -> BaseResource:
20:def register_core_functions(registry: FunctionRegistry) -> None:
16:def load_dana_env(dot_env_file_path: Path | str | None = None):
53:    def _resolve_user_identity(self, provided_user_id: str = None) -> str:
82:    def _resolve_instance_identity(self, provided_instance_id: str = None) -> str:
115:    def _resolve_session_identity(self, provided_session_id: str = None) -> str:
138:    def _initialize_simplified_memory_system(self):
183:    def _initialize_cross_session_persistence(self):
195:    def _restore_session_context(self):
224:    def _wrap_agent_methods(self):
235:    def _context_aware_solve(self, input_data: str, context: str | None = None) -> str:
245:    def _solve_with_memory_system(self, input_data: str, context: str | None = None) -> str:
281:    def _get_memory_context(self, input_data: str) -> dict:
290:    def _store_interaction_in_memory(self, input_data: str, response: str, complete_conversation: str):
299:    def _solve_with_basic_context(self, input_data: str, context: str | None = None) -> str:
330:    def _context_aware_reason(self, prompt: str, **kwargs) -> str:
353:    def _build_contextual_prompt(self, input_data: str) -> str:
393:    def _enhance_prompt_with_context(self, original_prompt: str) -> str:
412:    def _build_memory_enhanced_prompt(self, input_data: str, memory_context: dict) -> str:
448:    def _build_persistent_context_prompt(self, input_data: str, memory_context: dict) -> str:
495:    def _build_memory_context_summary(self, memory_context: dict) -> str:
517:    def _build_memory_enhanced_input(self, input_data: str) -> str:
544:    def _get_comprehensive_memory_context(self) -> str:
585:    def _extract_conversations_from_memories(self, memories) -> list:
634:    def _extract_user_facts_from_memories(self, memories) -> list:
645:    def _build_direct_memory_context(self, memory_items: list) -> str:
661:    def _run_async_safely(self, coro):
668:    def get_context_info(self) -> dict[str, Any]:
699:    def get_conversation_summary(self) -> str:
720:    def get_persistence_status(self) -> dict[str, Any]:
741:    def reset_context(self):
50:    def add_turn(self, user_input: str, agent_response: str, context_used: dict[str, Any] = None):
61:    def get_recent_history(self, n: int = 5) -> list[ConversationTurn]:
65:    def get_conversation_context(self) -> str:
78:    def extract_user_info(self, text: str) -> dict[str, Any]:
106:    def get_user_context(self) -> dict[str, Any]:
120:    def _generate_conversation_summary(self) -> str:
142:    def should_include_context(self) -> bool:
147:    def clear_session(self):
45:def _default_metadata() -> MemoryMetadata:
60:    def content(self) -> str:
64:    def embedding(self) -> list[float] | None:
68:    def memory_type(self) -> MemoryType:
72:    def confidence(self) -> float | None:
85:    def add_memory(self, memory: MemoryItem, target_type: str | None = None):
89:    def get_all_memories(self) -> list[MemoryItem]:
29:    async def initialize(self):
35:    async def extract_memories(self, conversation_content: str, user_id: str) -> list[dict[str, Any]]:
63:    def _build_extraction_prompt(self, content: str) -> str:
113:    def _parse_memory_response(self, response_content: Any, original_content: str) -> list[dict[str, Any]]:
138:    def _validate_memories(self, memories: list[dict[str, Any]]) -> list[dict[str, Any]]:
186:    def _fallback_extraction(self, content: str) -> list[dict[str, Any]]:
232:    async def initialize(self):
238:    async def detect_intent(self, query: str, working_memory: list[MemoryItem]) -> dict[str, Any]:
267:    def _format_memory_context(self, memories: list[MemoryItem]) -> str:
278:    def _build_intent_prompt(self, query: str, memory_context: str) -> str:
302:    def _parse_intent_response(self, response_content: Any, query: str) -> dict[str, Any]:
332:    def _fallback_intent_detection(self, query: str, working_memory: list[MemoryItem]) -> dict[str, Any]:
361:    async def initialize(self):
367:    async def rank_memories(self, query: str, memories: list[MemoryItem]) -> list[MemoryItem]:
403:    def _build_ranking_prompt(self, query: str, memory_texts: list[str]) -> str:
423:    def _parse_ranking_response(self, response_content: Any, memories: list[MemoryItem]) -> list[MemoryItem]:
457:    def _simple_rank_memories(self, query: str, memories: list[MemoryItem]) -> list[MemoryItem]:
465:        def relevance_score(memory: MemoryItem) -> float:
21:    def _serialize_memory_item(self, memory: MemoryItem) -> dict[str, Any]:
41:    def _deserialize_memory_item(self, data: dict[str, Any]) -> MemoryItem:
63:    def _load_memories(self) -> list[MemoryItem]:
76:    def _save_memories(self, memories: list[MemoryItem]):
82:    def _text_search(self, memories: list[MemoryItem], query: str, limit: int) -> list[MemoryItem]:
127:    async def store(self, memory: MemoryItem) -> bool:
145:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
153:    async def search_by_text(self, query: str, limit: int = 10) -> list[MemoryItem]:
159:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
168:    def _is_duplicate(self, new_memory: MemoryItem, existing_memories: list[MemoryItem]) -> bool:
202:    async def store(self, memory: MemoryItem) -> bool:
210:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
216:    async def search_by_text(self, query: str, limit: int = 10) -> list[MemoryItem]:
222:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
231:    async def get_user_profile_summary(self) -> dict[str, Any]:
279:    async def store(self, memory: MemoryItem) -> bool:
298:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
304:    async def search_by_text(self, query: str, limit: int = 10) -> list[MemoryItem]:
310:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
319:    def _should_share(self, memory: MemoryItem) -> bool:
348:    def _sanitize_memory(self, memory: MemoryItem) -> MemoryItem:
361:    async def get_collective_stats(self) -> dict[str, Any]:
12:    async def store(self, memory: MemoryItem) -> bool:
16:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
20:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
41:    def _get_storage_file_path(self) -> Path:
47:    def _load_memories(self):
60:    def _save_memories(self):
77:    def _serialize_memory(self, memory: MemoryItem) -> dict:
97:    def _deserialize_memory(self, data: dict) -> MemoryItem | None:
123:    async def store(self, memory: MemoryItem) -> bool:
131:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
136:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
143:    def clear_and_keep_recent(self, keep_count: int = 10):
150:    def replace_with_items(self, items_to_keep: list):
165:    async def store(self, memory: MemoryItem) -> bool:
173:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
178:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
194:    async def store(self, memory: MemoryItem) -> bool:
199:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
203:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
221:    async def store(self, memory: MemoryItem) -> bool:
228:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
232:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
67:    def _initialize_index(self):
98:    def _load_memory_metadata(self):
130:    def _save_memory_metadata(self):
158:    def _create_document_from_memory(self, memory: MemoryItem) -> Document:
176:    async def store(self, memory: MemoryItem) -> bool:
207:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
215:    async def search_by_text(self, query: str, limit: int) -> list[MemoryItem]:
242:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
247:    def get_query_engine(self, similarity_top_k: int = 10):
264:    def get_memory_count(self) -> int:
282:    async def store(self, memory: MemoryItem) -> bool:
300:    def _is_semantic_duplicate(self, new_content: str, existing_content: str) -> bool:
325:    async def get_user_profile_summary(self, query: str = "user preferences and characteristics") -> str:
347:    async def search_user_preferences(self, topic: str, limit: int = 10) -> list[MemoryItem]:
375:    async def store(self, memory: MemoryItem) -> bool:
403:    def _should_store_in_shared(self, memory: MemoryItem) -> bool:
432:    async def _rebuild_index(self):
462:    async def search_collective_knowledge(self, query: str, limit: int = 10) -> list[MemoryItem]:
466:    async def get_popular_topics(self, limit: int = 10) -> list[str]:
81:    def _count_tokens(self, text: str) -> int:
87:    def _get_working_memory_token_count(self, memories: list[MemoryItem]) -> int:
92:    def _get_recent_items_by_token_limit(self, memories: list[MemoryItem], token_limit: int) -> list[MemoryItem]:
113:    async def add_conversation_memory(self, memory_content: str) -> list[MemoryItem]:
142:    async def process_working_memory_batch(self):
222:    async def manual_batch_process(self):
226:    async def chat_with_memory(self, query: str) -> dict[str, Any]:
255:    async def retrieve_context(self, query: str) -> list[str]:
274:    async def get_user_profile(self) -> dict[str, Any]:
300:    async def advanced_query(self, query: str, memory_type: str = "long_term") -> str:
328:    async def search_by_text(self, query: str, memory_type: str = "all", limit: int = 10) -> list[MemoryItem]:
357:    async def get_current_working_memory_tokens(self) -> int:
362:    async def get_memory_statistics(self) -> dict[str, Any]:
409:    async def _search_persistent_memories(self, missing_evidence: list[str]) -> list[MemoryItem]:
426:    async def _replace_working_memory_with_llm_ranking(self, query: str, original: list[MemoryItem], retrieved: list[MemoryItem]) -> None:
88:    def with_planning(
121:    def with_reasoning(
152:    def _create_llm(self, llm: dict | str | LLMResource, name: str) -> LLMResource:
164:    def runtime_context(self) -> RuntimeContext:
171:    def planner(self) -> Planner:
178:    def planner(self, planner: Planner | None) -> None:
183:    def reasoner(self) -> Reasoner:
190:    def reasoner(self, reasoner: Reasoner | None) -> None:
195:    def _current_plan(self) -> Plan:
210:        def handle_plan_get(key: str, default: Any) -> Any:
214:        def handle_plan_set(key: str, value: Any) -> None:
231:    async def execute(self, plan: "Plan") -> Any:
30:    def create_agent(cls, config: dict[str, Any]) -> Agent:
18:def default_plan_method(context: SandboxContext, agent_instance: "AgentInstance", task: str, user_context: dict | None = None) -> Any:
39:def default_solve_method(context: SandboxContext, agent_instance: "AgentInstance", problem: str, user_context: dict | None = None) -> Any:
75:    def add_method(self, method_name: str, method_func: Any) -> None:
78:    def get_method(self, method_name: str) -> Any | None:
87:    def has_method(self, method_name: str) -> bool:
130:    def _initialize_context_management(self):
141:    def agent_card(self) -> dict[str, Any]:
158:    def skills(self) -> list[dict[str, Any]]:
162:    def agent_type(self) -> AgentType:
165:    def solve(self, task: str) -> str:
179:    def plan(self, task: str, user_context: dict | None = None) -> Any:
182:    def get_context_info(self) -> dict:
189:    def get_conversation_summary(self) -> str:
196:    def reset_context(self):
201:    def get_persistence_status(self) -> dict:
208:    def _call_method(self, method, *args, **kwargs):
244:    def _call_method_with_current_context(self, method, *args, **kwargs):
269:    def _get_current_execution_context(self):
307:    def call_method(self, method_name: str, *args: Any, **kwargs: Any) -> Any:
314:    def to_dict(self) -> dict[str, Any]:
321:    def _try_global_function_fallback(self, method_name: str) -> Any | None:
340:                def agent_method_wrapper(*args, **kwargs):
351:    def _function_matches_agent_type(self, func: Any, agent_type_name: str) -> bool:
394:    def _get_function_registry(self):
419:    def register(cls, agent_type: AgentType) -> None:
423:    def get(cls, agent_name: str) -> AgentType | None:
427:    def exists(cls, agent_name: str) -> bool:
431:    def list_types(cls) -> list[str]:
435:    def clear(cls) -> None:
439:    def create_instance(cls, agent_name: str, values: dict[str, Any], context: SandboxContext, instance_id: str = None) -> AgentInstance:
447:def create_agent_type_from_ast(agent_def) -> AgentType:
468:def register_agent_from_ast(agent_def) -> AgentType:
474:def create_agent_instance(agent_name: str, context: SandboxContext, **kwargs) -> AgentInstance:
478:def register_agent_method_from_function_def(node, dana_func):
67:    def _load_default_config(self) -> dict[str, Any]:
79:    def _find_first_available_model(self) -> str | None:
112:    def _get_required_env_vars_for_model(self, model_name: str) -> list[str]:
143:    def _load_from_file(self, config_path: str) -> None:
185:    def _load_json_file(self, path: Path) -> None:
204:    def _update_logging_from_env(self) -> None:
208:        def safe_int(value: str, default: int) -> int:
225:    def get(self, key: str, default: Any = None) -> Any:
229:    def update(self, config: dict[str, Any]) -> None:
53:    def new_instance(cls, response: BaseResponse | dict[str, Any] | Any) -> "AgentResponse":
97:    def state(self) -> AgentState:
104:    def runtime(self) -> AgentRuntime:
111:    def agent_llm(self) -> LLMResource:
118:    def available_resources(self) -> dict[str, BaseResource]:
125:    def capabilities(self) -> dict[str, BaseCapability]:
132:    def io(self) -> BaseIO:
139:    def with_model(self, model: str) -> "Agent":
144:    def with_llm(self, llm: dict | str | LLMResource) -> "Agent":
154:    def with_resources(self, resources: dict[str, BaseResource]) -> "Agent":
161:    def with_capabilities(self, capabilities: dict[str, BaseCapability]) -> "Agent":
168:    def with_io(self, io: BaseIO) -> "Agent":
173:    def with_planning(
189:    def with_reasoning(
206:    def _get_default_llm_resource(self):
210:    def _create_llm(self, llm: dict | str | LLMResource, name: str) -> LLMResource:
221:    def _initialize(self) -> "Agent":
236:    async def cleanup(self) -> None:
242:    async def initialize(self) -> "Agent":
256:    async def async_run(self, plan: Plan, context: RuntimeContext | None = None) -> AgentResponse:
262:    def run(self, plan: Plan) -> AgentResponse:
265:        async def _run_async():
270:    def ask(self, question: str) -> AgentResponse:
275:    def runtime_context(self) -> RuntimeContext:
280:    async def set_variable(self, name: str, value: Any) -> BaseResponse:
285:    async def query(self, request: BaseRequest) -> BaseResponse:
289:    def has_capability(self, capability: BaseCapability | str) -> bool:
303:    def add_capability(self, name: str, capability: BaseCapability) -> None:
312:    def remove_capability(self, name: str) -> None:
57:    async def create(cls, name: str, agent: "Agent", description: str) -> "AgentResource":
73:    async def query(self, request: BaseRequest | None = None) -> BaseResponse:
99:    async def initialize(self) -> None:
111:    async def cleanup(self) -> None:
98:    def expertise(self) -> DomainExpertise | None:
103:    def confidence_threshold(self) -> float:
108:    def system_prompt(self) -> str | None:
113:    def llm_config(self) -> dict[str, Any]:
117:    async def initialize(self) -> None:
123:    async def query(self, request: BaseRequest | None = None) -> BaseResponse:
143:    async def cleanup(self) -> None:
148:    def can_handle(self, request: dict[str, Any]) -> bool:
16:    def create_resource(cls, resource_type: str, config: dict[str, Any]) -> BaseResource:
25:    def create_llm_resource(cls, config: dict[str, Any]) -> LLMResource:
16:def main():
28:def parse_dana_input_args(input_strs: list[str] | tuple[str, ...]) -> dict[str, str]:
72:    def resolve_at_file(value: str, is_file: bool) -> str:
46:    def mcp_tool_decorator(self, func_name: str) -> Any:
49:        def wrapper(**kwargs) -> Any:
78:    async def initialize(self) -> None:
83:    async def _discover_tools(self) -> None:
94:    def _list_tools(self, format_converter: OpenAIToolFormat) -> list[Any]:
105:    async def call_tool(self, tool_name: str, arguments: dict[str, Any]) -> Any:
123:    async def query(self, request: BaseRequest) -> BaseResponse:
145:    def can_handle(self, request: BaseRequest) -> bool:
159:    async def main():
12:    def parse_init_params(cls, *args, **kwargs) -> ParsedArgKwargsResults:
86:    def _validate_transport(cls, *args, **kwargs) -> BaseTransport:
96:    async def _try_client_with_valid_transport(cls, transport: BaseTransport) -> bool:
6:def extract_text_from_response(response: Message) -> str:
34:    def select_agent(self, task: any, strategy: str = "llm", included_resources: list[str | Any] | None = None) -> Any:
52:    def _select_by_llm(self, task: any, included_resources: list[str | Any] | None = None) -> Any:
126:    def _get_agent_skills(self, agent: Any) -> list[str]:
139:    def _format_agent_cards(self, cards: dict[str, dict]) -> str:
168:    def update_performance_metrics(self, agent_name: str, metrics: dict[str, float]) -> None:
82:    def get_base_path(cls) -> Path:
91:    def get_config_path(
163:    def from_dict(cls, data: dict[str, Any]) -> "Configurable":
183:    def _load_config(self, config_path: str | Path | None = None) -> dict[str, Any]:
218:    def _apply_overrides(self, overrides: dict[str, Any]) -> None:
232:    def _validate_required(self, key: str, error_msg: str | None = None) -> None:
256:    def _validate_type(self, key: str, expected_type: type[T], error_msg: str | None = None) -> None:
282:    def _validate_enum(self, key: str, valid_values: list[Any], error_msg: str | None = None) -> None:
308:    def _validate_path(self, key: str, must_exist: bool = True, error_msg: str | None = None) -> None:
334:    def _validate_config(self) -> None:
350:    def get(self, key: str, default: Any = None) -> Any:
362:    def set(self, key: str, value: Any) -> None:
375:    def update(self, config: dict[str, Any]) -> None:
387:    def to_dict(self) -> dict[str, Any]:
395:    def save(self, path: str | Path) -> None:
418:    def get_yaml_path(cls, path: str | None = None) -> Path:
474:    def get_prompt(cls, config_path: str | None = None, prompt_ref: str | None = None, custom_prompts: dict[str, str] | None = None) -> str:
521:    def load_config(cls, path: str | None = None) -> dict[str, Any]:
29:def configure_asyncio_threshold():
66:    def load_yaml_config(path: str | Path) -> dict[str, Any]:
90:    def _resolve_yaml_path(path: Path) -> Path:
105:    def get_class_by_name(class_path: str) -> type[Any]:
116:    def get_base_path(for_class: type[Any]) -> Path:
121:    def get_config_path(
174:    def safe_asyncio_run(func: Callable[..., Any], *args: Any, **kwargs: Any) -> Any:
206:    def _run_in_existing_loop(func: Callable[..., Any], *args: Any, **kwargs: Any) -> Any:
216:        def run_in_thread():
225:    def get_field(obj: dict | object, field_name: str, default: Any = None) -> Any:
241:    def has_field(obj: dict | object, field_name: str) -> bool:
248:    def generate_base64_uuid(length: int | None = None) -> str:
278:    def parse_args_kwargs(func, *args, **kwargs) -> ParsedArgKwargsResults:
343:    def get_hash(key: str, length: int | None = None) -> str:
350:    def generate_uuid(length: int | None = None) -> str:
358:    def text_to_dict(text: str) -> dict[str, Any]:
378:    def get_response_content(response: BaseResponse) -> Any:
39:    def build_request_params(
75:    def get_openai_functions(self, resources: dict[str, BaseResource]) -> list[OpenAIFunctionCall]:
89:    async def call_requested_tools(self, tool_calls: list[OpenAIFunctionCall]) -> list[dict[str, Any]]:
189:    async def call_tools_legacy(self, tool_calls: list[dict[str, Any]], available_resources: list[BaseResource]) -> list[BaseResponse]:
218:    def format_tool_call_message(self, response_message: dict[str, Any], tool_calls: list[OpenAIFunctionCall]) -> dict[str, Any]:
236:    def has_tool_calls(self, response_message: dict[str, Any]) -> bool:
250:    def register_resources(self, available_resources: dict[str, Any]) -> None:
259:    def unregister_resources(self, available_resources: dict[str, Any]) -> None:
38:    async def initialize(self) -> None:
45:    async def query(self, query: str, num_results: int = 10) -> str:
136:    def _validate_decay_parameters(self) -> None:
150:    def decay_rate(self) -> float:
155:    def decay_rate(self, value: float) -> None:
174:    def half_life(self) -> float:
186:    def decay_interval(self) -> int:
191:    def decay_interval(self, value: int) -> None:
209:    def _should_decay(self) -> bool:
221:    async def _maybe_decay(self) -> None:
240:            def run_decay():
247:    async def decay_memories(self, intervals_passed: float = 1.0) -> None:
280:    async def initialize(self) -> None:
287:    async def cleanup(self) -> None:
295:    async def store(
339:    async def retrieve(self, query: str | None = None, limit: int | None = None) -> BaseResponse:
364:    async def update_importance(self, memory_id: int, importance: float) -> BaseResponse:
384:    def get_decay_stats(self) -> dict[str, Any]:
403:    def can_handle(self, request: dict[str, Any]) -> bool:
449:    def can_handle(self, request: dict[str, Any]) -> bool:
495:    def can_handle(self, request: dict[str, Any]) -> bool:
541:    async def _maybe_decay(self) -> None:
545:    async def decay_memories(self, intervals_passed: float = 1.0) -> None:
549:    def get_decay_stats(self) -> dict[str, Any]:
559:    def can_handle(self, request: dict[str, Any]) -> bool:
17:async def configure_poet(config: dict[str, Any]):
50:async def get_poet_domains():
21:async def upload_document(
43:async def create_document(
69:async def get_document(document_id: int, db: Session = Depends(get_db), document_service=Depends(get_document_service)):
85:async def list_documents(
104:async def download_document(document_id: int, db: Session = Depends(get_db), document_service=Depends(get_document_service)):
126:async def update_document(
144:async def delete_document(document_id: int, db: Session = Depends(get_db), document_service=Depends(get_document_service)):
40:async def generate_agent(request: AgentGenerationRequest, agent_service=Depends(get_agent_service)):
117:async def refine_agent_description(request: AgentDescriptionRequest, db: Session = Depends(get_db)):
196:async def generate_agent_code(request: AgentCodeGenerationRequest, agent_service=Depends(get_agent_service)):
234:async def deploy_agent(request: AgentDeployRequest, db: Session = Depends(get_db)):
284:async def check_dana_syntax(request: DanaSyntaxCheckRequest):
307:async def validate_code(request: CodeValidationRequest):
330:async def fix_code(request: CodeFixRequest):
358:async def process_agent_documents(request: ProcessAgentDocumentsRequest, agent_service=Depends(get_agent_service)):
394:async def list_agents(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
418:async def get_agent(agent_id: int, db: Session = Depends(get_db)):
444:async def create_agent(agent: AgentCreate, db: Session = Depends(get_db)):
470:async def update_agent(agent_id: int, agent: AgentCreate, db: Session = Depends(get_db)):
503:async def delete_agent(agent_id: int, db: Session = Depends(get_db)):
525:async def generate_agent_from_prompt(
560:async def update_agent_description(agent_id: int, request: AgentDescriptionRequest, agent_service=Depends(get_agent_service)):
585:async def validate_agent_code(request: CodeValidationRequest):
599:async def fix_agent_code(request: CodeFixRequest):
613:async def upload_knowledge_file(
668:async def open_file(file_path: str):
681:def _extract_agent_info_from_code(dana_code: str) -> tuple[str | None, str | None]:
19:async def send_chat_message(request: ChatRequest, db: Session = Depends(get_db), chat_service=Depends(get_chat_service)):
19:async def create_topic(request: TopicCreate, db: Session = Depends(get_db), topic_service=Depends(get_topic_service)):
33:async def get_topic(topic_id: int, db: Session = Depends(get_db), topic_service=Depends(get_topic_service)):
49:async def list_topics(
63:async def update_topic(topic_id: int, topic_data: TopicCreate, db: Session = Depends(get_db), topic_service=Depends(get_topic_service)):
81:async def delete_topic(topic_id: int, db: Session = Depends(get_db), topic_service=Depends(get_topic_service)):
19:async def create_conversation(
33:async def get_conversation(
54:async def list_conversations(
72:async def update_conversation(
90:async def delete_conversation(conversation_id: int, db: Session = Depends(get_db), conversation_service=Depends(get_conversation_service)):
107:async def create_message(
121:async def list_messages(
139:async def get_message(
157:async def update_message(
179:async def delete_message(
16:def get_db():
49:async def generate_agent_na(request: AgentGeneratorNARequest):
148:def health():
26:def run_na_file(request: RunNAFileRequest):
31:async def write_multi_file_project(project: MultiFileProject):
77:async def write_multi_file_project_temp(project: MultiFileProject):
124:async def validate_multi_file_project(project: MultiFileProject):
174:            if "agent" in file_info.content.lower() and "def solve" not in file_info.content:
186:        def has_circular_deps(filename, visited=None, path=None):
228:async def open_agent_folder(request: dict):
263:async def get_task_status(task_id: str):
288:async def deep_train_agent(request: dict):
38:async def _llm_fallback(agent_name: str, agent_description: str, message: str) -> str:
109:async def test_agent(request: AgentTestRequest):
10:def health():
15:def get_root_info():
34:def serve_react_index():
12:def run_na_file_service(request: RunNAFileRequest):
23:async def lifespan(app: FastAPI):
31:def create_app():
86:    async def serve_spa(full_path: str):
119:    def startup(self) -> None:
137:    def shutdown(self) -> None:
155:    def get_client(self) -> APIClient:
163:    def local_mode(self) -> bool:
169:    def _load_config(self) -> None:
198:    def _normalize_service_uri(self) -> None:
221:    def _init_api_client(self) -> None:
229:    def _start_local_server(self) -> None:
284:    def _is_server_running(self, port: int) -> bool:
294:    def _find_free_port(self) -> int:
300:    def _wait_for_server_ready(self, port: int, timeout: int = 30) -> None:
319:    def _validate_remote_connection(self) -> None:
343:    def check_health(self) -> bool:
362:    def get_service_uri(self) -> str:
366:    def get_api_key(self) -> str:
9:def main() -> None:
6:def get_multi_file_agent_generation_prompt(intentions: str, current_code: str = "", has_docs_folder: bool = False) -> str:
42:def solve(self : RetrievalExpertAgent, query: str) -> str:
65:def search_document(package: RetrievalPackage) -> RetrievalPackage:
72:def refine_query(package: RetrievalPackage) -> RetrievalPackage:
77:def should_use_rag(package: RetrievalPackage) -> RetrievalPackage:
81:def get_answer(package: RetrievalPackage) -> str:
6:def generate_mock_agent_code(messages, current_code=""):
34:def solve(weather_agent : WeatherAgent, problem : str):
46:def solve(assistant_agent : AssistantAgent, problem : str):
62:def solve(data_agent : DataAgent, problem : str):
78:def solve(document_agent : DocumentAgent, problem : str):
94:def solve(email_agent : EmailAgent, problem : str):
110:def solve(knowledge_agent : KnowledgeAgent, problem : str):
122:def solve(custom_agent : CustomAgent, problem : str):
42:    def startup(self) -> None:
63:    def shutdown(self) -> None:
75:    def _ensure_started(self) -> None:
80:    def post(self, endpoint: str, data: dict[str, Any]) -> dict[str, Any]:
118:    def get(self, endpoint: str, params: dict[str, Any] | None = None) -> dict[str, Any]:
153:    def health_check(self) -> bool:
178:    def close(self):
193:def create_client(base_uri: str, api_key: str | None = None) -> APIClient:
24:    async def process_chat_message(self, chat_request: ChatRequest, db_session) -> ChatResponse:
81:    async def _get_or_create_conversation(self, chat_request: ChatRequest, db_session) -> Conversation:
102:    async def _save_message(self, conversation_id: int, sender: str, content: str, db_session) -> Message:
113:    async def _generate_agent_response(self, chat_request: ChatRequest, conversation: Conversation, db_session) -> str:
124:def get_chat_service() -> ChatService:
24:    async def create_conversation(self, conversation_data: ConversationCreate, db_session) -> ConversationRead:
54:    async def get_conversation(
110:    async def list_conversations(
144:    async def update_conversation_title(self, conversation_id: int, new_title: str, db_session) -> ConversationRead | None:
178:    async def update_conversation(self, conversation_id: int, conversation_data: ConversationCreate, db_session) -> ConversationRead | None:
213:    async def create_message(self, conversation_id: int, message_data: MessageCreate, db_session) -> MessageRead:
245:    async def list_messages(self, conversation_id: int, limit: int = 100, offset: int = 0, db_session=None) -> list[MessageRead]:
284:    async def get_message(self, conversation_id: int, message_id: int, db_session) -> MessageRead | None:
315:    async def update_message(self, conversation_id: int, message_id: int, message_data: MessageCreate, db_session) -> MessageRead | None:
352:    async def delete_message(self, conversation_id: int, message_id: int, db_session) -> bool:
378:    async def delete_conversation(self, conversation_id: int, db_session) -> bool:
408:    async def add_message(self, conversation_id: int, message_data: MessageCreate, db_session) -> MessageRead:
440:    async def get_conversation_messages(
486:def get_conversation_service() -> ConversationService:
34:    async def upload_document(
99:    async def get_document(self, document_id: int, db_session) -> DocumentRead | None:
131:    async def update_document(self, document_id: int, document_data: DocumentUpdate, db_session) -> DocumentRead | None:
178:    async def delete_document(self, document_id: int, db_session) -> bool:
210:    async def list_documents(
255:    async def get_file_path(self, document_id: int, db_session) -> str | None:
277:    def _get_mime_type(self, filename: str) -> str:
311:def get_document_service() -> DocumentService:
26:    async def create_topic(self, topic_data: TopicCreate, db_session) -> TopicRead:
58:    async def get_topic(self, topic_id: int, db_session) -> TopicRead | None:
83:    async def get_topic_by_name(self, name: str, db_session) -> TopicRead | None:
108:    async def list_topics(self, limit: int = 100, offset: int = 0, search: str | None = None, db_session=None) -> list[TopicRead]:
140:    async def update_topic(self, topic_id: int, topic_data: TopicCreate, db_session) -> TopicRead | None:
182:    async def delete_topic(self, topic_id: int, db_session) -> bool:
216:    async def get_topic_statistics(self, topic_id: int, db_session) -> dict[str, Any]:
255:def get_topic_service() -> TopicService:
13:    def clean_generated_code(code: str) -> str:
79:    def parse_multi_file_response(response: str) -> dict:
209:                if line.startswith("def "):
218:                    stub_lines.append(f"def {tool}(query: str) -> str:")
232:    def ensure_all_files_present(project: dict) -> dict:
258:    def get_file_template(filename: str) -> str:
268:def solve(self : Georgia, query: str) -> str:
282:def process_request(package: AgentPackage) -> AgentPackage:
287:def generate_response(package: AgentPackage) -> str:
316:    def determine_file_type(filename: str) -> str:
332:    def get_file_description(filename: str) -> str:
344:    def extract_dependencies(content: str) -> list[str]:
360:    def get_fallback_template() -> str:
369:def solve(basic_agent : BasicAgent, problem : str):
45:    async def initialize(self):
59:    async def generate_agent_code(
156:    async def generate_agent_files_from_prompt(
242:    async def analyze_agent_capabilities(
320:    async def analyze_conversation_completeness(self, messages: list[dict[str, Any]]) -> dict[str, Any]:
393:    async def cleanup(self):
400:    async def _extract_user_intentions(self, messages: list[dict[str, Any]], current_code: str = "") -> str:
442:    def _extract_requirements(self, messages: list[dict[str, Any]]) -> str:
452:    def _create_generation_prompt(self, intentions: str, current_code: str = "", multi_file: bool = False) -> str:
480:    def _create_phase_2_prompt(self, prompt: str, messages: list[dict[str, Any]], agent_summary: dict[str, Any], multi_file: bool) -> str:
505:    def _create_capabilities_analysis_prompt(self, conversation_text: str, all_code_content: str) -> str:
519:    def _extract_response_content(self, result) -> str:
533:    def _extract_summary_from_code_and_conversation(self, dana_code: str, conversation_text: str) -> str:
555:    def _extract_knowledge_domains_from_code(self, dana_code: str, conversation_text: str) -> list[str]:
562:    def _extract_workflow_steps_from_code(self, dana_code: str, conversation_text: str) -> list[str]:
571:    def _extract_agent_tools_from_code(self, dana_code: str) -> list[str]:
583:async def get_agent_service() -> AgentService:
599:def get_multi_file_agent_generation_prompt(intentions: str, current_code: str = "", has_docs_folder: bool = False) -> str:
635:def solve(self : RetrievalExpertAgent, query: str) -> str:
658:def search_document(package: RetrievalPackage) -> RetrievalPackage:
665:def refine_query(package: RetrievalPackage) -> RetrievalPackage:
670:def should_use_rag(package: RetrievalPackage) -> RetrievalPackage:
674:def get_answer(package: RetrievalPackage) -> str:
806:def generate_mock_agent_code(messages, current_code=""):
834:def solve(weather_agent : WeatherAgent, problem : str):
846:def solve(assistant_agent : AssistantAgent, problem : str):
862:def solve(data_agent : DataAgent, problem : str):
878:def solve(document_agent : DocumentAgent, problem : str):
894:def solve(email_agent : EmailAgent, problem : str):
910:def solve(knowledge_agent : KnowledgeAgent, problem : str):
922:def solve(custom_agent : CustomAgent, problem : str):
45:    async def initialize(self):
59:    async def generate_agent_code(
159:    async def _extract_user_intentions(self, messages: list[dict[str, Any]], current_code: str = "") -> str:
224:    def _extract_requirements(self, messages: list[dict[str, Any]]) -> str:
245:    def _create_generation_prompt(self, intentions: str, current_code: str = "", multi_file: bool = False) -> str:
293:def solve([agent_name] : [AgentName], problem : str):
341:def solve([agent_name] : [AgentName], problem : str):
362:    async def cleanup(self):
373:async def get_agent_generator() -> AgentGenerator:
391:async def generate_agent_code_from_messages(
416:async def generate_agent_code_na(messages: list[dict[str, Any]], current_code: str = "") -> tuple[str, str | None]:
492:def _create_agent_generator_na_code(messages: list[dict[str, Any]], current_code: str) -> str:
519:def extract_intentions(messages: list) -> str:
551:def generate_agent_code(messages: list, current_code: str) -> str:
574:- Function parameters must be unquoted: def solve(agent_name : AgentName, problem : str)
576:- **All function definitions (like def solve(...)) must be outside the agent block. The agent block should only contain attribute assignments.**
589:def solve([agent_name] : [AgentName], problem : str):
625:def _test_generated_code(code: str) -> Any:
665:async def _fix_generated_code_with_agent(code: str, error: str, messages: list[dict[str, Any]]) -> str:
722:def _create_code_fixer_na_code(code: str, error: str, messages: list[dict[str, Any]]) -> str:
754:def solve(code_fixer : CodeFixerAgent, problem : str):
776:- Function parameters must be unquoted: def solve(agent_name : AgentName, problem : str)
778:- **All function definitions (like def solve(...)) must be outside the agent block. The agent block should only contain attribute assignments.**
791:def solve([agent_name] : [AgentName], problem : str):
814:def _generate_simple_fallback_agent(messages: list[dict[str, Any]]) -> str:
883:def solve({agent_name.lower()} : {agent_name}, problem : str):
891:async def analyze_conversation_completeness(messages: list[dict[str, Any]]) -> dict[str, Any]:
988:async def analyze_agent_capabilities(
1119:def _extract_summary_from_code_and_conversation(dana_code: str, conversation_text: str) -> str:
1232:def _extract_knowledge_domains_from_code(dana_code: str, conversation_text: str) -> list[str]:
1292:def _extract_workflow_steps_from_code(dana_code: str, conversation_text: str) -> list[str]:
1361:def _extract_agent_tools_from_code(dana_code: str) -> list[str]:
1407:        if line.strip().startswith("def ") and "solve(" not in line:
1408:            func_name = line.strip().split("(")[0].replace("def ", "")
1482:def _extract_solve_function_content(dana_code: str) -> str:
1489:        if "def solve(" in line:
1501:def _extract_agent_name_from_code(dana_code: str) -> str:
1510:def _extract_agent_description_from_code(dana_code: str) -> str:
1519:def _get_fallback_template() -> str:
1534:def solve(basic_agent : BasicAgent, problem : str):
1543:async def generate_agent_files_from_prompt(
1658:def _create_phase_2_prompt(prompt: str, messages: list[dict[str, Any]], agent_summary: dict[str, Any], multi_file: bool) -> str:
1715:def solve(self : {agent_class}, query: str) -> str:
1729:def search_document(package: RetrievalPackage) -> RetrievalPackage:
1736:def refine_query(package: RetrievalPackage) -> RetrievalPackage:
1741:def should_use_rag(package: RetrievalPackage) -> RetrievalPackage:
1745:def get_answer(package: RetrievalPackage) -> str:
1940:def get_multi_file_agent_generation_prompt(intentions: str, current_code: str = "", has_docs_folder: bool = False) -> str:
1976:def solve(self : RetrievalExpertAgent, query: str) -> str:
1999:def search_document(package: RetrievalPackage) -> RetrievalPackage:
2006:def refine_query(package: RetrievalPackage) -> RetrievalPackage:
2011:def should_use_rag(package: RetrievalPackage) -> RetrievalPackage:
2015:def get_answer(package: RetrievalPackage) -> str:
2147:def generate_mock_agent_code(messages, current_code=""):
2175:def solve(weather_agent : WeatherAgent, problem : str):
2187:def solve(assistant_agent : AssistantAgent, problem : str):
2203:def solve(data_agent : DataAgent, problem : str):
2219:def solve(document_agent : DocumentAgent, problem : str):
2235:def solve(email_agent : EmailAgent, problem : str):
2251:def solve(knowledge_agent : KnowledgeAgent, problem : str):
2263:def solve(custom_agent : CustomAgent, problem : str):
42:    async def create_agent_description(
121:    async def generate_agent_code(self, agent_metadata: dict[str, Any], messages: list[dict[str, Any]], prompt: str = "") -> dict[str, Any]:
184:    async def upload_knowledge_file(
284:    async def update_agent_description(self, agent_metadata: dict[str, Any], messages: list[dict[str, Any]]) -> dict[str, Any]:
304:    def get_agent_folder(self, agent_id: int) -> Path | None:
319:    def _create_agent_folder(self, agent_id: int, agent_name: str) -> Path:
327:    async def _extract_agent_requirements(self, messages: list[dict[str, Any]]) -> dict[str, Any]:
472:    def _merge_agent_requirements(self, new_requirements: dict[str, Any], existing_data: dict[str, Any]) -> dict[str, Any]:
501:    async def _generate_intelligent_response(
512:    def _is_ready_for_code_generation(self, agent_requirements: dict[str, Any], conversation_analysis: dict[str, Any]) -> bool:
523:    async def _analyze_capabilities_for_description(self, messages: list[dict[str, Any]]) -> AgentCapabilities | None:
537:    async def _store_multi_file_project(
556:    def _create_multi_file_project_object(self, multi_file_project: dict[str, Any]) -> MultiFileProject:
577:    async def _update_tools_with_rag(self, agent_folder: Path):
598:    async def _clear_rag_cache(self, agent_folder: Path):
605:    async def _regenerate_agent_with_knowledge(
710:    async def _generate_consistent_summary_with_knowledge(
821:    async def _generate_llm_summary_with_knowledge(
985:    def _format_conversation_context(self, conversation_context: list[dict[str, Any]]) -> str:
994:    def _format_existing_capabilities(self, existing_capabilities: dict[str, Any]) -> str:
1024:    def _fallback_summary_enhancement(
1046:    def _merge_capabilities_with_knowledge(self, existing_capabilities: dict[str, Any], uploaded_filename: str) -> dict[str, Any]:
1112:    def _enhance_description_with_knowledge(self, existing_description: str, filename: str, requirements: dict[str, Any]) -> str:
1129:    def _enhance_capabilities_with_knowledge(self, existing_capabilities: Any, filename: str) -> dict[str, Any]:
1133:    def _generate_knowledge_follow_up(self, filename: str, requirements: dict[str, Any]) -> str:
1138:    async def _check_ready_for_code_generation(self, conversation_context: list[dict[str, Any]], agent_metadata: dict[str, Any]) -> bool:
1154:    async def _generate_upload_response(
1198:def get_agent_manager() -> AgentManager:
62:    def generate_enhanced_function(self, func_info: FunctionInfo) -> str:
83:    def generate_perceive(self, func_info: FunctionInfo) -> CodeBlock:
94:    def generate_operate(self, func_info: FunctionInfo) -> CodeBlock:
105:    def generate_enforce(self, func_info: FunctionInfo) -> CodeBlock:
116:    def generate_train(self, func_info: FunctionInfo) -> CodeBlock | None:
133:    def _generate_perceive(self, func_info: FunctionInfo) -> CodeBlock:
138:    def _generate_operate(self, func_info: FunctionInfo) -> CodeBlock:
143:    def _generate_enforce(self, func_info: FunctionInfo) -> CodeBlock:
147:    def _generate_train(self, func_info: FunctionInfo) -> CodeBlock | None:
151:    def _merge_code_blocks(self, parent: CodeBlock | None, child: CodeBlock | None, phase: str) -> CodeBlock:
184:    def _generate_orchestrator(
216:def enhanced_{func_info.name}{signature}:
295:    def _indent_code(self, code: str, spaces: int) -> str:
300:    def _extract_parameter_names(self, signature: str) -> list[str]:
329:    def _generate_perceive(self, func_info: FunctionInfo) -> CodeBlock:
341:    def _generate_operate(self, func_info: FunctionInfo) -> CodeBlock:
370:    def _generate_enforce(self, func_info: FunctionInfo) -> CodeBlock:
14:def poet(
37:        def diagnose(symptoms: list) -> dict:
49:        def assess_credit_risk(score: int) -> str:
86:    def dana_decorator(original_func: Any) -> Any:
92:        def poet_enhanced_function(*args, **kwargs):
249:def extract_poet_metadata(func: Any) -> dict[str, Any]:
31:    def dict(self) -> dict[str, Any]:
49:    def from_dict(cls, data: builtins.dict[str, Any]) -> "POETConfig":
63:    def from_response(cls, response_data: dict[str, Any]) -> "TranspiledFunction":
92:    def poet(self) -> dict[str, Any]:
197:    def unwrap(self) -> Any:
201:    def raw(self) -> Any:
21:def create_workflow_metadata(
42:        def ingest_document(file_path):
47:        def perform_ocr(document):
61:def create_pipeline_metadata(
104:def with_workflow_metadata(workflow_id: str | None = None, description: str | None = None, version: str = "1.0.0") -> Callable:
119:        def document_processing_workflow(input_data):
127:    def decorator(pipeline_func: Callable) -> Callable:
139:def auto_workflow_metadata(func: Callable) -> Callable:
156:        def ingest_document(file_path):
174:def build_workflow_metadata(*args, **kwargs) -> dict[str, Any]:
35:    def to_dict(self) -> dict[str, Any]:
66:    def extract_function_metadata(self, func: Callable) -> FunctionMetadata:
97:    def _extract_description_from_docstring(self, func: Callable) -> str:
123:    def _extract_poet_config(self, func: Callable) -> dict[str, Any]:
151:    def _extract_additional_params(self, poet_config: dict[str, Any]) -> dict[str, Any]:
185:def extract_workflow_metadata(
219:def extract_pipeline_metadata(pipeline_func: Callable) -> dict[str, Any]:
244:def _extract_functions_from_pipeline(pipeline_func: Callable) -> list[Callable]:
280:def with_metadata(func: Callable, **metadata) -> Callable:
295:def workflow_step(
312:    def decorator(func: Callable) -> Callable:
329:def _extract_first_line_docstring(func: Callable) -> str:
19:    def generate_dana_wrapper(self, function_name: str, config: POETConfig) -> str:
36:def poet_wrapper_{function_name}(*args, **kwargs):
85:    def enhance_function_definition(self, original_function_code: str, config: POETConfig) -> str:
29:    def enforce(self, output: Any, context: dict[str, Any], expected_type: type | None = None) -> Any:
55:    def _validate_output(self, output: Any, expected_type: type | None = None) -> None:
66:    def _enforce_domain_rules(self, output: Any, context: dict[str, Any]) -> None:
11:def financial_services(**kwargs) -> dict[str, Any]:
59:def healthcare(**kwargs) -> dict[str, Any]:
106:def retail_ecommerce(**kwargs) -> dict[str, Any]:
153:def data_processing(**kwargs) -> dict[str, Any]:
200:def security(**kwargs) -> dict[str, Any]:
248:def quick_setup(domain: str, **kwargs) -> dict[str, Any]:
274:def poet_for_domain(domain: str, **kwargs):
41:    def debug_perceive(self, *args, **kwargs) -> dict[str, Any]:
70:    def debug_operate(self, *args, **kwargs) -> dict[str, Any]:
106:    def debug_enforce(self, operation_result: Any) -> dict[str, Any]:
138:    def debug_train(self, operation_result: Any) -> dict[str, Any]:
165:    def debug_full_execution(self, *args, **kwargs) -> dict[str, Any]:
197:def debug_poet_function(func: Callable, config: POETConfig, *args, **kwargs) -> dict[str, Any]:
214:def test_poet_function(func: Callable, test_cases: list[dict[str, Any]], config: POETConfig | None = None) -> dict[str, Any]:
263:def performance_benchmark(func: Callable, iterations: int = 100, *args, **kwargs) -> dict[str, Any]:
30:    def operate(self, func: Callable, args: tuple[Any, ...], kwargs: dict[str, Any], context: dict[str, Any]) -> Any:
29:    def perceive(self, args: tuple[Any, ...], kwargs: dict[str, Any]) -> tuple[tuple[Any, ...], dict[str, Any], dict[str, Any]]:
60:    def _validate_inputs(self, args: tuple[Any, ...], kwargs: dict[str, Any]) -> None:
72:    def _process_domain_inputs(self, args: tuple[Any, ...], kwargs: dict[str, Any], context: dict[str, Any]) -> None:
29:    def train(
74:    def _track_performance(self, training_data: dict[str, Any], execution_time: float) -> None:
83:    def _domain_learning(
98:    def _basic_pattern_recognition(self, training_data: dict[str, Any], input_args: tuple[Any, ...], output: Any) -> None:
110:    def _financial_learning(self, training_data: dict[str, Any], input_args: tuple[Any, ...], output: Any) -> None:
118:    def _healthcare_learning(self, training_data: dict[str, Any], input_args: tuple[Any, ...], output: Any) -> None:
126:    def _data_processing_learning(self, training_data: dict[str, Any], input_args: tuple[Any, ...], output: Any) -> None:
22:    def register_ko_type(self, name: str, ko_class: type) -> None:
35:    def register_ko_config(self, name: str, config: dict[str, Any]) -> None:
45:    def get_ko_type(self, name: str) -> type:
63:    def get_ko_config(self, name: str) -> dict[str, Any]:
81:    def list_ko_types(self) -> list[str]:
89:    def list_ko_configs(self) -> list[str]:
97:    def create_ko_instance(self, name: str, **kwargs) -> Any:
98:    def load_document(self, source: str) -> Document:
103:    def validate_document(self, document: Document) -> bool:
112:    def process(self, input_data: Any) -> Any:
117:    def validate_input(self, input_data: Any) -> bool:
126:    def extract_knowledge(self, document: Document) -> list[KnowledgePoint]:
131:    def validate_knowledge(self, knowledge: KnowledgePoint) -> ValidationResult:
13:def _get_context_manager() -> ContextManager:
25:def _parse_context_type(context_type_str: str) -> ContextType:
58:def context_set(context_type: str, key: str, value: Any) -> bool:
78:def context_get(context_type: str, key: str, default: Any = None) -> Any:
97:def context_has(context_type: str, key: str) -> bool:
115:def context_remove(context_type: str, key: str) -> bool:
133:def context_clear(context_type: str) -> bool:
151:def context_clear_all() -> bool:
165:def context_sync(source_type: str, target_type: str, keys: list[str] | None = None) -> bool:
186:def context_keys(context_type: str) -> list[str]:
204:def context_size(context_type: str) -> int:
222:def context_info(context_type: str) -> dict[str, Any]:
239:def context_snapshot(context_type: str) -> dict[str, Any]:
256:def context_restore(context_type: str, snapshot: dict[str, Any]) -> bool:
275:def context_types() -> list[str]:
289:def context_metrics() -> dict[str, Any]:
305:def context_merge(source_type: str, target_type: str) -> bool:
318:def context_copy(source_type: str, target_type: str, keys: list[str]) -> bool:
332:def context_exists(context_type: str) -> bool:
350:def context_is_empty(context_type: str) -> bool:
365:def to_context_dict(context_type: str) -> dict[str, Any]:
383:def from_context_dict(context_type: str, data: dict[str, Any]) -> bool:
407:def context_validate_key(key: str) -> bool:
424:def context_validate_value(value: Any) -> bool:
444:def context_configure(settings_dict: dict[str, Any]) -> bool:
462:def context_reset() -> bool:
33:    def get_context(self, context_type: ContextType) -> Context:
51:    def set_context_value(self, context_type: ContextType, key: str, value: Any) -> None:
71:    def get_context_value(self, context_type: ContextType, key: str, default: Any = None) -> Any:
85:    def has_context_value(self, context_type: ContextType, key: str) -> bool:
98:    def remove_context_value(self, context_type: ContextType, key: str) -> bool:
116:    def clear_context(self, context_type: ContextType) -> None:
127:    def clear_all_contexts(self) -> None:
134:    def sync_contexts(self, source_type: ContextType, target_type: ContextType, keys: list[str] | None = None) -> None:
167:    def get_context_snapshot(self, context_type: ContextType) -> dict[str, Any]:
179:    def restore_context_snapshot(self, context_type: ContextType, snapshot: dict[str, Any]) -> None:
201:    def get_all_context_types(self) -> list[ContextType]:
210:    def get_context_info(self, context_type: ContextType) -> dict[str, Any]:
228:    def get_metrics(self) -> dict[str, Any]:
242:    def _validate_key(self, key: str) -> None:
257:    def _validate_value(self, value: Any) -> None:
277:    def _invalidate_cache(self, context_type: ContextType) -> None:
287:    def _cleanup_expired_cache(self) -> None:
48:    def set(self, key: str, value: Any) -> None:
64:    def get(self, key: str, default: Any = None) -> Any:
76:    def has(self, key: str) -> bool:
87:    def remove(self, key: str) -> bool:
102:    def clear(self) -> None:
107:    def keys(self) -> list[str]:
115:    def values(self) -> list[Any]:
123:    def items(self) -> list[tuple[str, Any]]:
131:    def size(self) -> int:
139:    def copy(self) -> "Context":
151:    def merge(self, other: "Context") -> None:
166:    def to_dict(self) -> dict[str, Any]:
180:    def from_dict(cls, data: dict[str, Any]) -> "Context":
25:def create_store(store_type: str, settings: dict[str, Any]) -> None:
56:def store_value(key: str, value: Any, store_type: str) -> None:
77:def retrieve_value(key: str, store_type: str) -> Any | None:
100:def delete_value(key: str, store_type: str) -> None:
120:def query_values(store_type: str, **kwargs) -> list[Any]:
143:def close_stores() -> None:
154:def get_store_types() -> dict[str, str]:
168:def get_active_stores() -> list[str]:
178:def convert_dana_to_python(value: Any) -> Any:
196:def convert_python_to_dana(value: Any) -> Any:
28:    def _create_connection(self) -> psycopg2.extensions.connection:
49:    def _ensure_extension(self) -> None:
62:    def _ensure_table(self) -> None:
82:    def _parse_vector(self, vector_data) -> list[float]:
100:    def _validate_key(self, key: str) -> None:
122:    def store(self, key: str, value: Any) -> None:
164:    def retrieve(self, key: str) -> dict[str, Any] | None:
195:    def delete(self, key: str) -> None:
220:    def query(self, **kwargs) -> list[Any]:
271:    def close(self) -> None:
27:    def _create_connection(self) -> psycopg2.extensions.connection:
48:    def _ensure_extension(self) -> None:
61:    def _ensure_table(self) -> None:
91:    def _validate_key(self, key: str) -> None:
113:    def store(self, key: str, value: Any) -> None:
160:    def retrieve(self, key: str, start_time: str | datetime | None = None, end_time: str | datetime | None = None) -> list[dict[str, Any]]:
209:    def delete(self, key: str) -> None:
234:    def query(self, **kwargs) -> list[Any]:
302:    def close(self) -> None:
25:    def _create_connection(self) -> psycopg2.extensions.connection:
46:    def _ensure_default_tables(self) -> None:
69:    def _ensure_table(self, table_name: str) -> None:
92:    def _validate_key(self, key: str) -> None:
115:    def store(self, key: str, value: Any) -> None:
154:    def retrieve(self, key: str) -> dict[str, Any] | None:
189:    def delete(self, key: str) -> None:
219:    def query(
267:    def close(self) -> None:
28:    def _create_client(self) -> redis.Redis:
52:    def _validate_key(self, key: str) -> None:
74:    def store(self, key: str, value: Any) -> None:
103:    def retrieve(self, key: str) -> Any | None:
131:    def delete(self, key: str) -> None:
156:    def query(self, pattern: str) -> list[Any]:
188:    def close(self) -> None:
12:    def store(self, key: str, value: Any) -> None:
16:    def retrieve(self, key: str) -> Any | None:
20:    def delete(self, key: str) -> None:
24:    def query(self, **kwargs) -> list[Any]:
30:    def process(self, parsed_doc: ParsedDocument) -> str:
69:    def validate_input(self, parsed_doc: ParsedDocument) -> bool:
92:    def _extract_from_text_document(self, parsed_doc: ParsedDocument) -> str:
149:    def _extract_from_json_document(self, parsed_doc: ParsedDocument) -> str:
182:    def _extract_from_csv_document(self, parsed_doc: ParsedDocument) -> str:
229:    def _extract_generic_text(self, parsed_doc: ParsedDocument) -> str:
253:    def _json_to_text(self, data: Any, indent: int = 0) -> list[str]:
285:    def _clean_text(self, text: str) -> str:
305:    def _format_metadata(self, metadata: dict[str, Any]) -> str:
22:    def process(self, document: Document) -> ParsedDocument:
63:    def validate_input(self, document: Document) -> bool:
86:    def _parse_text_document(self, document: Document) -> dict[str, Any]:
134:    def _parse_json_document(self, document: Document) -> dict[str, Any]:
164:    def _parse_csv_document(self, document: Document) -> dict[str, Any]:
197:    def _parse_generic_document(self, document: Document) -> dict[str, Any]:
221:    def _analyze_json_schema(self, data: Any, path: str = "") -> dict[str, Any]:
31:    def load_document(self, source: str) -> Document:
81:    def load_documents(self, sources: list[str]) -> list[Document]:
108:    def validate_document(self, document: Document) -> bool:
143:    def _load_content(self, source: str, format_ext: str) -> str:
164:    def _load_text_file(self, source: str) -> str:
169:    def _load_json_file(self, source: str) -> str:
175:    def _load_csv_file(self, source: str) -> str:
180:    def _load_pdf_file(self, source: str) -> str:
239:    def _generate_document_id(self, source: str) -> str:
68:    def process(self, knowledge_points: list[KnowledgePoint]) -> dict[str, Any]:
118:    def validate_input(self, knowledge_points: list[KnowledgePoint]) -> bool:
142:    def search_similar(self, query_point: KnowledgePoint, candidate_points: list[KnowledgePoint] | None = None) -> SimilarityResult:
195:    def _build_knowledge_index(self, knowledge_points: list[KnowledgePoint]) -> None:
204:    def _generate_content_vectors(self, knowledge_points: list[KnowledgePoint]) -> None:
216:    def _generate_content_vector(self, content: str) -> np.ndarray:
272:    def _calculate_vector_similarity(self, vector1: np.ndarray, vector2: np.ndarray) -> float:
300:    def _identify_matching_features(self, kp1: KnowledgePoint, kp2: KnowledgePoint) -> list[str]:
340:    def _find_similarities(self, knowledge_points: list[KnowledgePoint]) -> list[dict[str, Any]]:
378:    def _create_semantic_matches(self, similarity_mappings: list[dict[str, Any]]) -> list[SemanticMatch]:
406:    def _determine_match_type(self, matching_features: list[str]) -> str:
429:    def _generate_similarity_clusters(self, semantic_matches: list[SemanticMatch]) -> list[dict[str, Any]]:
465:    def _find_connected_points(self, start_id: str, semantic_matches: list[SemanticMatch]) -> set:
491:    def _calculate_cluster_similarity(self, cluster_ids: list[str], semantic_matches: list[SemanticMatch]) -> float:
508:    def _get_dominant_match_type(self, cluster_ids: list[str], semantic_matches: list[SemanticMatch]) -> str:
531:    def _calculate_search_confidence(self, similarities: list[dict[str, Any]]) -> float:
552:    def _get_vector_dimensions(self) -> int:
150:    def process(self, knowledge_points: list[KnowledgePoint]) -> dict[str, Any]:
204:    def validate_input(self, knowledge_points: list[KnowledgePoint]) -> bool:
228:    def expand_context(self, knowledge_point: KnowledgePoint) -> list[ContextExpansion]:
271:    def validate_context(self, knowledge_point: KnowledgePoint) -> ContextValidation:
310:    def _parse_expansion_response(self, response: BaseResponse, source_id: str) -> list[ContextExpansion]:
363:    def _parse_validation_response(self, response: BaseResponse, context_id: str) -> ContextValidation:
434:    def _rule_based_expansion(self, knowledge_point: KnowledgePoint) -> list[ContextExpansion]:
501:    def _rule_based_validation(self, knowledge_point: KnowledgePoint) -> ContextValidation:
562:    def _assess_response_quality(self, expansion_data: dict[str, Any]) -> float:
593:    def _create_context_relationships(
641:    def _generate_context_summary(self, expansions: list[ContextExpansion], validations: list[ContextValidation]) -> dict[str, Any]:
675:    def _calculate_average_confidence(self, expansions: list[ContextExpansion]) -> float:
689:    def _calculate_average_validation_score(self, validations: list[ContextValidation]) -> float:
703:    def _calculate_validation_pass_rate(self, validations: list[ContextValidation]) -> float:
718:    def _get_common_issues(self, validations: list[ContextValidation]) -> list[str]:
41:    def process(self, document: Document) -> list[KnowledgePoint]:
77:    def validate_input(self, document: Document) -> bool:
99:    def _extract_with_llm(self, document: Document) -> list[KnowledgePoint]:
146:    def _build_extraction_prompt(self, document: Document) -> str:
191:    def _extract_response_text(self, response_content: Any) -> str:
258:    def _parse_llm_response(self, response: str, document: Document) -> list[KnowledgePoint]:
310:    def _create_knowledge_point(self, data: dict[str, Any], document: Document) -> KnowledgePoint | None:
357:    def _fallback_extraction(self, document: Document) -> list[KnowledgePoint]:
400:    def _is_potentially_important(self, sentence: str) -> bool:
442:    def _generate_knowledge_point_id(self) -> str:
450:    def _get_timestamp(self) -> str:
108:    def process(self, knowledge_points: list[KnowledgePoint]) -> dict[str, Any]:
166:    def validate_input(self, knowledge_points: list[KnowledgePoint]) -> bool:
190:    def _categorize_knowledge_point(self, knowledge_point: KnowledgePoint) -> list[dict[str, Any]]:
245:    def _calculate_keyword_similarity(self, text: str, keywords: list[str]) -> float:
272:    def _determine_relationship_type(self, similarity_score: float) -> str:
288:    def _map_knowledge_point_relationships(self, knowledge_points: list[KnowledgePoint]) -> list[dict[str, Any]]:
329:    def _calculate_content_similarity(self, content1: str, content2: str) -> float:
351:    def _have_contextual_relationship(self, kp1: KnowledgePoint, kp2: KnowledgePoint) -> bool:
378:    def _find_shared_context(self, kp1: KnowledgePoint, kp2: KnowledgePoint) -> dict[str, Any]:
398:    def _build_category_hierarchy(self) -> dict[str, Any]:
422:    def _generate_categorization_summary(
15:    def extract_text(self, content: str) -> str:
19:    def extract_metadata(self, content: str) -> dict[str, Any]:
15:    def parse(self, content: str) -> dict[str, Any]:
19:    def parse_batch(self, contents: list[str]) -> list[dict[str, Any]]:
15:    def load(self, source: str) -> str:
20:    def load_batch(self, sources: list[str]) -> list[str]:
91:    def execute(self, input_data: Any, context: Any = None) -> Any:
131:    def _create_step_context(self, input_data: Any, context: Any = None) -> StepExecutionContext:
156:    def _validate_pre_conditions(self, input_data: Any, context: StepExecutionContext) -> None:
166:    def _validate_post_conditions(self, result: Any, context: StepExecutionContext) -> None:
176:    def _execute_function(self, input_data: Any, context: StepExecutionContext) -> Any:
180:        def _timeout_handler(signum, frame):
217:        def composed_function(input_data: Any) -> Any:
232:    def clone(self, **overrides) -> "WorkflowStep":
255:    def from_function(
279:        def decorator(func: Callable) -> "WorkflowStep":
39:    def add_context(self, key: str, value: Any) -> None:
43:    def get_context(self, key: str, default: Any = None) -> Any:
72:    def execute(
132:    def _validate_workflow(self, workflow: Any) -> None:
140:    def _execute_step_list(self, steps: list[WorkflowStep], input_data: Any, context: WorkflowExecutionContext) -> Any:
177:    def _execute_composed_function(self, composed_func: Callable, input_data: Any, context: WorkflowExecutionContext) -> Any:
189:    def _post_execution_processing(self, context: WorkflowExecutionContext, result: Any) -> None:
201:    def _handle_execution_error(self, context: WorkflowExecutionContext, error: Exception) -> None:
220:    def create_workflow_step(
65:    def validate_workflow(self, workflow: Any, context: Any = None) -> SafetyResult:
103:    def validate_step(self, step: Any, context: Any = None) -> SafetyResult:
169:    def add_validation_rule(self, name: str, rule: Callable) -> None:
180:    def remove_validation_rule(self, name: str) -> bool:
196:    def _register_default_rules(self) -> None:
203:    def _validate_step_list(self, steps: list, context: Any = None) -> SafetyResult:
249:    def _validate_composed_function(self, func: Callable, context: Any = None) -> SafetyResult:
285:    def _validate_function(self, func: Callable, name: str) -> SafetyResult:
316:    def _check_dangerous_operations(self, func: Callable, name: str) -> SafetyResult:
355:    def _is_workflow_list(self, workflow: Any) -> bool:
359:    def _rule_basic_structure(self, workflow: Any, context: Any = None) -> SafetyResult:
368:    def _rule_no_infinite_recursion(self, workflow: Any, context: Any = None) -> SafetyResult:
382:    def _rule_reasonable_complexity(self, workflow: Any, context: Any = None) -> SafetyResult:
400:    def get_validation_summary(self) -> dict[str, Any]:
72:    def add_knowledge(self, content: str, source: str, tags: list[str] | None = None, metadata: dict[str, Any] | None = None) -> str:
106:    def get_knowledge(self, knowledge_id: str) -> KnowledgePoint | None:
118:    def find_by_tag(self, tag: str) -> list[KnowledgePoint]:
131:    def search_knowledge(
166:    def create_context_snapshot(self, metadata: dict[str, Any] | None = None) -> str:
186:    def get_context_snapshot(self, snapshot_id: str) -> ContextSnapshot | None:
198:    def clear_knowledge(self, source: str | None = None) -> int:
231:    def get_stats(self) -> dict[str, Any]:
250:    def _enforce_limit(self) -> None:
264:    def export_knowledge(self, source: str | None = None) -> dict[str, Any]:
291:    def import_knowledge(self, data: dict[str, Any]) -> int:
40:    def search(self, query: str, candidates: list[str]) -> SimilarityResult:
50:    def validate_input(self, knowledge_points: list[Any]) -> bool:
36:    def expand(self, context: dict[str, Any], knowledge_base: list[Any]) -> ContextExpansion:
41:    def validate(self, context: dict[str, Any]) -> ContextValidation:
15:    def extract(self, content: str) -> dict[str, Any]:
20:    def extract_batch(self, contents: list[str]) -> list[dict[str, Any]]:
34:    def categorize(self, content: str) -> list[KnowledgeCategory]:
39:    def find_relationships(self, categories: list[KnowledgeCategory]) -> list[CategoryRelationship]:
15:    def search(self, query: str, candidates: list[str]) -> list[str]:
20:    def rank(self, query: str, candidates: list[str]) -> list[tuple[str, float]]:
34:    def expand(self, context: str, knowledge_base: list[str]) -> list[str]:
44:    def to_dict(self) -> dict[str, any]:
62:def create_dana_exception(exc: Exception, error_context=None) -> DanaException:
42:    def find_spec(self, fullname: str, path: Sequence[str | bytes] | None = None, target: Module | None = None) -> PyModuleSpec | None:
67:    def _find_spec_with_context(self, fullname: str, importing_module_path: str | None = None) -> PyModuleSpec | None:
300:    def _setup_package_attributes(self, spec: ModuleSpec) -> None:
333:    def create_module(self, spec: PyModuleSpec) -> Module | None:
375:    def exec_module(self, module: Module) -> None:
473:    def _setup_module_function_context(self, module: Module, interpreter: DanaInterpreter, context: SandboxContext) -> None:
516:    def _find_module_in_directory(self, module_name: str, directory: Path) -> Path | None:
538:    def _find_module_file(self, module_name: str) -> Path | None:
75:def show_help():
96:def execute_file(file_path, debug=False):
145:async def start_repl(debug=False):
166:def handle_start_command(args):
212:def main():
318:def handle_main_command():
364:def handle_deploy_command(args):
391:def handle_config_command(args):
420:def deploy_thru_mcp(file_path, args):
437:def deploy_thru_a2a(file_path, args):
450:def configure_debug_logging():
457:def validate_na_file(file_path):
114:    def run_configuration_wizard(self) -> bool:
160:    def _select_providers(self) -> list[str]:
210:    def _configure_provider(self, provider_key: str) -> dict[str, str] | None:
262:    def _write_env_file(self, env_vars: dict[str, str]):
299:    def validate_configuration(self) -> bool:
355:    def _load_env_file(self):
11:def validate_agent_module(na_file_path: str, na_module):
59:def make_agent_class(agent_name: str, agent_description: str, entry_func: Callable):
77:        def solve_query(self, query: str) -> str:
85:        def handle_task(self, task):
103:def color_text(text, color_code):
107:def print_a2a_server_banner(host, port, agent_name, agent_description):
129:def deploy_dana_agents_thru_a2a(na_file_path, host, port):
8:def validate_agent_module(na_file_path: str, na_module):
48:def create_mcp_server_for_file(na_file_path):
68:        def solve(query: str) -> str:
84:def color_text(text, color_code):
88:def print_mcp_server_banner(host, port, agent_name):
110:def deploy_dana_agents_thru_mcp(na_file_path, host, port):
142:    async def lifespan(app: FastAPI):
52:    def detect_assignment_context(self, assignment_node: Assignment) -> TypeContext | None:
84:    def detect_function_call_context(self, func_call_node: FunctionCall) -> TypeContext | None:
143:    def detect_function_parameter_context(self, param_name: str, param_type: str) -> TypeContext:
163:    def detect_conditional_context(self, condition_node: Any) -> TypeContext:
182:    def infer_context_from_usage(self, variable_name: str, usage_context: str) -> TypeContext | None:
215:    def get_cached_context(self, cache_key: str) -> TypeContext | None:
226:    def cache_context(self, cache_key: str, context: TypeContext) -> None:
236:    def clear_cache(self) -> None:
241:    def get_cache_size(self) -> int:
245:    def detect_current_context(self, context: Any) -> TypeContext | None:
293:    def _infer_from_execution_context(self, context: Any) -> TypeContext | None:
346:    def analyze_assignment_chain(self, assignments: list[Assignment]) -> list[TypeContext]:
365:    def find_strongest_context(self, contexts: list[TypeContext]) -> TypeContext | None:
381:    def merge_contexts(self, contexts: list[TypeContext]) -> TypeContext | None:
431:def detect_assignment_context(assignment_node: Assignment) -> TypeContext | None:
437:def detect_conditional_context(condition_node: Any) -> TypeContext:
443:def analyze_contexts(assignments: list[Assignment]) -> list[TypeContext]:
55:    def push_location(self, location: ExecutionLocation) -> None:
60:    def pop_location(self) -> ExecutionLocation | None:
68:    def set_file(self, filename: str | Path) -> None:
73:    def load_source(self, filename: str) -> list[str] | None:
87:    def get_source_line(self, filename: str, line_num: int) -> str | None:
94:    def format_stack_trace(self) -> str:
48:def _patched_format_user_error(e, user_input=None):
87:    def _init_function_registry(self):
108:    def function_registry(self) -> FunctionRegistry:
122:    def _run(self, file_path: str | Path, source_code: str, context: SandboxContext) -> Any:
136:    def _eval(self, source_code: str, context: SandboxContext, filename: str | None = None) -> Any:
155:    def _execute(self, ast: Program, context: SandboxContext) -> Any:
192:    def evaluate_expression(self, expression: Any, context: SandboxContext) -> Any:
204:    def execute_program(self, program: Program, context: SandboxContext) -> Any:
217:    def execute_statement(self, statement: Any, context: SandboxContext) -> Any:
230:    def get_and_clear_output(self) -> str:
234:    def get_evaluated(self, key: str, context: SandboxContext) -> Any:
250:    def call_function(
278:    def evaluate_ast(self, ast: Program, context: SandboxContext) -> Any:
294:    def _process_function_definition(self, func_def: FunctionDefinition, context: SandboxContext) -> None:
325:    def _create_dana_function(self, func_def: FunctionDefinition, context: SandboxContext, register: bool = True):
339:        def dana_function(*args, **kwargs):
362:    def _bind_function_parameters(self, parameters: list, args: tuple, kwargs: dict, context: SandboxContext) -> None:
376:    def _register_function_normally(self, func_def: FunctionDefinition, context: SandboxContext) -> None:
381:    def is_repl_mode(self) -> bool:
18:    def format_error(error: Exception, error_context: ErrorContext | None = None, show_traceback: bool = True) -> str:
86:    def format_developer_error(error: Exception, error_context: ErrorContext | None = None, show_traceback: bool = True) -> str:
164:    def format_simple_error(error: Exception, filename: str | None = None) -> str:
36:    def _build_boolean_patterns(self) -> dict[str, bool]:
87:    def _build_numeric_patterns(self) -> dict[str, re.Pattern]:
97:    def coerce_to_bool(self, value: Any, context: str | None = None) -> bool:
126:    def _coerce_string_to_bool(self, text: str) -> bool:
160:    def _is_zero_equivalent(self, text: str) -> bool:
165:    def _is_positive_numeric(self, text: str) -> bool:
173:    def _apply_contextual_boolean_logic(self, text: str) -> bool | None:
192:    def coerce_value(self, value: Any, target_type: str, context: str | None = None) -> Any:
237:    def _coerce_to_dict(self, value: Any, context: str | None = None) -> dict:
278:    def _coerce_to_list(self, value: Any, context: str | None = None) -> list:
319:    def _extract_final_answer(self, text: str) -> str:
338:    def _try_coerce_to_struct(self, value: Any, target_type: str, context: str | None = None) -> Any | None:
396:    def _coerce_string_to_struct(self, text: str, target_type: str, context: str | None = None) -> Any:
440:    def _coerce_dict_to_struct(self, data: dict, target_type: str, context: str | None = None) -> Any:
466:    def _clean_json_string(self, value: str) -> str:
487:    def test_semantic_equivalence(self, left: Any, right: Any) -> bool:
513:def coerce_value(value: Any, target_type: str, context: str | None = None) -> Any:
518:def semantic_bool(value: Any) -> bool:
523:def semantic_equals(left: Any, right: Any) -> bool:
49:    def prepare_context(self, context: SandboxContext | Any, args: list[Any], kwargs: dict[str, Any]) -> SandboxContext:
108:    def restore_context(self, context: SandboxContext, original_context: SandboxContext) -> None:
121:    def execute(self, context: Any, *args: Any, **kwargs: Any) -> Any:
56:    def prepare_context(self, context: SandboxContext, args: list[Any], kwargs: dict[str, Any]) -> SandboxContext:
73:    def restore_context(self, context: SandboxContext, original_context: SandboxContext) -> None:
86:    def execute(self, context: SandboxContext, *args: Any, **kwargs: Any) -> Any:
108:    def _resolve_function(self, func: SandboxFunction | str | Callable, context: SandboxContext) -> SandboxFunction:
167:    def _wrap_callable(self, func: callable, func_name: str, context: SandboxContext) -> SandboxFunction:
185:            def execute(self, context: SandboxContext, *args, **kwargs):
208:            def restore_context(self, context: SandboxContext, original_context: SandboxContext) -> None:
81:    def register_handlers(self):
102:    def execute_assignment(self, node: Assignment, context: SandboxContext) -> Any:
114:    def execute_compound_assignment(self, node: CompoundAssignment, context: SandboxContext) -> Any:
126:    def execute_assert_statement(self, node: AssertStatement, context: SandboxContext) -> None:
141:    def _execute_python_import(self, module_name: str, context_name: str, context: SandboxContext) -> None:
168:    def _execute_dana_import(self, module_name: str, context_name: str, context: SandboxContext) -> None:
210:    def _execute_python_from_import(self, module_name: str, names: list[tuple[str, str | None]], context: SandboxContext) -> None:
253:    def _execute_dana_from_import(self, module_name: str, names: list[tuple[str, str | None]], context: SandboxContext) -> None:
315:    def _register_imported_function(self, func: callable, context_name: str, module_name: str, original_name: str) -> None:
385:    def execute_import_statement(self, node: ImportStatement, context: SandboxContext) -> Any:
397:    def execute_import_from_statement(self, node: ImportFromStatement, context: SandboxContext) -> Any:
409:    def execute_pass_statement(self, node: PassStatement, context: SandboxContext) -> None:
421:    def execute_raise_statement(self, node: RaiseStatement, context: SandboxContext) -> None:
436:    def execute_use_statement(self, node: UseStatement, context: SandboxContext) -> Any:
448:    def execute_export_statement(self, node: ExportStatement, context: SandboxContext) -> None:
460:    def execute_struct_definition(self, node: StructDefinition, context: SandboxContext) -> None:
472:    def execute_agent_definition(self, node: AgentDefinition, context: SandboxContext) -> None:
484:    def execute_agent_statement(self, node: AgentStatement, context: SandboxContext) -> Any:
496:    def execute_agent_pool_statement(self, node: AgentPoolStatement, context: SandboxContext) -> Any:
508:    def execute_function_definition(self, node: "FunctionDefinition", context: SandboxContext) -> Any:
523:    def execute_method_definition(self, node: "MethodDefinition", context: SandboxContext) -> Any:
541:            func_def = FunctionDefinition(
551:    def execute_declarative_function_definition(self, node: "DeclarativeFunctionDefinition", context: SandboxContext) -> Any:
570:        def create_declarative_function():
571:            def wrapper(*args, **kwargs):
615:    def _bind_declarative_function_parameters(self, parameters: list, args: tuple, kwargs: dict, func_context: SandboxContext) -> None:
674:    def _execute_composition(self, composition, func_context: SandboxContext, args: tuple) -> Any:
698:    def _extract_annotations(self, parameters: list, return_type) -> dict[str, type]:
720:    def _map_dana_type_to_python(self, dana_type: str) -> type:
745:    def _create_signature(self, parameters: list, return_type):
68:    def register_handlers(self):
76:    def execute_function_definition(self, node: FunctionDefinition, context: SandboxContext) -> Any:
142:    def execute_method_definition(self, node: MethodDefinition, context: SandboxContext) -> Any:
221:    def _apply_decorators(self, func, decorators, context):
249:    def _evaluate_expression(self, expr, context):
260:    def _resolve_decorator(self, decorator, context):
292:    def _ensure_fully_evaluated(self, value: Any, context: SandboxContext) -> Any:
314:    def execute_function_call(self, node: FunctionCall, context: SandboxContext) -> Any:
522:    def _get_current_function_context(self, context: SandboxContext) -> str | None:
560:    def _assign_and_coerce_result(self, raw_result: Any, function_name: str) -> Any:
578:    def _apply_function_result_coercion(self, result: Any, function_name: str) -> Any:
609:    def _execute_user_defined_function(self, func_data: dict[str, Any], args: list[Any], context: SandboxContext) -> Any:
42:    def execute_agent_statement(self, node: AgentStatement, context: SandboxContext) -> Any:
87:    def execute_agent_pool_statement(self, node: AgentPoolStatement, context: SandboxContext) -> Any:
132:    def execute_use_statement(self, node: UseStatement, context: SandboxContext) -> Any:
169:    def execute_export_statement(self, node: ExportStatement, context: SandboxContext) -> None:
200:    def execute_struct_definition(self, node: StructDefinition, context: SandboxContext) -> None:
235:            def struct_constructor(**kwargs):
248:    def execute_agent_definition(self, node: AgentDefinition, context: SandboxContext) -> None:
273:            def agent_constructor(**kwargs):
288:    def execute_function_definition(self, node: FunctionDefinition, context: SandboxContext) -> Any:
352:    def _apply_decorators(self, func, decorators, context):
380:    def _resolve_decorator(self, decorator, context):
390:    def _trace_resource_operation(self, operation_type: str, resource_name: str, arg_count: int, kwarg_count: int) -> None:
406:    def get_stats(self) -> dict[str, Any]:
56:    def execute_import_statement(self, node: ImportStatement, context: SandboxContext) -> Any:
93:    def execute_import_from_statement(self, node: ImportFromStatement, context: SandboxContext) -> Any:
123:    def _execute_python_import(self, module_name: str, context_name: str, context: SandboxContext) -> None:
157:    def _execute_dana_import(self, module_name: str, context_name: str, context: SandboxContext) -> None:
229:    def _execute_python_from_import(self, module_name: str, names: list[tuple[str, str | None]], context: SandboxContext) -> None:
276:    def _execute_dana_from_import(self, module_name: str, names: list[tuple[str, str | None]], context: SandboxContext) -> None:
364:    def _register_imported_function(self, func: callable, context_name: str, module_name: str, original_name: str) -> None:
402:    def _ensure_module_system_initialized(self) -> None:
418:    def _create_parent_namespaces(self, context_name: str, module: Any, context: SandboxContext) -> None:
480:    def _resolve_relative_import(self, module_name: str, context: SandboxContext) -> str:
557:    def _trace_import(self, import_type: str, module_name: str, context_info: str) -> None:
572:    def clear_cache(self) -> None:
581:    def get_cache_stats(self) -> dict[str, Any]:
49:    def execute_assignment(self, node: Assignment, context: SandboxContext) -> Any:
89:    def execute_compound_assignment(self, node: CompoundAssignment, context: SandboxContext) -> Any:
167:    def _process_type_hint(self, node: Assignment, context: SandboxContext) -> type | None:
212:    def _apply_type_coercion(self, value: Any, target_type: type | str, target_node: Any) -> Any:
263:    def _execute_assignment_by_target(self, target: Any, value: Any, context: SandboxContext) -> None:
287:    def _execute_subscript_assignment(self, target: SubscriptExpression, value: Any, context: SandboxContext) -> None:
320:    def _execute_slice_assignment(self, target_obj: Any, slice_expr: Any, value: Any, context: SandboxContext) -> None:
342:    def _execute_multidim_slice_assignment(self, target_obj: Any, slice_tuple: Any, value: Any, context: SandboxContext) -> None:
376:    def _execute_attribute_assignment(self, target: AttributeAccess, value: Any, context: SandboxContext) -> None:
397:    def _get_assignment_target_name(self, target: Any) -> str:
417:    def _trace_assignment(self, target: Any, value: Any) -> None:
433:    def clear_cache(self) -> None:
438:    def get_cache_stats(self) -> dict[str, Any]:
73:    def parse_function_name(self, func_name: str) -> FunctionNameInfo:
103:    def resolve_function(self, name_info: FunctionNameInfo, context: SandboxContext, registry: Any) -> ResolvedFunction | None:
133:    def _resolve_from_context_hierarchy(self, name_info: FunctionNameInfo, context: SandboxContext) -> ResolvedFunction | None:
175:    def _create_resolved_function_from_context(self, func_data: Any, name_info: FunctionNameInfo) -> ResolvedFunction:
218:    def _resolve_from_context(self, name_info: FunctionNameInfo, context: SandboxContext) -> ResolvedFunction | None:
252:    def _resolve_from_registry(self, name_info: FunctionNameInfo, registry: Any) -> ResolvedFunction | None:
289:    def execute_resolved_function(
321:    def list_available_functions(self, namespace: str | None = None) -> list[str]:
85:    def _register_all_handlers(self):
99:    def execute(self, node: Any, context: SandboxContext) -> Any:
146:    def _execute_hook(
168:    def get_and_clear_output(self) -> str:
178:    def extract_value(self, node: Any) -> Any:
197:    def configure_optimizations(self, **kwargs) -> None:
206:    def get_optimization_statistics(self) -> dict[str, Any] | None:
216:    def log_optimization_report(self) -> None:
223:    def clear_optimization_caches(self) -> None:
228:    def is_optimization_healthy(self) -> bool:
238:    def execute_with_location_context(self, method: Callable, node: Any, context: SandboxContext) -> Any:
22:    def track_execution(self, node_description: str):
38:    def check_depth_safety(self) -> None:
51:    def get_statistics(self) -> dict[str, Any]:
62:    def reset_statistics(self) -> None:
75:    def visit_node(self, node: Any):
95:    def get_current_path(self) -> list[str]:
99:    def clear(self) -> None:
99:    def register_handlers(self):
118:    def execute_literal_expression(self, node: LiteralExpression, context: SandboxContext) -> Any:
134:    def execute_identifier(self, node: Identifier, context: SandboxContext) -> Any:
147:    def execute_binary_expression(self, node: BinaryExpression, context: SandboxContext) -> Any:
167:    def execute_unary_expression(self, node: UnaryExpression, context: SandboxContext) -> Any:
188:    def execute_tuple_literal(self, node: TupleLiteral, context: SandboxContext) -> tuple:
200:    def execute_dict_literal(self, node: DictLiteral, context: SandboxContext) -> dict:
212:    def execute_set_literal(self, node: SetLiteral, context: SandboxContext) -> set:
224:    def execute_fstring_expression(self, node: FStringExpression, context: SandboxContext) -> str:
236:    def execute_attribute_access(self, node: AttributeAccess, context: SandboxContext) -> Any:
305:    def run_function(self, func: Callable, *args, **kwargs) -> Any:
311:    def execute_object_function_call(self, node: Any, context: SandboxContext) -> Any:
425:    def execute_subscript_expression(self, node: SubscriptExpression, context: SandboxContext) -> Any:
472:    def _execute_slice(self, target: Any, slice_expr: Any, context: SandboxContext) -> Any:
504:    def _evaluate_slice_components(self, slice_expr: Any, context: SandboxContext) -> dict[str, Any]:
545:    def _validate_slice_operation(self, target: Any, components: dict[str, Any]) -> None:
573:    def _validate_sequence_slice_bounds(self, components: dict[str, Any], length: int) -> None:
606:    def _execute_validated_slice(self, target: Any, components: dict[str, Any]) -> Any:
648:    def _execute_slice_tuple(self, target: Any, slice_tuple: Any, context: SandboxContext) -> Any:
699:    def _get_safe_length(self, obj: Any) -> str:
713:    def execute_list_literal(self, node: ListLiteral, context: SandboxContext) -> list:
725:    def execute_placeholder_expression(self, node: PlaceholderExpression, context: SandboxContext) -> Any:
740:    def _resolve_pipeline_function(self, identifier: Identifier, context: SandboxContext) -> Any:
771:    def execute_pipeline_expression(self, node: PipelineExpression, context: SandboxContext) -> Any:
783:            def identity_function(initial_value):
789:        def composed_function(initial_value):
803:    def _execute_pipeline_stage(self, current_value: Any, stage: Any, context: SandboxContext) -> Any:
856:                    def error_function(value):
907:    def _execute_function_call_stage(self, current_value: Any, func_call: FunctionCall, context: SandboxContext) -> Any:
964:    def _contains_placeholder(self, expr: Any) -> bool:
52:    def execute_try_block(self, node: TryBlock, context: SandboxContext) -> Any:
162:    def _execute_statement_list(self, statements: list[Any], context: SandboxContext) -> Any:
187:    def _add_exception_trace(self, block_type: str, exception_type: str, action: str) -> None:
208:    def clear_cache(self) -> None:
215:    def get_performance_stats(self) -> dict[str, Any]:
232:    def get_exception_traces(self) -> list[dict[str, Any]]:
240:    def _matches_exception(self, exception: Exception, except_block: ExceptBlock, context: SandboxContext) -> bool:
51:    def resolve_identifier(self, node: Identifier, context: SandboxContext) -> Any:
125:    def _try_direct_context_lookup(self, name: str, context: SandboxContext) -> Any | None:
136:    def _try_cross_scope_search(self, name: str, context: SandboxContext) -> Any | None:
151:    def _try_scoped_resolution(self, name: str, context: SandboxContext) -> Any | None:
163:    def _resolve_colon_notation(self, name: str, context: SandboxContext) -> Any | None:
190:    def _resolve_dot_notation(self, name: str, context: SandboxContext) -> Any | None:
218:    def _try_fallback_scope_search(self, var_name: str, specified_scope: str, context: SandboxContext) -> Any | None:
231:    def _resolve_scoped_attribute_access(self, var_name: str, scope_name: str, context: SandboxContext) -> Any | None:
255:    def _access_attribute_path(self, base_value: Any, attribute_path: str) -> Any:
262:    def _try_function_registry_resolution(self, name: str, context: SandboxContext) -> Any | None:
310:    def _create_registry_wrapper(self, name: str, resolved_func: Any, context: SandboxContext) -> Any:
313:        def registry_function(*args, **kwargs):
324:    def _try_dotted_attribute_access(self, name: str, context: SandboxContext) -> Any | None:
364:    def _try_struct_type_resolution(self, name: str) -> Any | None:
389:    def _cache_result(self, cache_key: tuple, result: Any) -> None:
399:    def clear_cache(self) -> None:
406:    def get_cache_stats(self) -> dict[str, int | float]:
41:    def execute(self, context: SandboxContext, *args, **kwargs) -> list[Any]:
61:    def restore_context(self, context: SandboxContext, original_context: SandboxContext) -> None:
66:    def _call_function(self, func: Any, context: SandboxContext, *args, **kwargs) -> Any:
107:    def execute_pipe(self, left: Any, right: Any, context: SandboxContext) -> Any:
128:    def _resolve_to_function(self, expr: Any, context: SandboxContext) -> Any:
167:    def _resolve_function_call(self, func_call: FunctionCall, context: SandboxContext) -> Any:
206:    def _resolve_list_literal(self, list_literal: ListLiteral, context: SandboxContext) -> Any:
218:    def _resolve_identifier(self, identifier: Identifier, context: SandboxContext) -> Any:
31:    def execute_binary_expression(self, node: BinaryExpression, context: SandboxContext) -> Any:
100:    def _apply_binary_coercion(self, left: Any, right: Any, operator: str) -> tuple:
118:    def _extract_value(self, raw_value: Any) -> Any:
124:    def clear_cache(self) -> None:
130:    def get_cache_stats(self) -> dict[str, Any]:
63:    def _initialize_resolvers(self) -> None:
78:    def resolve_function(self, name_info: FunctionNameInfo, context: SandboxContext) -> ResolvedFunction:
145:    def execute_function(
181:    def _execute_registry_function(
197:    def _execute_dana_function(
209:    def _execute_python_function(
221:    def _execute_callable_function(
233:    def _assign_and_coerce_result(self, raw_result: Any, func_name: str) -> Any:
242:    def get_resolution_history(self) -> list[ResolutionAttempt]:
250:    def get_stats(self) -> dict[str, Any]:
258:    def clear_history(self) -> None:
262:    def _raise_function_not_found_error(self, name_info: FunctionNameInfo, attempts: list[ResolutionAttempt]) -> None:
38:    def handle_function_call_error(self, error: Exception, node: FunctionCall, context: Any) -> Any:
64:    def _is_positional_argument_error(self, error: Exception) -> bool:
77:    def _handle_registry_error(self, error: FunctionRegistryError, node: FunctionCall) -> Any:
89:    def _convert_to_user_friendly_name(self, function_name: str) -> str:
108:    def format_error_message(self, error: Exception, function_name: str, context: str = "") -> str:
127:    def handle_registry_execution_error(
171:    def _create_enhanced_sandbox_error(self, error: Exception, node: FunctionCall, func_name: str) -> SandboxError:
204:    def attempt_recovery(self, error: Exception, node: FunctionCall, context: Any) -> Any:
233:    def _try_keyword_conversion(self, node: FunctionCall, context: Any) -> Any:
263:    def _try_reduced_args(self, node: FunctionCall, context: Any) -> Any:
292:    def get_recovery_suggestions(self, error: Exception, function_name: str) -> list[str]:
322:    def can_handle(self, error: Exception, evaluated_kwargs: dict[str, Any]) -> bool:
334:    def _is_positional_argument_error(self, error: Exception) -> bool:
347:    def recover(
52:    def validate_instantiation(self, args: dict[str, Any]) -> bool:
86:    def _validate_field_type(self, field_name: str, value: Any, expected_type: str) -> bool:
123:    def get_field_type(self, field_name: str) -> str | None:
127:    def get_field_comment(self, field_name: str) -> str | None:
131:    def get_field_description(self, field_name: str) -> str:
178:    def struct_type(self) -> StructType:
235:    def _coerce_value(self, value: Any, field_type: str | None) -> Any:
247:    def _find_similar_field(self, name: str, available_fields: list[str]) -> str | None:
253:        def similarity_score(field: str) -> float:
301:    def get_field_names(self) -> list[str]:
305:    def get_field_value(self, field_name: str) -> Any:
309:    def get_field(self, field_name: str) -> Any:
313:    def set_field_value(self, field_name: str, value: Any) -> None:
317:    def to_dict(self) -> dict[str, Any]:
321:    def call_method(self, method_name: str, *args: Any, **kwargs: Any) -> Any:
360:    def register_method(cls, receiver_types: list[str], method_name: str, function: Any) -> None:
375:    def get_method(cls, type_name: str, method_name: str) -> Any | None:
380:    def has_method(cls, type_name: str, method_name: str) -> bool:
385:    def get_methods_for_type(cls, type_name: str) -> dict[str, Any]:
394:    def clear(cls) -> None:
412:    def register(cls, struct_type: StructType) -> None:
428:    def get(cls, struct_name: str) -> StructType | None:
433:    def exists(cls, struct_name: str) -> bool:
438:    def list_types(cls) -> list[str]:
443:    def clear(cls) -> None:
448:    def create_instance(cls, struct_name: str, values: dict[str, Any]) -> StructInstance:
458:    def get_schema(cls, struct_name: str) -> dict[str, Any]:
494:    def _type_to_json_schema(cls, type_name: str) -> dict[str, Any]:
518:    def validate_json(cls, json_data: dict[str, Any], struct_name: str) -> bool:
544:    def create_instance_from_json(cls, json_data: dict[str, Any], struct_name: str) -> StructInstance:
564:def create_struct_type_from_ast(struct_def, context=None) -> StructType:
608:def register_struct_from_ast(struct_def) -> StructType:
615:def create_struct_instance(struct_name: str, **kwargs) -> StructInstance:
36:    def enhance_prompt(self, prompt: str, type_context: TypeContext | None = None) -> str:
58:    def _get_type_handler(self, expected_type: str) -> Callable[[str, TypeContext], str]:
71:    def _build_type_handlers(self) -> dict[str, Callable[[str, TypeContext], str]]:
80:    def _apply_enhancement(self, prompt: str, enhancement: str, type_name: str) -> str:
90:    def _enhance_for_boolean(self, prompt: str, context: TypeContext) -> str:
97:    def _enhance_for_integer(self, prompt: str, context: TypeContext) -> str:
102:    def _enhance_for_float(self, prompt: str, context: TypeContext) -> str:
107:    def _enhance_for_string(self, prompt: str, context: TypeContext) -> str:
117:    def _enhance_for_structure(self, prompt: str, context: TypeContext) -> str:
127:    def _enhance_for_dana_struct(self, prompt: str, context: TypeContext) -> str:
145:    def _get_struct_info(self, expected_type: str) -> dict | None:
171:    def _build_struct_enhancement(self, struct_name: str, struct_info: dict) -> str:
202:    def _build_field_descriptions(self, struct_type) -> list[str]:
210:    def _build_enhancement_patterns(self) -> dict[str, dict[str, str]]:
279:    def get_enhancement_preview(self, prompt: str, expected_type: str) -> str:
304:def enhance_prompt_for_type(prompt: str, type_context: TypeContext | None = None) -> str:
318:def preview_enhancement(prompt: str, expected_type: str) -> str:
30:def main():
51:        async def _validate_document(self, uri: str, text: str):
71:        def _get_document_text(self, uri: str) -> str | None:
84:    async def did_open(ls: DanaLanguageServer, params: lsp.DidOpenTextDocumentParams):
90:    async def did_change(ls: DanaLanguageServer, params: lsp.DidChangeTextDocumentParams):
98:    async def did_save(ls: DanaLanguageServer, params: lsp.DidSaveTextDocumentParams):
120:    async def hover(ls: DanaLanguageServer, params: lsp.HoverParams) -> lsp.Hover | None:
137:    async def completion(ls: DanaLanguageServer, params: lsp.CompletionParams) -> lsp.CompletionList:
132:    async def analyze(self, text: str) -> list[Any]:
165:    def _analyze_dana_specific_rules(self, text: str, program: Program):
176:    def _analyze_line(self, line: str, line_num: int):
221:    def _has_incorrect_scope_syntax(self, line: str) -> bool:
226:    def _has_string_concatenation(self, line: str) -> bool:
234:    def _has_unscoped_assignment(self, line: str) -> bool:
248:    async def get_hover(self, text: str, line: int, character: int) -> str | None:
272:    def _get_word_at_position(self, line: str, character: int) -> str | None:
290:    def _get_dana_hover_info(self, word: str) -> str | None:
315:    async def get_completions(self, text: str, line: int, character: int) -> list[dict[str, Any]]:
357:    def _should_suggest_scope_prefixes(self, prefix: str) -> bool:
362:    def _parse_error_to_diagnostic(self, error: ParseError):
109:    def set_filename(self, filename: str | None) -> None:
127:    def program(self, items):
145:    def _fix_function_boundary_bug(self, statements):
176:    def _fix_nested_statements(self, statements):
239:    def _is_local_scoped_assignment(self, assignment):
247:    def statement(self, items):
263:    def conditional(self, items):
267:    def if_part(self, items):
271:    def else_part(self, items):
275:    def while_stmt(self, items):
279:    def for_stmt(self, items):
283:    def _transform_item(self, item):
309:    def function_def(self, items):
313:    def method_def(self, items):
317:    def decorators(self, items):
321:    def decorator(self, items):
325:    def struct_definition(self, items):
329:    def struct_field(self, items):
333:    def agent_definition(self, items):
337:    def agent_field(self, items):
341:    def try_stmt(self, items):
345:    def if_stmt(self, items):
349:    def elif_stmts(self, items):
353:    def elif_stmt(self, items):
358:    def assignment(self, items):
367:    def declarative_function_assignment(self, items):
374:    def expr_stmt(self, items):
378:    def return_stmt(self, items):
382:    def break_stmt(self, items):
386:    def continue_stmt(self, items):
390:    def pass_stmt(self, items):
394:    def raise_stmt(self, items):
398:    def assert_stmt(self, items):
402:    def use_stmt(self, items):
406:    def agent_stmt(self, items):
410:    def agent_pool_stmt(self, items):
415:    def import_stmt(self, items):
419:    def simple_import(self, items):
423:    def from_import(self, items):
428:    def arg_list(self, items):
432:    def positional_args(self, items):
436:    def named_args(self, items):
440:    def named_arg(self, items):
445:    def _filter_body(self, items):
452:    def identifier(self, items):
456:    def _transform_block(self, block):
493:    def _process_statements_with_boundary_detection(self, statements):
520:    def _is_program_level_statement(self, stmt):
543:    def _is_assignment_to_local_scope(self, assignment_tree):
556:    def _target_uses_local_scope(self, target_tree):
575:    def parameters(self, items):
579:    def parameter(self, items):
583:    def binary_expr(self, items):
597:    def _filter_relevant_items(self, items):
618:    def basic_type(self, items):
622:    def typed_assignment(self, items):
626:    def simple_assignment(self, items):
630:    def function_call_assignment(self, items):
634:    def compound_assignment(self, items):
638:    def compound_op(self, items):
642:    def return_object_stmt(self, items):
646:    def typed_parameter(self, items):
650:    def mixed_arguments(self, items):
654:    def with_arg(self, items):
658:    def with_context_manager(self, items):
662:    def with_stmt(self, items):
666:    def create_location(self, item: Any) -> Location | None:
675:    def statements(self, items):
76:    def set_declarative_function_context(self, in_declarative_function: bool):
80:    def expression(self, items):
115:            def custom_transformer(node: Any) -> Any:
174:    def _extract_operator_string(self, op_token):
178:    def _op_tree_to_str(self, tree):
189:    def _left_associative_binop(self, items, operator_getter):
197:    def _get_binary_operator(self, op_str):
225:    def or_expr(self, items):
236:    def and_expr(self, items):
247:    def placeholder_expression(self, items):
251:    def pipe_expr(self, items):
294:                "Use 'def function_name() = expr1 | expr2' syntax instead of assignment."
300:    def _is_in_declarative_function_context(self):
304:    def _is_literal_expression(self, expr):
324:    def not_expr(self, items):
366:    def comparison(self, items):
369:    def sum_expr(self, items):
373:    def term(self, items):
377:    def factor(self, items):
429:    def power(self, items):
465:    def atom(self, items):
513:    def _atom_from_token(self, token):
551:    def literal(self, items):
555:    def identifier(self, items):
561:    def argument(self, items):
574:    def _process_function_arguments(self, arg_children):
599:    def tuple(self, items):
611:    def list(self, items):
626:    def dict(self, items):
639:    def set(self, items):
651:    def TRUE(self, items=None):
654:    def FALSE(self, items=None):
657:    def NONE(self, items=None):
660:    def trailer(self, items):
698:    def _get_full_attribute_name(self, attr):
710:    def key_value_pair(self, items):
716:    def expr(self, items):
720:    def string(self, items):
797:    def product(self, items):
805:    def POW(self, token):
809:    def ADD(self, token):
813:    def SUB(self, token):
817:    def MUL(self, token):
821:    def DIV(self, token):
825:    def FDIV(self, token):
829:    def MOD(self, token):
833:    def string_literal(self, items):
886:    def slice_or_index(self, items):
890:    def slice_start_only(self, items):
894:    def slice_stop_only(self, items):
898:    def slice_start_stop(self, items):
902:    def slice_start_stop_step(self, items):
906:    def slice_all(self, items):
910:    def slice_step_only(self, items):
914:    def slice_expr(self, items):
919:    def slice_list(self, items):
931:    def function_composition_expr(self, items):
936:    def function_pipe_expr(self, items):
951:    def function_expr(self, items):
956:    def function_name(self, items):
961:    def function_call(self, items):
968:    def function_list_literal(self, items):
46:    def assignment(self, items):
55:    def typed_assignment(self, items):
64:    def simple_assignment(self, items):
72:    def compound_assignment(self, items):
124:    def compound_op(self, items):
129:    def function_call_assignment(self, items):
153:    def declarative_function_assignment(self, items):
202:    def _transform_function_composition(self, composition_tree):
223:    def _transform_parameter(self, param_tree):
240:    def _transform_type_hint(self, type_tree):
254:    def return_object_stmt(self, items):
268:    def basic_type(self, items):
272:    def typed_parameter(self, items):
5:- Function definitions (def statements)
45:    def function_def(self, items):
81:    def method_def(self, items):
150:    def _extract_decorators_and_name(self, relevant_items):
171:    def _resolve_function_parameters(self, relevant_items, current_index):
195:    def _extract_return_type(self, relevant_items, current_index):
214:    def _extract_function_body(self, relevant_items, current_index):
229:    def decorators(self, items):
233:    def decorator(self, items):
237:    def _transform_decorators(self, decorators_tree):
245:    def _transform_decorator(self, decorator_tree):
251:    def _transform_decorator_from_items(self, items):
268:    def _parse_decorator_arguments(self, arguments_tree):
291:    def _transform_parameters(self, parameters_tree):
297:    def _transform_parameter(self, param_tree):
306:    def parameters(self, items):
342:    def parameter(self, items):
364:    def struct_definition(self, items):
385:    def struct_field(self, items):
423:    def agent_definition(self, items):
444:    def agent_field(self, items):
38:    def expr_stmt(self, items):
42:    def return_stmt(self, items):
46:    def break_stmt(self, items):
50:    def continue_stmt(self, items):
54:    def pass_stmt(self, items):
58:    def raise_stmt(self, items):
62:    def assert_stmt(self, items):
68:    def import_stmt(self, items):
73:    def simple_import(self, items):
117:    def from_import(self, items):
211:    def arg_list(self, items):
215:    def positional_args(self, items):
219:    def named_args(self, items):
228:    def named_arg(self, items):
43:    def conditional(self, items):
53:    def if_part(self, items):
59:    def else_part(self, items):
63:    def if_stmt(self, items):
111:    def elif_stmts(self, items):
142:    def elif_stmt(self, items):
152:    def while_stmt(self, items):
161:    def for_stmt(self, items):
209:    def try_stmt(self, items):
239:    def except_clause(self, items):
258:    def except_spec(self, items):
278:    def exception_type(self, items):
295:    def exception_list(self, items):
30:    def variable(self, items):
38:    def scoped_var(self, items):
54:        def raw_name(item):
72:    def simple_name(self, items):
84:    def dotted_access(self, items):
123:    def identifier(self, items):
137:    def _extract_name(self, item):
158:    def _join_dotted(self, parts):
164:    def _insert_scope_if_missing(self, name):
31:    def set_filename(self, filename: str | None) -> None:
35:    def _parse_literal(self, text):
39:    def _create_literal(self, token):
43:    def _insert_local_scope(self, parts: list[str] | str) -> Any:
48:    def get_leaf_node(item: Tree | Token | ASTNode) -> Token | ASTNode:
52:    def flatten_items(self, items):
59:    def unwrap_single_child_tree(self, item, stop_at=None):
73:    def get_location(self, item: Any) -> tuple[int, int] | None:
89:    def create_location(self, item: Any) -> Location | None:
29:    def set_filename(self, filename: str | None) -> None:
42:    def transform(self, tree):
29:    def trailer(self, items):
160:    def argument(self, items):
175:    def _process_function_arguments(self, arg_children):
202:    def slice_or_index(self, items):
206:    def slice_start_only(self, items):
210:    def slice_stop_only(self, items):
214:    def slice_start_stop(self, items):
218:    def slice_start_stop_step(self, items):
222:    def slice_all(self, items):
226:    def slice_step_only(self, items):
230:    def slice_expr(self, items):
235:    def slice_list(self, items):
246:    def _get_full_attribute_name(self, attr):
24:    def extract_operator_string(op_token):
47:    def op_tree_to_str(tree):
55:    def left_associative_binop(items, operator_getter):
79:    def get_binary_operator(op_str):
114:    def atom_from_token(token):
138:    def process_string_literal(item):
179:    def get_full_attribute_name(attr):
27:    def _extract_operator_string(self, op_token):
38:    def _op_tree_to_str(self, tree):
45:    def _left_associative_binop(self, items, operator_getter):
69:    def _get_binary_operator(self, op_str):
99:    def or_expr(self, items):
103:    def and_expr(self, items):
107:    def pipe_expr(self, items):
111:    def not_expr(self, items):
136:    def comparison(self, items):
140:    def sum_expr(self, items):
144:    def term(self, items):
148:    def factor(self, items):
173:    def power(self, items):
193:    def ADD(self, token):
197:    def SUB(self, token):
201:    def MUL(self, token):
205:    def DIV(self, token):
209:    def FDIV(self, token):
213:    def MOD(self, token):
217:    def POW(self, token):
221:    def PIPE(self, token):
225:    def EQ_OP(self, token):
229:    def NE_OP(self, token):
233:    def LT_OP(self, token):
237:    def GT_OP(self, token):
241:    def LE_OP(self, token):
245:    def GE_OP(self, token):
249:    def IN_OP(self, token):
253:    def NOT_IN_OP(self, token):
257:    def IS_OP(self, token):
261:    def IS_NOT_OP(self, token):
265:    def NOT_OP(self, token):
35:    def validate_function_call_trailer(trailer: Any) -> None:
47:    def validate_attribute_trailer(trailer: Any) -> None:
66:    def handle_function_call(self, current_base: Expression, trailer: Any) -> ObjectFunctionCall | FunctionCall:
94:    def _create_method_call(self, attribute_access: AttributeAccess, args: dict[str, Any]) -> ObjectFunctionCall:
103:    def _create_function_call(self, base: Expression, args: dict[str, Any]) -> FunctionCall:
119:    def handle_attribute_access(self, current_base: Expression, trailer: Any) -> AttributeAccess:
149:    def handle_indexing(self, current_base: Expression, trailer: Any) -> SubscriptExpression:
170:    def analyze_chain(self, trailers: list[Any]) -> dict[str, Any]:
198:    def _count_trailer_types(self, trailers: list[Any]) -> dict[str, int]:
230:    def process_trailers(self, base: Expression, trailers: list[Any]) -> Expression:
267:    def _process_single_trailer(self, current_base: Expression, trailer: Any, position: int) -> Expression:
76:    def from_type_hint(type_hint: "TypeHint") -> "DanaType":
103:    def get(self, name: str) -> DanaType | None:
111:    def set(self, name: str, type_: DanaType) -> None:
115:    def register(self, name: str, type_: DanaType) -> None:
119:    def push_scope(self):
123:    def pop_scope(self):
134:    def check_program(self, program: Program) -> None:
139:    def check_statement(self, statement: Any) -> None:
185:    def check_assignment(self, node: Assignment) -> None:
225:    def check_compound_assignment(self, node: CompoundAssignment) -> None:
256:    def check_conditional(self, node: Conditional) -> None:
267:    def check_while_loop(self, node: WhileLoop) -> None:
276:    def check_for_loop(self, node: ForLoop) -> None:
306:    def check_try_block(self, node: TryBlock) -> None:
316:    def check_except_block(self, node: ExceptBlock) -> None:
321:    def check_function_definition(self, node: FunctionDefinition) -> None:
376:    def check_method_definition(self, node: MethodDefinition) -> None:
427:    def check_struct_definition(self, node: StructDefinition) -> None:
442:    def check_import_statement(self, node: ImportStatement) -> None:
446:    def check_import_from_statement(self, node: ImportFromStatement) -> None:
450:    def check_expression(self, expression: Any) -> DanaType:
492:    def check_literal_expression(self, node: LiteralExpression) -> DanaType:
496:    def check_identifier(self, node: Identifier) -> DanaType:
514:    def check_binary_expression(self, node: BinaryExpression) -> DanaType:
580:    def check_unary_expression(self, node: UnaryExpression) -> DanaType:
589:    def check_attribute_access(self, node: AttributeAccess) -> DanaType:
596:    def check_subscript_expression(self, node: SubscriptExpression) -> DanaType:
614:    def check_dict_literal(self, node: DictLiteral) -> DanaType:
623:    def check_set_literal(self, node: SetLiteral) -> DanaType:
629:    def check_tuple_literal(self, node: TupleLiteral) -> DanaType:
635:    def check_list_literal(self, node: ListLiteral) -> DanaType:
641:    def check_function_call(self, node: FunctionCall) -> DanaType:
651:    def check_assert_statement(self, node: AssertStatement) -> None:
661:    def check_raise_statement(self, node: RaiseStatement) -> None:
671:    def check_return_statement(self, node: ReturnStatement) -> None:
677:    def check_use_statement(self, node: UseStatement) -> DanaType:
688:    def check_types(program: Program) -> None:
52:    def is_valid(self) -> bool:
129:    def parse(self, program_text: str, do_transform: bool = True, do_type_check: bool = False, filename: str | None = None) -> Any:
156:    def transform(self, parse_tree: Tree, do_type_check: bool = False) -> Program:
184:    def parse_expression(self, expr_text: str):
208:    def _deprecated_transform_identifier(self, node: Tree) -> Identifier:
224:def parse_program(program_text: str, do_type_check: bool = ENABLE_TYPE_CHECK) -> Program:
103:    def _register_cleanup(self):
109:    def _create_default_context(self) -> SandboxContext:
115:        def feedback_placeholder(result: Any, feedback_data: Any):
123:    def _ensure_initialized(self):
155:    def _can_reuse_shared_resources(self) -> bool:
163:    def _use_shared_resources(self):
171:    def _initialize_new_resources(self):
203:    def _cleanup(self):
247:    def _cleanup_instance_resources(self):
274:    def _cleanup_shared_resources(cls):
301:    def _cleanup_on_deletion(weakref_obj):
322:    def _cleanup_all_instances(cls):
338:    def cleanup_all(cls):
346:    def is_healthy(self) -> bool:
359:    def run_file(self, file_path: str | Path) -> ExecutionResult:
445:    def eval(self, source_code: str, filename: str | None = None) -> ExecutionResult:
529:    def quick_run(cls, file_path: str | Path, debug_mode: bool = False, context: SandboxContext | None = None) -> ExecutionResult:
545:    def quick_eval(
587:    def context(self) -> SandboxContext:
591:    def load_file(self, file_path: str) -> None:
598:    def function_registry(self):
31:    def evaluate(self, context) -> Any:
152:    def type(self):
457:    """Method definition statement with explicit receiver (e.g., def (point: Point) translate(dx, dy):)."""
470:    """Declarative function definition statement (e.g., def func(x: int) -> str = f1 | f2)."""
89:    def parent_context(self) -> Optional["SandboxContext"]:
94:    def manager(self) -> Optional["ContextManager"]:
99:    def manager(self, manager: "ContextManager") -> None:
104:    def interpreter(self) -> "DanaInterpreter":
111:    def interpreter(self, interpreter: "DanaInterpreter"):
120:    def error_context(self):
124:    def get_interpreter(self) -> Optional["DanaInterpreter"]:
132:    def _validate_key(self, key: str) -> tuple[str, str]:
163:    def _normalize_key(self, scope: str, var_name: str) -> str:
175:    def set(self, key: str, value: Any) -> None:
201:    def get(self, key: str, default: Any = None) -> Any:
234:    def get_execution_status(self) -> ExecutionStatus:
242:    def set_execution_status(self, status: ExecutionStatus) -> None:
250:    def add_execution_history(self, entry: dict[str, Any]) -> None:
261:    def reset_execution_state(self) -> None:
267:    def from_dict(cls, data: dict[str, Any], base_context: Optional["SandboxContext"] = None) -> "SandboxContext":
308:    def set_in_scope(self, var_name: str, value: Any, scope: str = "local") -> None:
333:    def has(self, key: str) -> bool:
353:    def delete(self, key: str) -> None:
375:    def clear(self, scope: str | None = None) -> None:
392:    def get_state(self) -> dict[str, dict[str, Any]]:
400:    def set_state(self, state: dict[str, dict[str, Any]]) -> None:
418:    def merge(self, other: "SandboxContext") -> None:
427:    def copy(self) -> "SandboxContext":
456:    def sanitize(self) -> "SandboxContext":
550:    def get_scope(self, scope: str) -> dict[str, Any]:
561:    def set_scope(self, scope: str, context: dict[str, Any] | None = None) -> None:
570:    def get_from_scope(self, var_name: str, scope: str = "local") -> Any:
605:    def get_assignment_target_type(self) -> Any | None:
627:    def set_resource(self, name: str, resource: BaseResource) -> None:
641:    def get_resource(self, name: str) -> BaseResource:
647:    def get_resources(self, included: list[str | BaseResource] | None = None) -> dict[str, BaseResource]:
677:    def soft_delete_resource(self, name: str) -> None:
684:    def list_resources(self) -> list[str]:
693:    def delete_from_scope(self, var_name: str, scope: str = "local") -> None:
721:    def set_agent(self, name: str, agent: BaseResource) -> None:
735:    def get_agent(self, name: str) -> BaseResource:
741:    def get_agents(self, included: list[str | BaseResource] | None = None) -> dict[str, BaseResource]:
757:    def soft_delete_agent(self, name: str) -> None:
764:    def list_agents(self) -> list[str]:
773:    def get_self_agent_card(self, included_resources: list[str | BaseResource] | None = None) -> dict[str, dict[str, Any]]:
810:    def get_other_agent_cards(self, included_agents: list[str | BaseResource] | None = None) -> dict[str, dict[str, Any]]:
816:    def startup(self) -> None:
821:    def shutdown(self) -> None:
37:    def _smart_max(*args):
55:    def _smart_min(*args):
73:    def _smart_sum(*args):
405:    def _semantic_bool_wrapper(cls, value):
416:    def create_function(cls, name: str):
431:        def dana_wrapper(context: SandboxContext, *args, **kwargs):
446:    def _raise_unsupported_error(cls, name: str):
470:    def _handle_unknown_builtin(cls, name: str):
575:    def _validate_args(cls, name: str, args: tuple, expected_signatures: list[tuple]):
618:    def _execute_with_guards(cls, func: callable, args: tuple):
625:    def get_available_functions(cls) -> list[str]:
630:    def get_function_info(cls, name: str) -> dict[str, Any]:
637:    def get_unsupported_functions(cls) -> list[str]:
642:    def get_unsupported_info(cls, name: str) -> dict[str, Any]:
649:    def is_supported(cls, name: str) -> bool:
654:    def is_unsupported(cls, name: str) -> bool:
659:    def get_functions_by_reason(cls, reason: UnsupportedReason) -> list[str]:
664:    def get_security_report(cls) -> dict[str, Any]:
696:def register_pythonic_builtins(registry: FunctionRegistry) -> None:
735:        def create_unsupported_handler(name):
736:            def unsupported_handler(context: SandboxContext, *args, **kwargs):
9:def create_function_with_better_doc_string(func: Callable, doc_string: str) -> Callable:
13:    def wrapper(*args, **kwargs):
17:    async def async_wrapper(*args, **kwargs):
28:def use_function(context: SandboxContext, function_name: str, *args, _name: str | None = None, **kwargs) -> BaseResource:
19:def cast_function(context: SandboxContext, target_type: Any, value: Any) -> Any:
15:def noop_function(
7:def agent_function(context: SandboxContext, *args, _name: str | None = None, **kwargs) -> AbstractDanaAgent:
31:def _create_module_agent(context: SandboxContext, name: str, module, **kwargs) -> AbstractDanaAgent:
60:def _create_a2a_agent(context: SandboxContext, name: str, *args, **kwargs) -> AbstractDanaAgent:
94:def agent_pool_function(context: SandboxContext, *args, _name: str | None = None, **kwargs) -> BaseResource:
20:def register_core_functions(registry: FunctionRegistry) -> None:
16:def load_dana_env(dot_env_file_path: Path | str | None = None):
53:    def _resolve_user_identity(self, provided_user_id: str = None) -> str:
82:    def _resolve_instance_identity(self, provided_instance_id: str = None) -> str:
115:    def _resolve_session_identity(self, provided_session_id: str = None) -> str:
138:    def _initialize_simplified_memory_system(self):
183:    def _initialize_cross_session_persistence(self):
195:    def _restore_session_context(self):
224:    def _wrap_agent_methods(self):
235:    def _context_aware_solve(self, input_data: str, context: str | None = None) -> str:
245:    def _solve_with_memory_system(self, input_data: str, context: str | None = None) -> str:
281:    def _get_memory_context(self, input_data: str) -> dict:
290:    def _store_interaction_in_memory(self, input_data: str, response: str, complete_conversation: str):
299:    def _solve_with_basic_context(self, input_data: str, context: str | None = None) -> str:
330:    def _context_aware_reason(self, prompt: str, **kwargs) -> str:
353:    def _build_contextual_prompt(self, input_data: str) -> str:
393:    def _enhance_prompt_with_context(self, original_prompt: str) -> str:
412:    def _build_memory_enhanced_prompt(self, input_data: str, memory_context: dict) -> str:
448:    def _build_persistent_context_prompt(self, input_data: str, memory_context: dict) -> str:
495:    def _build_memory_context_summary(self, memory_context: dict) -> str:
517:    def _build_memory_enhanced_input(self, input_data: str) -> str:
544:    def _get_comprehensive_memory_context(self) -> str:
585:    def _extract_conversations_from_memories(self, memories) -> list:
634:    def _extract_user_facts_from_memories(self, memories) -> list:
645:    def _build_direct_memory_context(self, memory_items: list) -> str:
661:    def _run_async_safely(self, coro):
668:    def get_context_info(self) -> dict[str, Any]:
699:    def get_conversation_summary(self) -> str:
720:    def get_persistence_status(self) -> dict[str, Any]:
741:    def reset_context(self):
50:    def add_turn(self, user_input: str, agent_response: str, context_used: dict[str, Any] = None):
61:    def get_recent_history(self, n: int = 5) -> list[ConversationTurn]:
65:    def get_conversation_context(self) -> str:
78:    def extract_user_info(self, text: str) -> dict[str, Any]:
106:    def get_user_context(self) -> dict[str, Any]:
120:    def _generate_conversation_summary(self) -> str:
142:    def should_include_context(self) -> bool:
147:    def clear_session(self):
45:def _default_metadata() -> MemoryMetadata:
60:    def content(self) -> str:
64:    def embedding(self) -> list[float] | None:
68:    def memory_type(self) -> MemoryType:
72:    def confidence(self) -> float | None:
85:    def add_memory(self, memory: MemoryItem, target_type: str | None = None):
89:    def get_all_memories(self) -> list[MemoryItem]:
29:    async def initialize(self):
35:    async def extract_memories(self, conversation_content: str, user_id: str) -> list[dict[str, Any]]:
63:    def _build_extraction_prompt(self, content: str) -> str:
113:    def _parse_memory_response(self, response_content: Any, original_content: str) -> list[dict[str, Any]]:
138:    def _validate_memories(self, memories: list[dict[str, Any]]) -> list[dict[str, Any]]:
186:    def _fallback_extraction(self, content: str) -> list[dict[str, Any]]:
232:    async def initialize(self):
238:    async def detect_intent(self, query: str, working_memory: list[MemoryItem]) -> dict[str, Any]:
267:    def _format_memory_context(self, memories: list[MemoryItem]) -> str:
278:    def _build_intent_prompt(self, query: str, memory_context: str) -> str:
302:    def _parse_intent_response(self, response_content: Any, query: str) -> dict[str, Any]:
332:    def _fallback_intent_detection(self, query: str, working_memory: list[MemoryItem]) -> dict[str, Any]:
361:    async def initialize(self):
367:    async def rank_memories(self, query: str, memories: list[MemoryItem]) -> list[MemoryItem]:
403:    def _build_ranking_prompt(self, query: str, memory_texts: list[str]) -> str:
423:    def _parse_ranking_response(self, response_content: Any, memories: list[MemoryItem]) -> list[MemoryItem]:
457:    def _simple_rank_memories(self, query: str, memories: list[MemoryItem]) -> list[MemoryItem]:
465:        def relevance_score(memory: MemoryItem) -> float:
21:    def _serialize_memory_item(self, memory: MemoryItem) -> dict[str, Any]:
41:    def _deserialize_memory_item(self, data: dict[str, Any]) -> MemoryItem:
63:    def _load_memories(self) -> list[MemoryItem]:
76:    def _save_memories(self, memories: list[MemoryItem]):
82:    def _text_search(self, memories: list[MemoryItem], query: str, limit: int) -> list[MemoryItem]:
127:    async def store(self, memory: MemoryItem) -> bool:
145:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
153:    async def search_by_text(self, query: str, limit: int = 10) -> list[MemoryItem]:
159:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
168:    def _is_duplicate(self, new_memory: MemoryItem, existing_memories: list[MemoryItem]) -> bool:
202:    async def store(self, memory: MemoryItem) -> bool:
210:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
216:    async def search_by_text(self, query: str, limit: int = 10) -> list[MemoryItem]:
222:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
231:    async def get_user_profile_summary(self) -> dict[str, Any]:
279:    async def store(self, memory: MemoryItem) -> bool:
298:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
304:    async def search_by_text(self, query: str, limit: int = 10) -> list[MemoryItem]:
310:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
319:    def _should_share(self, memory: MemoryItem) -> bool:
348:    def _sanitize_memory(self, memory: MemoryItem) -> MemoryItem:
361:    async def get_collective_stats(self) -> dict[str, Any]:
12:    async def store(self, memory: MemoryItem) -> bool:
16:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
20:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
41:    def _get_storage_file_path(self) -> Path:
47:    def _load_memories(self):
60:    def _save_memories(self):
77:    def _serialize_memory(self, memory: MemoryItem) -> dict:
97:    def _deserialize_memory(self, data: dict) -> MemoryItem | None:
123:    async def store(self, memory: MemoryItem) -> bool:
131:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
136:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
143:    def clear_and_keep_recent(self, keep_count: int = 10):
150:    def replace_with_items(self, items_to_keep: list):
165:    async def store(self, memory: MemoryItem) -> bool:
173:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
178:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
194:    async def store(self, memory: MemoryItem) -> bool:
199:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
203:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
221:    async def store(self, memory: MemoryItem) -> bool:
228:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
232:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
67:    def _initialize_index(self):
98:    def _load_memory_metadata(self):
130:    def _save_memory_metadata(self):
158:    def _create_document_from_memory(self, memory: MemoryItem) -> Document:
176:    async def store(self, memory: MemoryItem) -> bool:
207:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
215:    async def search_by_text(self, query: str, limit: int) -> list[MemoryItem]:
242:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
247:    def get_query_engine(self, similarity_top_k: int = 10):
264:    def get_memory_count(self) -> int:
282:    async def store(self, memory: MemoryItem) -> bool:
300:    def _is_semantic_duplicate(self, new_content: str, existing_content: str) -> bool:
325:    async def get_user_profile_summary(self, query: str = "user preferences and characteristics") -> str:
347:    async def search_user_preferences(self, topic: str, limit: int = 10) -> list[MemoryItem]:
375:    async def store(self, memory: MemoryItem) -> bool:
403:    def _should_store_in_shared(self, memory: MemoryItem) -> bool:
432:    async def _rebuild_index(self):
462:    async def search_collective_knowledge(self, query: str, limit: int = 10) -> list[MemoryItem]:
466:    async def get_popular_topics(self, limit: int = 10) -> list[str]:
81:    def _count_tokens(self, text: str) -> int:
87:    def _get_working_memory_token_count(self, memories: list[MemoryItem]) -> int:
92:    def _get_recent_items_by_token_limit(self, memories: list[MemoryItem], token_limit: int) -> list[MemoryItem]:
113:    async def add_conversation_memory(self, memory_content: str) -> list[MemoryItem]:
142:    async def process_working_memory_batch(self):
222:    async def manual_batch_process(self):
226:    async def chat_with_memory(self, query: str) -> dict[str, Any]:
255:    async def retrieve_context(self, query: str) -> list[str]:
274:    async def get_user_profile(self) -> dict[str, Any]:
300:    async def advanced_query(self, query: str, memory_type: str = "long_term") -> str:
328:    async def search_by_text(self, query: str, memory_type: str = "all", limit: int = 10) -> list[MemoryItem]:
357:    async def get_current_working_memory_tokens(self) -> int:
362:    async def get_memory_statistics(self) -> dict[str, Any]:
409:    async def _search_persistent_memories(self, missing_evidence: list[str]) -> list[MemoryItem]:
426:    async def _replace_working_memory_with_llm_ranking(self, query: str, original: list[MemoryItem], retrieved: list[MemoryItem]) -> None:
88:    def with_planning(
121:    def with_reasoning(
152:    def _create_llm(self, llm: dict | str | LLMResource, name: str) -> LLMResource:
164:    def runtime_context(self) -> RuntimeContext:
171:    def planner(self) -> Planner:
178:    def planner(self, planner: Planner | None) -> None:
183:    def reasoner(self) -> Reasoner:
190:    def reasoner(self, reasoner: Reasoner | None) -> None:
195:    def _current_plan(self) -> Plan:
210:        def handle_plan_get(key: str, default: Any) -> Any:
214:        def handle_plan_set(key: str, value: Any) -> None:
231:    async def execute(self, plan: "Plan") -> Any:
30:    def create_agent(cls, config: dict[str, Any]) -> Agent:
18:def default_plan_method(context: SandboxContext, agent_instance: "AgentInstance", task: str, user_context: dict | None = None) -> Any:
39:def default_solve_method(context: SandboxContext, agent_instance: "AgentInstance", problem: str, user_context: dict | None = None) -> Any:
75:    def add_method(self, method_name: str, method_func: Any) -> None:
78:    def get_method(self, method_name: str) -> Any | None:
87:    def has_method(self, method_name: str) -> bool:
130:    def _initialize_context_management(self):
141:    def agent_card(self) -> dict[str, Any]:
158:    def skills(self) -> list[dict[str, Any]]:
162:    def agent_type(self) -> AgentType:
165:    def solve(self, task: str) -> str:
179:    def plan(self, task: str, user_context: dict | None = None) -> Any:
182:    def get_context_info(self) -> dict:
189:    def get_conversation_summary(self) -> str:
196:    def reset_context(self):
201:    def get_persistence_status(self) -> dict:
208:    def _call_method(self, method, *args, **kwargs):
244:    def _call_method_with_current_context(self, method, *args, **kwargs):
269:    def _get_current_execution_context(self):
307:    def call_method(self, method_name: str, *args: Any, **kwargs: Any) -> Any:
314:    def to_dict(self) -> dict[str, Any]:
321:    def _try_global_function_fallback(self, method_name: str) -> Any | None:
340:                def agent_method_wrapper(*args, **kwargs):
351:    def _function_matches_agent_type(self, func: Any, agent_type_name: str) -> bool:
394:    def _get_function_registry(self):
419:    def register(cls, agent_type: AgentType) -> None:
423:    def get(cls, agent_name: str) -> AgentType | None:
427:    def exists(cls, agent_name: str) -> bool:
431:    def list_types(cls) -> list[str]:
435:    def clear(cls) -> None:
439:    def create_instance(cls, agent_name: str, values: dict[str, Any], context: SandboxContext, instance_id: str = None) -> AgentInstance:
447:def create_agent_type_from_ast(agent_def) -> AgentType:
468:def register_agent_from_ast(agent_def) -> AgentType:
474:def create_agent_instance(agent_name: str, context: SandboxContext, **kwargs) -> AgentInstance:
478:def register_agent_method_from_function_def(node, dana_func):
67:    def _load_default_config(self) -> dict[str, Any]:
79:    def _find_first_available_model(self) -> str | None:
112:    def _get_required_env_vars_for_model(self, model_name: str) -> list[str]:
143:    def _load_from_file(self, config_path: str) -> None:
185:    def _load_json_file(self, path: Path) -> None:
204:    def _update_logging_from_env(self) -> None:
208:        def safe_int(value: str, default: int) -> int:
225:    def get(self, key: str, default: Any = None) -> Any:
229:    def update(self, config: dict[str, Any]) -> None:
53:    def new_instance(cls, response: BaseResponse | dict[str, Any] | Any) -> "AgentResponse":
97:    def state(self) -> AgentState:
104:    def runtime(self) -> AgentRuntime:
111:    def agent_llm(self) -> LLMResource:
118:    def available_resources(self) -> dict[str, BaseResource]:
125:    def capabilities(self) -> dict[str, BaseCapability]:
132:    def io(self) -> BaseIO:
139:    def with_model(self, model: str) -> "Agent":
144:    def with_llm(self, llm: dict | str | LLMResource) -> "Agent":
154:    def with_resources(self, resources: dict[str, BaseResource]) -> "Agent":
161:    def with_capabilities(self, capabilities: dict[str, BaseCapability]) -> "Agent":
168:    def with_io(self, io: BaseIO) -> "Agent":
173:    def with_planning(
189:    def with_reasoning(
206:    def _get_default_llm_resource(self):
210:    def _create_llm(self, llm: dict | str | LLMResource, name: str) -> LLMResource:
221:    def _initialize(self) -> "Agent":
236:    async def cleanup(self) -> None:
242:    async def initialize(self) -> "Agent":
256:    async def async_run(self, plan: Plan, context: RuntimeContext | None = None) -> AgentResponse:
262:    def run(self, plan: Plan) -> AgentResponse:
265:        async def _run_async():
270:    def ask(self, question: str) -> AgentResponse:
275:    def runtime_context(self) -> RuntimeContext:
280:    async def set_variable(self, name: str, value: Any) -> BaseResponse:
285:    async def query(self, request: BaseRequest) -> BaseResponse:
289:    def has_capability(self, capability: BaseCapability | str) -> bool:
303:    def add_capability(self, name: str, capability: BaseCapability) -> None:
312:    def remove_capability(self, name: str) -> None:
57:    async def create(cls, name: str, agent: "Agent", description: str) -> "AgentResource":
73:    async def query(self, request: BaseRequest | None = None) -> BaseResponse:
99:    async def initialize(self) -> None:
111:    async def cleanup(self) -> None:
98:    def expertise(self) -> DomainExpertise | None:
103:    def confidence_threshold(self) -> float:
108:    def system_prompt(self) -> str | None:
113:    def llm_config(self) -> dict[str, Any]:
117:    async def initialize(self) -> None:
123:    async def query(self, request: BaseRequest | None = None) -> BaseResponse:
143:    async def cleanup(self) -> None:
148:    def can_handle(self, request: dict[str, Any]) -> bool:
16:    def create_resource(cls, resource_type: str, config: dict[str, Any]) -> BaseResource:
25:    def create_llm_resource(cls, config: dict[str, Any]) -> LLMResource:
16:def main():
28:def parse_dana_input_args(input_strs: list[str] | tuple[str, ...]) -> dict[str, str]:
72:    def resolve_at_file(value: str, is_file: bool) -> str:
46:    def mcp_tool_decorator(self, func_name: str) -> Any:
49:        def wrapper(**kwargs) -> Any:
78:    async def initialize(self) -> None:
83:    async def _discover_tools(self) -> None:
94:    def _list_tools(self, format_converter: OpenAIToolFormat) -> list[Any]:
105:    async def call_tool(self, tool_name: str, arguments: dict[str, Any]) -> Any:
123:    async def query(self, request: BaseRequest) -> BaseResponse:
145:    def can_handle(self, request: BaseRequest) -> bool:
159:    async def main():
12:    def parse_init_params(cls, *args, **kwargs) -> ParsedArgKwargsResults:
86:    def _validate_transport(cls, *args, **kwargs) -> BaseTransport:
96:    async def _try_client_with_valid_transport(cls, transport: BaseTransport) -> bool:
6:def extract_text_from_response(response: Message) -> str:
34:    def select_agent(self, task: any, strategy: str = "llm", included_resources: list[str | Any] | None = None) -> Any:
52:    def _select_by_llm(self, task: any, included_resources: list[str | Any] | None = None) -> Any:
126:    def _get_agent_skills(self, agent: Any) -> list[str]:
139:    def _format_agent_cards(self, cards: dict[str, dict]) -> str:
168:    def update_performance_metrics(self, agent_name: str, metrics: dict[str, float]) -> None:
82:    def get_base_path(cls) -> Path:
91:    def get_config_path(
163:    def from_dict(cls, data: dict[str, Any]) -> "Configurable":
183:    def _load_config(self, config_path: str | Path | None = None) -> dict[str, Any]:
218:    def _apply_overrides(self, overrides: dict[str, Any]) -> None:
232:    def _validate_required(self, key: str, error_msg: str | None = None) -> None:
256:    def _validate_type(self, key: str, expected_type: type[T], error_msg: str | None = None) -> None:
282:    def _validate_enum(self, key: str, valid_values: list[Any], error_msg: str | None = None) -> None:
308:    def _validate_path(self, key: str, must_exist: bool = True, error_msg: str | None = None) -> None:
334:    def _validate_config(self) -> None:
350:    def get(self, key: str, default: Any = None) -> Any:
362:    def set(self, key: str, value: Any) -> None:
375:    def update(self, config: dict[str, Any]) -> None:
387:    def to_dict(self) -> dict[str, Any]:
395:    def save(self, path: str | Path) -> None:
418:    def get_yaml_path(cls, path: str | None = None) -> Path:
474:    def get_prompt(cls, config_path: str | None = None, prompt_ref: str | None = None, custom_prompts: dict[str, str] | None = None) -> str:
521:    def load_config(cls, path: str | None = None) -> dict[str, Any]:
29:def configure_asyncio_threshold():
66:    def load_yaml_config(path: str | Path) -> dict[str, Any]:
90:    def _resolve_yaml_path(path: Path) -> Path:
105:    def get_class_by_name(class_path: str) -> type[Any]:
116:    def get_base_path(for_class: type[Any]) -> Path:
121:    def get_config_path(
174:    def safe_asyncio_run(func: Callable[..., Any], *args: Any, **kwargs: Any) -> Any:
206:    def _run_in_existing_loop(func: Callable[..., Any], *args: Any, **kwargs: Any) -> Any:
216:        def run_in_thread():
225:    def get_field(obj: dict | object, field_name: str, default: Any = None) -> Any:
241:    def has_field(obj: dict | object, field_name: str) -> bool:
248:    def generate_base64_uuid(length: int | None = None) -> str:
278:    def parse_args_kwargs(func, *args, **kwargs) -> ParsedArgKwargsResults:
343:    def get_hash(key: str, length: int | None = None) -> str:
350:    def generate_uuid(length: int | None = None) -> str:
358:    def text_to_dict(text: str) -> dict[str, Any]:
378:    def get_response_content(response: BaseResponse) -> Any:
39:    def build_request_params(
75:    def get_openai_functions(self, resources: dict[str, BaseResource]) -> list[OpenAIFunctionCall]:
89:    async def call_requested_tools(self, tool_calls: list[OpenAIFunctionCall]) -> list[dict[str, Any]]:
189:    async def call_tools_legacy(self, tool_calls: list[dict[str, Any]], available_resources: list[BaseResource]) -> list[BaseResponse]:
218:    def format_tool_call_message(self, response_message: dict[str, Any], tool_calls: list[OpenAIFunctionCall]) -> dict[str, Any]:
236:    def has_tool_calls(self, response_message: dict[str, Any]) -> bool:
250:    def register_resources(self, available_resources: dict[str, Any]) -> None:
259:    def unregister_resources(self, available_resources: dict[str, Any]) -> None:
38:    async def initialize(self) -> None:
45:    async def query(self, query: str, num_results: int = 10) -> str:
136:    def _validate_decay_parameters(self) -> None:
150:    def decay_rate(self) -> float:
155:    def decay_rate(self, value: float) -> None:
174:    def half_life(self) -> float:
186:    def decay_interval(self) -> int:
191:    def decay_interval(self, value: int) -> None:
209:    def _should_decay(self) -> bool:
221:    async def _maybe_decay(self) -> None:
240:            def run_decay():
247:    async def decay_memories(self, intervals_passed: float = 1.0) -> None:
280:    async def initialize(self) -> None:
287:    async def cleanup(self) -> None:
295:    async def store(
339:    async def retrieve(self, query: str | None = None, limit: int | None = None) -> BaseResponse:
364:    async def update_importance(self, memory_id: int, importance: float) -> BaseResponse:
384:    def get_decay_stats(self) -> dict[str, Any]:
403:    def can_handle(self, request: dict[str, Any]) -> bool:
449:    def can_handle(self, request: dict[str, Any]) -> bool:
495:    def can_handle(self, request: dict[str, Any]) -> bool:
541:    async def _maybe_decay(self) -> None:
545:    async def decay_memories(self, intervals_passed: float = 1.0) -> None:
549:    def get_decay_stats(self) -> dict[str, Any]:
559:    def can_handle(self, request: dict[str, Any]) -> bool:
17:async def configure_poet(config: dict[str, Any]):
50:async def get_poet_domains():
21:async def upload_document(
43:async def create_document(
69:async def get_document(document_id: int, db: Session = Depends(get_db), document_service=Depends(get_document_service)):
85:async def list_documents(
104:async def download_document(document_id: int, db: Session = Depends(get_db), document_service=Depends(get_document_service)):
126:async def update_document(
144:async def delete_document(document_id: int, db: Session = Depends(get_db), document_service=Depends(get_document_service)):
40:async def generate_agent(request: AgentGenerationRequest, agent_service=Depends(get_agent_service)):
117:async def refine_agent_description(request: AgentDescriptionRequest, db: Session = Depends(get_db)):
196:async def generate_agent_code(request: AgentCodeGenerationRequest, agent_service=Depends(get_agent_service)):
234:async def deploy_agent(request: AgentDeployRequest, db: Session = Depends(get_db)):
284:async def check_dana_syntax(request: DanaSyntaxCheckRequest):
307:async def validate_code(request: CodeValidationRequest):
330:async def fix_code(request: CodeFixRequest):
358:async def process_agent_documents(request: ProcessAgentDocumentsRequest, agent_service=Depends(get_agent_service)):
394:async def list_agents(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
418:async def get_agent(agent_id: int, db: Session = Depends(get_db)):
444:async def create_agent(agent: AgentCreate, db: Session = Depends(get_db)):
470:async def update_agent(agent_id: int, agent: AgentCreate, db: Session = Depends(get_db)):
503:async def delete_agent(agent_id: int, db: Session = Depends(get_db)):
525:async def generate_agent_from_prompt(
560:async def update_agent_description(agent_id: int, request: AgentDescriptionRequest, agent_service=Depends(get_agent_service)):
585:async def validate_agent_code(request: CodeValidationRequest):
599:async def fix_agent_code(request: CodeFixRequest):
613:async def upload_knowledge_file(
668:async def open_file(file_path: str):
681:def _extract_agent_info_from_code(dana_code: str) -> tuple[str | None, str | None]:
19:async def send_chat_message(request: ChatRequest, db: Session = Depends(get_db), chat_service=Depends(get_chat_service)):
19:async def create_topic(request: TopicCreate, db: Session = Depends(get_db), topic_service=Depends(get_topic_service)):
33:async def get_topic(topic_id: int, db: Session = Depends(get_db), topic_service=Depends(get_topic_service)):
49:async def list_topics(
63:async def update_topic(topic_id: int, topic_data: TopicCreate, db: Session = Depends(get_db), topic_service=Depends(get_topic_service)):
81:async def delete_topic(topic_id: int, db: Session = Depends(get_db), topic_service=Depends(get_topic_service)):
19:async def create_conversation(
33:async def get_conversation(
54:async def list_conversations(
72:async def update_conversation(
90:async def delete_conversation(conversation_id: int, db: Session = Depends(get_db), conversation_service=Depends(get_conversation_service)):
107:async def create_message(
121:async def list_messages(
139:async def get_message(
157:async def update_message(
179:async def delete_message(
16:def get_db():
49:async def generate_agent_na(request: AgentGeneratorNARequest):
148:def health():
26:def run_na_file(request: RunNAFileRequest):
31:async def write_multi_file_project(project: MultiFileProject):
77:async def write_multi_file_project_temp(project: MultiFileProject):
124:async def validate_multi_file_project(project: MultiFileProject):
174:            if "agent" in file_info.content.lower() and "def solve" not in file_info.content:
186:        def has_circular_deps(filename, visited=None, path=None):
228:async def open_agent_folder(request: dict):
263:async def get_task_status(task_id: str):
288:async def deep_train_agent(request: dict):
38:async def _llm_fallback(agent_name: str, agent_description: str, message: str) -> str:
109:async def test_agent(request: AgentTestRequest):
10:def health():
15:def get_root_info():
34:def serve_react_index():
12:def run_na_file_service(request: RunNAFileRequest):
23:async def lifespan(app: FastAPI):
31:def create_app():
86:    async def serve_spa(full_path: str):
119:    def startup(self) -> None:
137:    def shutdown(self) -> None:
155:    def get_client(self) -> APIClient:
163:    def local_mode(self) -> bool:
169:    def _load_config(self) -> None:
198:    def _normalize_service_uri(self) -> None:
221:    def _init_api_client(self) -> None:
229:    def _start_local_server(self) -> None:
284:    def _is_server_running(self, port: int) -> bool:
294:    def _find_free_port(self) -> int:
300:    def _wait_for_server_ready(self, port: int, timeout: int = 30) -> None:
319:    def _validate_remote_connection(self) -> None:
343:    def check_health(self) -> bool:
362:    def get_service_uri(self) -> str:
366:    def get_api_key(self) -> str:
9:def main() -> None:
6:def get_multi_file_agent_generation_prompt(intentions: str, current_code: str = "", has_docs_folder: bool = False) -> str:
42:def solve(self : RetrievalExpertAgent, query: str) -> str:
65:def search_document(package: RetrievalPackage) -> RetrievalPackage:
72:def refine_query(package: RetrievalPackage) -> RetrievalPackage:
77:def should_use_rag(package: RetrievalPackage) -> RetrievalPackage:
81:def get_answer(package: RetrievalPackage) -> str:
6:def generate_mock_agent_code(messages, current_code=""):
34:def solve(weather_agent : WeatherAgent, problem : str):
46:def solve(assistant_agent : AssistantAgent, problem : str):
62:def solve(data_agent : DataAgent, problem : str):
78:def solve(document_agent : DocumentAgent, problem : str):
94:def solve(email_agent : EmailAgent, problem : str):
110:def solve(knowledge_agent : KnowledgeAgent, problem : str):
122:def solve(custom_agent : CustomAgent, problem : str):
42:    def startup(self) -> None:
63:    def shutdown(self) -> None:
75:    def _ensure_started(self) -> None:
80:    def post(self, endpoint: str, data: dict[str, Any]) -> dict[str, Any]:
118:    def get(self, endpoint: str, params: dict[str, Any] | None = None) -> dict[str, Any]:
153:    def health_check(self) -> bool:
178:    def close(self):
193:def create_client(base_uri: str, api_key: str | None = None) -> APIClient:
24:    async def process_chat_message(self, chat_request: ChatRequest, db_session) -> ChatResponse:
81:    async def _get_or_create_conversation(self, chat_request: ChatRequest, db_session) -> Conversation:
102:    async def _save_message(self, conversation_id: int, sender: str, content: str, db_session) -> Message:
113:    async def _generate_agent_response(self, chat_request: ChatRequest, conversation: Conversation, db_session) -> str:
124:def get_chat_service() -> ChatService:
24:    async def create_conversation(self, conversation_data: ConversationCreate, db_session) -> ConversationRead:
54:    async def get_conversation(
110:    async def list_conversations(
144:    async def update_conversation_title(self, conversation_id: int, new_title: str, db_session) -> ConversationRead | None:
178:    async def update_conversation(self, conversation_id: int, conversation_data: ConversationCreate, db_session) -> ConversationRead | None:
213:    async def create_message(self, conversation_id: int, message_data: MessageCreate, db_session) -> MessageRead:
245:    async def list_messages(self, conversation_id: int, limit: int = 100, offset: int = 0, db_session=None) -> list[MessageRead]:
284:    async def get_message(self, conversation_id: int, message_id: int, db_session) -> MessageRead | None:
315:    async def update_message(self, conversation_id: int, message_id: int, message_data: MessageCreate, db_session) -> MessageRead | None:
352:    async def delete_message(self, conversation_id: int, message_id: int, db_session) -> bool:
378:    async def delete_conversation(self, conversation_id: int, db_session) -> bool:
408:    async def add_message(self, conversation_id: int, message_data: MessageCreate, db_session) -> MessageRead:
440:    async def get_conversation_messages(
486:def get_conversation_service() -> ConversationService:
34:    async def upload_document(
99:    async def get_document(self, document_id: int, db_session) -> DocumentRead | None:
131:    async def update_document(self, document_id: int, document_data: DocumentUpdate, db_session) -> DocumentRead | None:
178:    async def delete_document(self, document_id: int, db_session) -> bool:
210:    async def list_documents(
255:    async def get_file_path(self, document_id: int, db_session) -> str | None:
277:    def _get_mime_type(self, filename: str) -> str:
311:def get_document_service() -> DocumentService:
26:    async def create_topic(self, topic_data: TopicCreate, db_session) -> TopicRead:
58:    async def get_topic(self, topic_id: int, db_session) -> TopicRead | None:
83:    async def get_topic_by_name(self, name: str, db_session) -> TopicRead | None:
108:    async def list_topics(self, limit: int = 100, offset: int = 0, search: str | None = None, db_session=None) -> list[TopicRead]:
140:    async def update_topic(self, topic_id: int, topic_data: TopicCreate, db_session) -> TopicRead | None:
182:    async def delete_topic(self, topic_id: int, db_session) -> bool:
216:    async def get_topic_statistics(self, topic_id: int, db_session) -> dict[str, Any]:
255:def get_topic_service() -> TopicService:
13:    def clean_generated_code(code: str) -> str:
79:    def parse_multi_file_response(response: str) -> dict:
209:                if line.startswith("def "):
218:                    stub_lines.append(f"def {tool}(query: str) -> str:")
232:    def ensure_all_files_present(project: dict) -> dict:
258:    def get_file_template(filename: str) -> str:
268:def solve(self : Georgia, query: str) -> str:
282:def process_request(package: AgentPackage) -> AgentPackage:
287:def generate_response(package: AgentPackage) -> str:
316:    def determine_file_type(filename: str) -> str:
332:    def get_file_description(filename: str) -> str:
344:    def extract_dependencies(content: str) -> list[str]:
360:    def get_fallback_template() -> str:
369:def solve(basic_agent : BasicAgent, problem : str):
45:    async def initialize(self):
59:    async def generate_agent_code(
156:    async def generate_agent_files_from_prompt(
242:    async def analyze_agent_capabilities(
320:    async def analyze_conversation_completeness(self, messages: list[dict[str, Any]]) -> dict[str, Any]:
393:    async def cleanup(self):
400:    async def _extract_user_intentions(self, messages: list[dict[str, Any]], current_code: str = "") -> str:
442:    def _extract_requirements(self, messages: list[dict[str, Any]]) -> str:
452:    def _create_generation_prompt(self, intentions: str, current_code: str = "", multi_file: bool = False) -> str:
480:    def _create_phase_2_prompt(self, prompt: str, messages: list[dict[str, Any]], agent_summary: dict[str, Any], multi_file: bool) -> str:
505:    def _create_capabilities_analysis_prompt(self, conversation_text: str, all_code_content: str) -> str:
519:    def _extract_response_content(self, result) -> str:
533:    def _extract_summary_from_code_and_conversation(self, dana_code: str, conversation_text: str) -> str:
555:    def _extract_knowledge_domains_from_code(self, dana_code: str, conversation_text: str) -> list[str]:
562:    def _extract_workflow_steps_from_code(self, dana_code: str, conversation_text: str) -> list[str]:
571:    def _extract_agent_tools_from_code(self, dana_code: str) -> list[str]:
583:async def get_agent_service() -> AgentService:
599:def get_multi_file_agent_generation_prompt(intentions: str, current_code: str = "", has_docs_folder: bool = False) -> str:
635:def solve(self : RetrievalExpertAgent, query: str) -> str:
658:def search_document(package: RetrievalPackage) -> RetrievalPackage:
665:def refine_query(package: RetrievalPackage) -> RetrievalPackage:
670:def should_use_rag(package: RetrievalPackage) -> RetrievalPackage:
674:def get_answer(package: RetrievalPackage) -> str:
806:def generate_mock_agent_code(messages, current_code=""):
834:def solve(weather_agent : WeatherAgent, problem : str):
846:def solve(assistant_agent : AssistantAgent, problem : str):
862:def solve(data_agent : DataAgent, problem : str):
878:def solve(document_agent : DocumentAgent, problem : str):
894:def solve(email_agent : EmailAgent, problem : str):
910:def solve(knowledge_agent : KnowledgeAgent, problem : str):
922:def solve(custom_agent : CustomAgent, problem : str):
45:    async def initialize(self):
59:    async def generate_agent_code(
159:    async def _extract_user_intentions(self, messages: list[dict[str, Any]], current_code: str = "") -> str:
224:    def _extract_requirements(self, messages: list[dict[str, Any]]) -> str:
245:    def _create_generation_prompt(self, intentions: str, current_code: str = "", multi_file: bool = False) -> str:
293:def solve([agent_name] : [AgentName], problem : str):
341:def solve([agent_name] : [AgentName], problem : str):
362:    async def cleanup(self):
373:async def get_agent_generator() -> AgentGenerator:
391:async def generate_agent_code_from_messages(
416:async def generate_agent_code_na(messages: list[dict[str, Any]], current_code: str = "") -> tuple[str, str | None]:
492:def _create_agent_generator_na_code(messages: list[dict[str, Any]], current_code: str) -> str:
519:def extract_intentions(messages: list) -> str:
551:def generate_agent_code(messages: list, current_code: str) -> str:
574:- Function parameters must be unquoted: def solve(agent_name : AgentName, problem : str)
576:- **All function definitions (like def solve(...)) must be outside the agent block. The agent block should only contain attribute assignments.**
589:def solve([agent_name] : [AgentName], problem : str):
625:def _test_generated_code(code: str) -> Any:
665:async def _fix_generated_code_with_agent(code: str, error: str, messages: list[dict[str, Any]]) -> str:
722:def _create_code_fixer_na_code(code: str, error: str, messages: list[dict[str, Any]]) -> str:
754:def solve(code_fixer : CodeFixerAgent, problem : str):
776:- Function parameters must be unquoted: def solve(agent_name : AgentName, problem : str)
778:- **All function definitions (like def solve(...)) must be outside the agent block. The agent block should only contain attribute assignments.**
791:def solve([agent_name] : [AgentName], problem : str):
814:def _generate_simple_fallback_agent(messages: list[dict[str, Any]]) -> str:
883:def solve({agent_name.lower()} : {agent_name}, problem : str):
891:async def analyze_conversation_completeness(messages: list[dict[str, Any]]) -> dict[str, Any]:
988:async def analyze_agent_capabilities(
1119:def _extract_summary_from_code_and_conversation(dana_code: str, conversation_text: str) -> str:
1232:def _extract_knowledge_domains_from_code(dana_code: str, conversation_text: str) -> list[str]:
1292:def _extract_workflow_steps_from_code(dana_code: str, conversation_text: str) -> list[str]:
1361:def _extract_agent_tools_from_code(dana_code: str) -> list[str]:
1407:        if line.strip().startswith("def ") and "solve(" not in line:
1408:            func_name = line.strip().split("(")[0].replace("def ", "")
1482:def _extract_solve_function_content(dana_code: str) -> str:
1489:        if "def solve(" in line:
1501:def _extract_agent_name_from_code(dana_code: str) -> str:
1510:def _extract_agent_description_from_code(dana_code: str) -> str:
1519:def _get_fallback_template() -> str:
1534:def solve(basic_agent : BasicAgent, problem : str):
1543:async def generate_agent_files_from_prompt(
1658:def _create_phase_2_prompt(prompt: str, messages: list[dict[str, Any]], agent_summary: dict[str, Any], multi_file: bool) -> str:
1715:def solve(self : {agent_class}, query: str) -> str:
1729:def search_document(package: RetrievalPackage) -> RetrievalPackage:
1736:def refine_query(package: RetrievalPackage) -> RetrievalPackage:
1741:def should_use_rag(package: RetrievalPackage) -> RetrievalPackage:
1745:def get_answer(package: RetrievalPackage) -> str:
1940:def get_multi_file_agent_generation_prompt(intentions: str, current_code: str = "", has_docs_folder: bool = False) -> str:
1976:def solve(self : RetrievalExpertAgent, query: str) -> str:
1999:def search_document(package: RetrievalPackage) -> RetrievalPackage:
2006:def refine_query(package: RetrievalPackage) -> RetrievalPackage:
2011:def should_use_rag(package: RetrievalPackage) -> RetrievalPackage:
2015:def get_answer(package: RetrievalPackage) -> str:
2147:def generate_mock_agent_code(messages, current_code=""):
2175:def solve(weather_agent : WeatherAgent, problem : str):
2187:def solve(assistant_agent : AssistantAgent, problem : str):
2203:def solve(data_agent : DataAgent, problem : str):
2219:def solve(document_agent : DocumentAgent, problem : str):
2235:def solve(email_agent : EmailAgent, problem : str):
2251:def solve(knowledge_agent : KnowledgeAgent, problem : str):
2263:def solve(custom_agent : CustomAgent, problem : str):
42:    async def create_agent_description(
121:    async def generate_agent_code(self, agent_metadata: dict[str, Any], messages: list[dict[str, Any]], prompt: str = "") -> dict[str, Any]:
184:    async def upload_knowledge_file(
284:    async def update_agent_description(self, agent_metadata: dict[str, Any], messages: list[dict[str, Any]]) -> dict[str, Any]:
304:    def get_agent_folder(self, agent_id: int) -> Path | None:
319:    def _create_agent_folder(self, agent_id: int, agent_name: str) -> Path:
327:    async def _extract_agent_requirements(self, messages: list[dict[str, Any]]) -> dict[str, Any]:
472:    def _merge_agent_requirements(self, new_requirements: dict[str, Any], existing_data: dict[str, Any]) -> dict[str, Any]:
501:    async def _generate_intelligent_response(
512:    def _is_ready_for_code_generation(self, agent_requirements: dict[str, Any], conversation_analysis: dict[str, Any]) -> bool:
523:    async def _analyze_capabilities_for_description(self, messages: list[dict[str, Any]]) -> AgentCapabilities | None:
537:    async def _store_multi_file_project(
556:    def _create_multi_file_project_object(self, multi_file_project: dict[str, Any]) -> MultiFileProject:
577:    async def _update_tools_with_rag(self, agent_folder: Path):
598:    async def _clear_rag_cache(self, agent_folder: Path):
605:    async def _regenerate_agent_with_knowledge(
710:    async def _generate_consistent_summary_with_knowledge(
821:    async def _generate_llm_summary_with_knowledge(
985:    def _format_conversation_context(self, conversation_context: list[dict[str, Any]]) -> str:
994:    def _format_existing_capabilities(self, existing_capabilities: dict[str, Any]) -> str:
1024:    def _fallback_summary_enhancement(
1046:    def _merge_capabilities_with_knowledge(self, existing_capabilities: dict[str, Any], uploaded_filename: str) -> dict[str, Any]:
1112:    def _enhance_description_with_knowledge(self, existing_description: str, filename: str, requirements: dict[str, Any]) -> str:
1129:    def _enhance_capabilities_with_knowledge(self, existing_capabilities: Any, filename: str) -> dict[str, Any]:
1133:    def _generate_knowledge_follow_up(self, filename: str, requirements: dict[str, Any]) -> str:
1138:    async def _check_ready_for_code_generation(self, conversation_context: list[dict[str, Any]], agent_metadata: dict[str, Any]) -> bool:
1154:    async def _generate_upload_response(
1198:def get_agent_manager() -> AgentManager:
62:    def generate_enhanced_function(self, func_info: FunctionInfo) -> str:
83:    def generate_perceive(self, func_info: FunctionInfo) -> CodeBlock:
94:    def generate_operate(self, func_info: FunctionInfo) -> CodeBlock:
105:    def generate_enforce(self, func_info: FunctionInfo) -> CodeBlock:
116:    def generate_train(self, func_info: FunctionInfo) -> CodeBlock | None:
133:    def _generate_perceive(self, func_info: FunctionInfo) -> CodeBlock:
138:    def _generate_operate(self, func_info: FunctionInfo) -> CodeBlock:
143:    def _generate_enforce(self, func_info: FunctionInfo) -> CodeBlock:
147:    def _generate_train(self, func_info: FunctionInfo) -> CodeBlock | None:
151:    def _merge_code_blocks(self, parent: CodeBlock | None, child: CodeBlock | None, phase: str) -> CodeBlock:
184:    def _generate_orchestrator(
216:def enhanced_{func_info.name}{signature}:
295:    def _indent_code(self, code: str, spaces: int) -> str:
300:    def _extract_parameter_names(self, signature: str) -> list[str]:
329:    def _generate_perceive(self, func_info: FunctionInfo) -> CodeBlock:
341:    def _generate_operate(self, func_info: FunctionInfo) -> CodeBlock:
370:    def _generate_enforce(self, func_info: FunctionInfo) -> CodeBlock:
14:def poet(
37:        def diagnose(symptoms: list) -> dict:
49:        def assess_credit_risk(score: int) -> str:
86:    def dana_decorator(original_func: Any) -> Any:
92:        def poet_enhanced_function(*args, **kwargs):
249:def extract_poet_metadata(func: Any) -> dict[str, Any]:
31:    def dict(self) -> dict[str, Any]:
49:    def from_dict(cls, data: builtins.dict[str, Any]) -> "POETConfig":
63:    def from_response(cls, response_data: dict[str, Any]) -> "TranspiledFunction":
92:    def poet(self) -> dict[str, Any]:
197:    def unwrap(self) -> Any:
201:    def raw(self) -> Any:
21:def create_workflow_metadata(
42:        def ingest_document(file_path):
47:        def perform_ocr(document):
61:def create_pipeline_metadata(
104:def with_workflow_metadata(workflow_id: str | None = None, description: str | None = None, version: str = "1.0.0") -> Callable:
119:        def document_processing_workflow(input_data):
127:    def decorator(pipeline_func: Callable) -> Callable:
139:def auto_workflow_metadata(func: Callable) -> Callable:
156:        def ingest_document(file_path):
174:def build_workflow_metadata(*args, **kwargs) -> dict[str, Any]:
35:    def to_dict(self) -> dict[str, Any]:
66:    def extract_function_metadata(self, func: Callable) -> FunctionMetadata:
97:    def _extract_description_from_docstring(self, func: Callable) -> str:
123:    def _extract_poet_config(self, func: Callable) -> dict[str, Any]:
151:    def _extract_additional_params(self, poet_config: dict[str, Any]) -> dict[str, Any]:
185:def extract_workflow_metadata(
219:def extract_pipeline_metadata(pipeline_func: Callable) -> dict[str, Any]:
244:def _extract_functions_from_pipeline(pipeline_func: Callable) -> list[Callable]:
280:def with_metadata(func: Callable, **metadata) -> Callable:
295:def workflow_step(
312:    def decorator(func: Callable) -> Callable:
329:def _extract_first_line_docstring(func: Callable) -> str:
19:    def generate_dana_wrapper(self, function_name: str, config: POETConfig) -> str:
36:def poet_wrapper_{function_name}(*args, **kwargs):
85:    def enhance_function_definition(self, original_function_code: str, config: POETConfig) -> str:
29:    def enforce(self, output: Any, context: dict[str, Any], expected_type: type | None = None) -> Any:
55:    def _validate_output(self, output: Any, expected_type: type | None = None) -> None:
66:    def _enforce_domain_rules(self, output: Any, context: dict[str, Any]) -> None:
11:def financial_services(**kwargs) -> dict[str, Any]:
59:def healthcare(**kwargs) -> dict[str, Any]:
106:def retail_ecommerce(**kwargs) -> dict[str, Any]:
153:def data_processing(**kwargs) -> dict[str, Any]:
200:def security(**kwargs) -> dict[str, Any]:
248:def quick_setup(domain: str, **kwargs) -> dict[str, Any]:
274:def poet_for_domain(domain: str, **kwargs):
41:    def debug_perceive(self, *args, **kwargs) -> dict[str, Any]:
70:    def debug_operate(self, *args, **kwargs) -> dict[str, Any]:
106:    def debug_enforce(self, operation_result: Any) -> dict[str, Any]:
138:    def debug_train(self, operation_result: Any) -> dict[str, Any]:
165:    def debug_full_execution(self, *args, **kwargs) -> dict[str, Any]:
197:def debug_poet_function(func: Callable, config: POETConfig, *args, **kwargs) -> dict[str, Any]:
214:def test_poet_function(func: Callable, test_cases: list[dict[str, Any]], config: POETConfig | None = None) -> dict[str, Any]:
263:def performance_benchmark(func: Callable, iterations: int = 100, *args, **kwargs) -> dict[str, Any]:
30:    def operate(self, func: Callable, args: tuple[Any, ...], kwargs: dict[str, Any], context: dict[str, Any]) -> Any:
29:    def perceive(self, args: tuple[Any, ...], kwargs: dict[str, Any]) -> tuple[tuple[Any, ...], dict[str, Any], dict[str, Any]]:
60:    def _validate_inputs(self, args: tuple[Any, ...], kwargs: dict[str, Any]) -> None:
72:    def _process_domain_inputs(self, args: tuple[Any, ...], kwargs: dict[str, Any], context: dict[str, Any]) -> None:
29:    def train(
74:    def _track_performance(self, training_data: dict[str, Any], execution_time: float) -> None:
83:    def _domain_learning(
98:    def _basic_pattern_recognition(self, training_data: dict[str, Any], input_args: tuple[Any, ...], output: Any) -> None:
110:    def _financial_learning(self, training_data: dict[str, Any], input_args: tuple[Any, ...], output: Any) -> None:
118:    def _healthcare_learning(self, training_data: dict[str, Any], input_args: tuple[Any, ...], output: Any) -> None:
126:    def _data_processing_learning(self, training_data: dict[str, Any], input_args: tuple[Any, ...], output: Any) -> None:
22:    def register_ko_type(self, name: str, ko_class: type) -> None:
35:    def register_ko_config(self, name: str, config: dict[str, Any]) -> None:
45:    def get_ko_type(self, name: str) -> type:
63:    def get_ko_config(self, name: str) -> dict[str, Any]:
81:    def list_ko_types(self) -> list[str]:
89:    def list_ko_configs(self) -> list[str]:
97:    def create_ko_instance(self, name: str, **kwargs) -> Any:
98:    def load_document(self, source: str) -> Document:
103:    def validate_document(self, document: Document) -> bool:
112:    def process(self, input_data: Any) -> Any:
117:    def validate_input(self, input_data: Any) -> bool:
126:    def extract_knowledge(self, document: Document) -> list[KnowledgePoint]:
131:    def validate_knowledge(self, knowledge: KnowledgePoint) -> ValidationResult:
13:def _get_context_manager() -> ContextManager:
25:def _parse_context_type(context_type_str: str) -> ContextType:
58:def context_set(context_type: str, key: str, value: Any) -> bool:
78:def context_get(context_type: str, key: str, default: Any = None) -> Any:
97:def context_has(context_type: str, key: str) -> bool:
115:def context_remove(context_type: str, key: str) -> bool:
133:def context_clear(context_type: str) -> bool:
151:def context_clear_all() -> bool:
165:def context_sync(source_type: str, target_type: str, keys: list[str] | None = None) -> bool:
186:def context_keys(context_type: str) -> list[str]:
204:def context_size(context_type: str) -> int:
222:def context_info(context_type: str) -> dict[str, Any]:
239:def context_snapshot(context_type: str) -> dict[str, Any]:
256:def context_restore(context_type: str, snapshot: dict[str, Any]) -> bool:
275:def context_types() -> list[str]:
289:def context_metrics() -> dict[str, Any]:
305:def context_merge(source_type: str, target_type: str) -> bool:
318:def context_copy(source_type: str, target_type: str, keys: list[str]) -> bool:
332:def context_exists(context_type: str) -> bool:
350:def context_is_empty(context_type: str) -> bool:
365:def to_context_dict(context_type: str) -> dict[str, Any]:
383:def from_context_dict(context_type: str, data: dict[str, Any]) -> bool:
407:def context_validate_key(key: str) -> bool:
424:def context_validate_value(value: Any) -> bool:
444:def context_configure(settings_dict: dict[str, Any]) -> bool:
462:def context_reset() -> bool:
33:    def get_context(self, context_type: ContextType) -> Context:
51:    def set_context_value(self, context_type: ContextType, key: str, value: Any) -> None:
71:    def get_context_value(self, context_type: ContextType, key: str, default: Any = None) -> Any:
85:    def has_context_value(self, context_type: ContextType, key: str) -> bool:
98:    def remove_context_value(self, context_type: ContextType, key: str) -> bool:
116:    def clear_context(self, context_type: ContextType) -> None:
127:    def clear_all_contexts(self) -> None:
134:    def sync_contexts(self, source_type: ContextType, target_type: ContextType, keys: list[str] | None = None) -> None:
167:    def get_context_snapshot(self, context_type: ContextType) -> dict[str, Any]:
179:    def restore_context_snapshot(self, context_type: ContextType, snapshot: dict[str, Any]) -> None:
201:    def get_all_context_types(self) -> list[ContextType]:
210:    def get_context_info(self, context_type: ContextType) -> dict[str, Any]:
228:    def get_metrics(self) -> dict[str, Any]:
242:    def _validate_key(self, key: str) -> None:
257:    def _validate_value(self, value: Any) -> None:
277:    def _invalidate_cache(self, context_type: ContextType) -> None:
287:    def _cleanup_expired_cache(self) -> None:
48:    def set(self, key: str, value: Any) -> None:
64:    def get(self, key: str, default: Any = None) -> Any:
76:    def has(self, key: str) -> bool:
87:    def remove(self, key: str) -> bool:
102:    def clear(self) -> None:
107:    def keys(self) -> list[str]:
115:    def values(self) -> list[Any]:
123:    def items(self) -> list[tuple[str, Any]]:
131:    def size(self) -> int:
139:    def copy(self) -> "Context":
151:    def merge(self, other: "Context") -> None:
166:    def to_dict(self) -> dict[str, Any]:
180:    def from_dict(cls, data: dict[str, Any]) -> "Context":
25:def create_store(store_type: str, settings: dict[str, Any]) -> None:
56:def store_value(key: str, value: Any, store_type: str) -> None:
77:def retrieve_value(key: str, store_type: str) -> Any | None:
100:def delete_value(key: str, store_type: str) -> None:
120:def query_values(store_type: str, **kwargs) -> list[Any]:
143:def close_stores() -> None:
154:def get_store_types() -> dict[str, str]:
168:def get_active_stores() -> list[str]:
178:def convert_dana_to_python(value: Any) -> Any:
196:def convert_python_to_dana(value: Any) -> Any:
28:    def _create_connection(self) -> psycopg2.extensions.connection:
49:    def _ensure_extension(self) -> None:
62:    def _ensure_table(self) -> None:
82:    def _parse_vector(self, vector_data) -> list[float]:
100:    def _validate_key(self, key: str) -> None:
122:    def store(self, key: str, value: Any) -> None:
164:    def retrieve(self, key: str) -> dict[str, Any] | None:
195:    def delete(self, key: str) -> None:
220:    def query(self, **kwargs) -> list[Any]:
271:    def close(self) -> None:
27:    def _create_connection(self) -> psycopg2.extensions.connection:
48:    def _ensure_extension(self) -> None:
61:    def _ensure_table(self) -> None:
91:    def _validate_key(self, key: str) -> None:
113:    def store(self, key: str, value: Any) -> None:
160:    def retrieve(self, key: str, start_time: str | datetime | None = None, end_time: str | datetime | None = None) -> list[dict[str, Any]]:
209:    def delete(self, key: str) -> None:
234:    def query(self, **kwargs) -> list[Any]:
302:    def close(self) -> None:
25:    def _create_connection(self) -> psycopg2.extensions.connection:
46:    def _ensure_default_tables(self) -> None:
69:    def _ensure_table(self, table_name: str) -> None:
92:    def _validate_key(self, key: str) -> None:
115:    def store(self, key: str, value: Any) -> None:
154:    def retrieve(self, key: str) -> dict[str, Any] | None:
189:    def delete(self, key: str) -> None:
219:    def query(
267:    def close(self) -> None:
28:    def _create_client(self) -> redis.Redis:
52:    def _validate_key(self, key: str) -> None:
74:    def store(self, key: str, value: Any) -> None:
103:    def retrieve(self, key: str) -> Any | None:
131:    def delete(self, key: str) -> None:
156:    def query(self, pattern: str) -> list[Any]:
188:    def close(self) -> None:
12:    def store(self, key: str, value: Any) -> None:
16:    def retrieve(self, key: str) -> Any | None:
20:    def delete(self, key: str) -> None:
24:    def query(self, **kwargs) -> list[Any]:
30:    def process(self, parsed_doc: ParsedDocument) -> str:
69:    def validate_input(self, parsed_doc: ParsedDocument) -> bool:
92:    def _extract_from_text_document(self, parsed_doc: ParsedDocument) -> str:
149:    def _extract_from_json_document(self, parsed_doc: ParsedDocument) -> str:
182:    def _extract_from_csv_document(self, parsed_doc: ParsedDocument) -> str:
229:    def _extract_generic_text(self, parsed_doc: ParsedDocument) -> str:
253:    def _json_to_text(self, data: Any, indent: int = 0) -> list[str]:
285:    def _clean_text(self, text: str) -> str:
305:    def _format_metadata(self, metadata: dict[str, Any]) -> str:
22:    def process(self, document: Document) -> ParsedDocument:
63:    def validate_input(self, document: Document) -> bool:
86:    def _parse_text_document(self, document: Document) -> dict[str, Any]:
134:    def _parse_json_document(self, document: Document) -> dict[str, Any]:
164:    def _parse_csv_document(self, document: Document) -> dict[str, Any]:
197:    def _parse_generic_document(self, document: Document) -> dict[str, Any]:
221:    def _analyze_json_schema(self, data: Any, path: str = "") -> dict[str, Any]:
31:    def load_document(self, source: str) -> Document:
81:    def load_documents(self, sources: list[str]) -> list[Document]:
108:    def validate_document(self, document: Document) -> bool:
143:    def _load_content(self, source: str, format_ext: str) -> str:
164:    def _load_text_file(self, source: str) -> str:
169:    def _load_json_file(self, source: str) -> str:
175:    def _load_csv_file(self, source: str) -> str:
180:    def _load_pdf_file(self, source: str) -> str:
239:    def _generate_document_id(self, source: str) -> str:
68:    def process(self, knowledge_points: list[KnowledgePoint]) -> dict[str, Any]:
118:    def validate_input(self, knowledge_points: list[KnowledgePoint]) -> bool:
142:    def search_similar(self, query_point: KnowledgePoint, candidate_points: list[KnowledgePoint] | None = None) -> SimilarityResult:
195:    def _build_knowledge_index(self, knowledge_points: list[KnowledgePoint]) -> None:
204:    def _generate_content_vectors(self, knowledge_points: list[KnowledgePoint]) -> None:
216:    def _generate_content_vector(self, content: str) -> np.ndarray:
272:    def _calculate_vector_similarity(self, vector1: np.ndarray, vector2: np.ndarray) -> float:
300:    def _identify_matching_features(self, kp1: KnowledgePoint, kp2: KnowledgePoint) -> list[str]:
340:    def _find_similarities(self, knowledge_points: list[KnowledgePoint]) -> list[dict[str, Any]]:
378:    def _create_semantic_matches(self, similarity_mappings: list[dict[str, Any]]) -> list[SemanticMatch]:
406:    def _determine_match_type(self, matching_features: list[str]) -> str:
429:    def _generate_similarity_clusters(self, semantic_matches: list[SemanticMatch]) -> list[dict[str, Any]]:
465:    def _find_connected_points(self, start_id: str, semantic_matches: list[SemanticMatch]) -> set:
491:    def _calculate_cluster_similarity(self, cluster_ids: list[str], semantic_matches: list[SemanticMatch]) -> float:
508:    def _get_dominant_match_type(self, cluster_ids: list[str], semantic_matches: list[SemanticMatch]) -> str:
531:    def _calculate_search_confidence(self, similarities: list[dict[str, Any]]) -> float:
552:    def _get_vector_dimensions(self) -> int:
150:    def process(self, knowledge_points: list[KnowledgePoint]) -> dict[str, Any]:
204:    def validate_input(self, knowledge_points: list[KnowledgePoint]) -> bool:
228:    def expand_context(self, knowledge_point: KnowledgePoint) -> list[ContextExpansion]:
271:    def validate_context(self, knowledge_point: KnowledgePoint) -> ContextValidation:
310:    def _parse_expansion_response(self, response: BaseResponse, source_id: str) -> list[ContextExpansion]:
363:    def _parse_validation_response(self, response: BaseResponse, context_id: str) -> ContextValidation:
434:    def _rule_based_expansion(self, knowledge_point: KnowledgePoint) -> list[ContextExpansion]:
501:    def _rule_based_validation(self, knowledge_point: KnowledgePoint) -> ContextValidation:
562:    def _assess_response_quality(self, expansion_data: dict[str, Any]) -> float:
593:    def _create_context_relationships(
641:    def _generate_context_summary(self, expansions: list[ContextExpansion], validations: list[ContextValidation]) -> dict[str, Any]:
675:    def _calculate_average_confidence(self, expansions: list[ContextExpansion]) -> float:
689:    def _calculate_average_validation_score(self, validations: list[ContextValidation]) -> float:
703:    def _calculate_validation_pass_rate(self, validations: list[ContextValidation]) -> float:
718:    def _get_common_issues(self, validations: list[ContextValidation]) -> list[str]:
41:    def process(self, document: Document) -> list[KnowledgePoint]:
77:    def validate_input(self, document: Document) -> bool:
99:    def _extract_with_llm(self, document: Document) -> list[KnowledgePoint]:
146:    def _build_extraction_prompt(self, document: Document) -> str:
191:    def _extract_response_text(self, response_content: Any) -> str:
258:    def _parse_llm_response(self, response: str, document: Document) -> list[KnowledgePoint]:
310:    def _create_knowledge_point(self, data: dict[str, Any], document: Document) -> KnowledgePoint | None:
357:    def _fallback_extraction(self, document: Document) -> list[KnowledgePoint]:
400:    def _is_potentially_important(self, sentence: str) -> bool:
442:    def _generate_knowledge_point_id(self) -> str:
450:    def _get_timestamp(self) -> str:
108:    def process(self, knowledge_points: list[KnowledgePoint]) -> dict[str, Any]:
166:    def validate_input(self, knowledge_points: list[KnowledgePoint]) -> bool:
190:    def _categorize_knowledge_point(self, knowledge_point: KnowledgePoint) -> list[dict[str, Any]]:
245:    def _calculate_keyword_similarity(self, text: str, keywords: list[str]) -> float:
272:    def _determine_relationship_type(self, similarity_score: float) -> str:
288:    def _map_knowledge_point_relationships(self, knowledge_points: list[KnowledgePoint]) -> list[dict[str, Any]]:
329:    def _calculate_content_similarity(self, content1: str, content2: str) -> float:
351:    def _have_contextual_relationship(self, kp1: KnowledgePoint, kp2: KnowledgePoint) -> bool:
378:    def _find_shared_context(self, kp1: KnowledgePoint, kp2: KnowledgePoint) -> dict[str, Any]:
398:    def _build_category_hierarchy(self) -> dict[str, Any]:
422:    def _generate_categorization_summary(
15:    def extract_text(self, content: str) -> str:
19:    def extract_metadata(self, content: str) -> dict[str, Any]:
15:    def parse(self, content: str) -> dict[str, Any]:
19:    def parse_batch(self, contents: list[str]) -> list[dict[str, Any]]:
15:    def load(self, source: str) -> str:
20:    def load_batch(self, sources: list[str]) -> list[str]:
91:    def execute(self, input_data: Any, context: Any = None) -> Any:
131:    def _create_step_context(self, input_data: Any, context: Any = None) -> StepExecutionContext:
156:    def _validate_pre_conditions(self, input_data: Any, context: StepExecutionContext) -> None:
166:    def _validate_post_conditions(self, result: Any, context: StepExecutionContext) -> None:
176:    def _execute_function(self, input_data: Any, context: StepExecutionContext) -> Any:
180:        def _timeout_handler(signum, frame):
217:        def composed_function(input_data: Any) -> Any:
232:    def clone(self, **overrides) -> "WorkflowStep":
255:    def from_function(
279:        def decorator(func: Callable) -> "WorkflowStep":
39:    def add_context(self, key: str, value: Any) -> None:
43:    def get_context(self, key: str, default: Any = None) -> Any:
72:    def execute(
132:    def _validate_workflow(self, workflow: Any) -> None:
140:    def _execute_step_list(self, steps: list[WorkflowStep], input_data: Any, context: WorkflowExecutionContext) -> Any:
177:    def _execute_composed_function(self, composed_func: Callable, input_data: Any, context: WorkflowExecutionContext) -> Any:
189:    def _post_execution_processing(self, context: WorkflowExecutionContext, result: Any) -> None:
201:    def _handle_execution_error(self, context: WorkflowExecutionContext, error: Exception) -> None:
220:    def create_workflow_step(
65:    def validate_workflow(self, workflow: Any, context: Any = None) -> SafetyResult:
103:    def validate_step(self, step: Any, context: Any = None) -> SafetyResult:
169:    def add_validation_rule(self, name: str, rule: Callable) -> None:
180:    def remove_validation_rule(self, name: str) -> bool:
196:    def _register_default_rules(self) -> None:
203:    def _validate_step_list(self, steps: list, context: Any = None) -> SafetyResult:
249:    def _validate_composed_function(self, func: Callable, context: Any = None) -> SafetyResult:
285:    def _validate_function(self, func: Callable, name: str) -> SafetyResult:
316:    def _check_dangerous_operations(self, func: Callable, name: str) -> SafetyResult:
355:    def _is_workflow_list(self, workflow: Any) -> bool:
359:    def _rule_basic_structure(self, workflow: Any, context: Any = None) -> SafetyResult:
368:    def _rule_no_infinite_recursion(self, workflow: Any, context: Any = None) -> SafetyResult:
382:    def _rule_reasonable_complexity(self, workflow: Any, context: Any = None) -> SafetyResult:
400:    def get_validation_summary(self) -> dict[str, Any]:
72:    def add_knowledge(self, content: str, source: str, tags: list[str] | None = None, metadata: dict[str, Any] | None = None) -> str:
106:    def get_knowledge(self, knowledge_id: str) -> KnowledgePoint | None:
118:    def find_by_tag(self, tag: str) -> list[KnowledgePoint]:
131:    def search_knowledge(
166:    def create_context_snapshot(self, metadata: dict[str, Any] | None = None) -> str:
186:    def get_context_snapshot(self, snapshot_id: str) -> ContextSnapshot | None:
198:    def clear_knowledge(self, source: str | None = None) -> int:
231:    def get_stats(self) -> dict[str, Any]:
250:    def _enforce_limit(self) -> None:
264:    def export_knowledge(self, source: str | None = None) -> dict[str, Any]:
291:    def import_knowledge(self, data: dict[str, Any]) -> int:
40:    def search(self, query: str, candidates: list[str]) -> SimilarityResult:
50:    def validate_input(self, knowledge_points: list[Any]) -> bool:
36:    def expand(self, context: dict[str, Any], knowledge_base: list[Any]) -> ContextExpansion:
41:    def validate(self, context: dict[str, Any]) -> ContextValidation:
15:    def extract(self, content: str) -> dict[str, Any]:
20:    def extract_batch(self, contents: list[str]) -> list[dict[str, Any]]:
34:    def categorize(self, content: str) -> list[KnowledgeCategory]:
39:    def find_relationships(self, categories: list[KnowledgeCategory]) -> list[CategoryRelationship]:
15:    def search(self, query: str, candidates: list[str]) -> list[str]:
20:    def rank(self, query: str, candidates: list[str]) -> list[tuple[str, float]]:
34:    def expand(self, context: str, knowledge_base: list[str]) -> list[str]:
44:    def to_dict(self) -> dict[str, any]:
62:def create_dana_exception(exc: Exception, error_context=None) -> DanaException:
42:    def find_spec(self, fullname: str, path: Sequence[str | bytes] | None = None, target: Module | None = None) -> PyModuleSpec | None:
67:    def _find_spec_with_context(self, fullname: str, importing_module_path: str | None = None) -> PyModuleSpec | None:
300:    def _setup_package_attributes(self, spec: ModuleSpec) -> None:
333:    def create_module(self, spec: PyModuleSpec) -> Module | None:
375:    def exec_module(self, module: Module) -> None:
473:    def _setup_module_function_context(self, module: Module, interpreter: DanaInterpreter, context: SandboxContext) -> None:
516:    def _find_module_in_directory(self, module_name: str, directory: Path) -> Path | None:
538:    def _find_module_file(self, module_name: str) -> Path | None:
75:def show_help():
98:def execute_file(file_path, debug=False):
147:async def start_repl(debug=False):
168:def handle_start_command(args):
214:def handle_init_command(args):
251:    def greet(self, name):
309:def handle_new_command(args):
324:    def process(self, data):
330:    def analyze(self, input_data):
359:def handle_serve_command(args):
389:def main():
525:def handle_main_command():
571:def handle_deploy_command(args):
598:def handle_config_command(args):
627:def deploy_thru_mcp(file_path, args):
644:def deploy_thru_a2a(file_path, args):
657:def configure_debug_logging():
664:def validate_na_file(file_path):
114:    def run_configuration_wizard(self) -> bool:
160:    def _select_providers(self) -> list[str]:
210:    def _configure_provider(self, provider_key: str) -> dict[str, str] | None:
262:    def _write_env_file(self, env_vars: dict[str, str]):
299:    def validate_configuration(self) -> bool:
355:    def _load_env_file(self):
11:def validate_agent_module(na_file_path: str, na_module):
59:def make_agent_class(agent_name: str, agent_description: str, entry_func: Callable):
77:        def solve_query(self, query: str) -> str:
85:        def handle_task(self, task):
103:def color_text(text, color_code):
107:def print_a2a_server_banner(host, port, agent_name, agent_description):
129:def deploy_dana_agents_thru_a2a(na_file_path, host, port):
8:def validate_agent_module(na_file_path: str, na_module):
48:def create_mcp_server_for_file(na_file_path):
68:        def solve(query: str) -> str:
84:def color_text(text, color_code):
88:def print_mcp_server_banner(host, port, agent_name):
110:def deploy_dana_agents_thru_mcp(na_file_path, host, port):
142:    async def lifespan(app: FastAPI):
52:    def detect_assignment_context(self, assignment_node: Assignment) -> TypeContext | None:
84:    def detect_function_call_context(self, func_call_node: FunctionCall) -> TypeContext | None:
143:    def detect_function_parameter_context(self, param_name: str, param_type: str) -> TypeContext:
163:    def detect_conditional_context(self, condition_node: Any) -> TypeContext:
182:    def infer_context_from_usage(self, variable_name: str, usage_context: str) -> TypeContext | None:
215:    def get_cached_context(self, cache_key: str) -> TypeContext | None:
226:    def cache_context(self, cache_key: str, context: TypeContext) -> None:
236:    def clear_cache(self) -> None:
241:    def get_cache_size(self) -> int:
245:    def detect_current_context(self, context: Any) -> TypeContext | None:
293:    def _infer_from_execution_context(self, context: Any) -> TypeContext | None:
346:    def analyze_assignment_chain(self, assignments: list[Assignment]) -> list[TypeContext]:
365:    def find_strongest_context(self, contexts: list[TypeContext]) -> TypeContext | None:
381:    def merge_contexts(self, contexts: list[TypeContext]) -> TypeContext | None:
431:def detect_assignment_context(assignment_node: Assignment) -> TypeContext | None:
437:def detect_conditional_context(condition_node: Any) -> TypeContext:
443:def analyze_contexts(assignments: list[Assignment]) -> list[TypeContext]:
55:    def push_location(self, location: ExecutionLocation) -> None:
60:    def pop_location(self) -> ExecutionLocation | None:
68:    def set_file(self, filename: str | Path) -> None:
73:    def load_source(self, filename: str) -> list[str] | None:
87:    def get_source_line(self, filename: str, line_num: int) -> str | None:
94:    def format_stack_trace(self) -> str:
48:def _patched_format_user_error(e, user_input=None):
87:    def _init_function_registry(self):
108:    def function_registry(self) -> FunctionRegistry:
122:    def _run(self, file_path: str | Path, source_code: str, context: SandboxContext) -> Any:
136:    def _eval(self, source_code: str, context: SandboxContext, filename: str | None = None) -> Any:
155:    def _execute(self, ast: Program, context: SandboxContext) -> Any:
192:    def evaluate_expression(self, expression: Any, context: SandboxContext) -> Any:
204:    def execute_program(self, program: Program, context: SandboxContext) -> Any:
217:    def execute_statement(self, statement: Any, context: SandboxContext) -> Any:
230:    def get_and_clear_output(self) -> str:
234:    def get_evaluated(self, key: str, context: SandboxContext) -> Any:
250:    def call_function(
278:    def evaluate_ast(self, ast: Program, context: SandboxContext) -> Any:
294:    def _process_function_definition(self, func_def: FunctionDefinition, context: SandboxContext) -> None:
325:    def _create_dana_function(self, func_def: FunctionDefinition, context: SandboxContext, register: bool = True):
339:        def dana_function(*args, **kwargs):
362:    def _bind_function_parameters(self, parameters: list, args: tuple, kwargs: dict, context: SandboxContext) -> None:
376:    def _register_function_normally(self, func_def: FunctionDefinition, context: SandboxContext) -> None:
381:    def is_repl_mode(self) -> bool:
18:    def format_error(error: Exception, error_context: ErrorContext | None = None, show_traceback: bool = True) -> str:
86:    def format_developer_error(error: Exception, error_context: ErrorContext | None = None, show_traceback: bool = True) -> str:
164:    def format_simple_error(error: Exception, filename: str | None = None) -> str:
36:    def _build_boolean_patterns(self) -> dict[str, bool]:
87:    def _build_numeric_patterns(self) -> dict[str, re.Pattern]:
97:    def coerce_to_bool(self, value: Any, context: str | None = None) -> bool:
126:    def _coerce_string_to_bool(self, text: str) -> bool:
160:    def _is_zero_equivalent(self, text: str) -> bool:
165:    def _is_positive_numeric(self, text: str) -> bool:
173:    def _apply_contextual_boolean_logic(self, text: str) -> bool | None:
192:    def coerce_value(self, value: Any, target_type: str, context: str | None = None) -> Any:
237:    def _coerce_to_dict(self, value: Any, context: str | None = None) -> dict:
278:    def _coerce_to_list(self, value: Any, context: str | None = None) -> list:
319:    def _extract_final_answer(self, text: str) -> str:
338:    def _try_coerce_to_struct(self, value: Any, target_type: str, context: str | None = None) -> Any | None:
396:    def _coerce_string_to_struct(self, text: str, target_type: str, context: str | None = None) -> Any:
440:    def _coerce_dict_to_struct(self, data: dict, target_type: str, context: str | None = None) -> Any:
466:    def _clean_json_string(self, value: str) -> str:
487:    def test_semantic_equivalence(self, left: Any, right: Any) -> bool:
513:def coerce_value(value: Any, target_type: str, context: str | None = None) -> Any:
518:def semantic_bool(value: Any) -> bool:
523:def semantic_equals(left: Any, right: Any) -> bool:
49:    def prepare_context(self, context: SandboxContext | Any, args: list[Any], kwargs: dict[str, Any]) -> SandboxContext:
108:    def restore_context(self, context: SandboxContext, original_context: SandboxContext) -> None:
121:    def execute(self, context: Any, *args: Any, **kwargs: Any) -> Any:
56:    def prepare_context(self, context: SandboxContext, args: list[Any], kwargs: dict[str, Any]) -> SandboxContext:
73:    def restore_context(self, context: SandboxContext, original_context: SandboxContext) -> None:
86:    def execute(self, context: SandboxContext, *args: Any, **kwargs: Any) -> Any:
108:    def _resolve_function(self, func: SandboxFunction | str | Callable, context: SandboxContext) -> SandboxFunction:
167:    def _wrap_callable(self, func: callable, func_name: str, context: SandboxContext) -> SandboxFunction:
185:            def execute(self, context: SandboxContext, *args, **kwargs):
208:            def restore_context(self, context: SandboxContext, original_context: SandboxContext) -> None:
81:    def register_handlers(self):
102:    def execute_assignment(self, node: Assignment, context: SandboxContext) -> Any:
114:    def execute_compound_assignment(self, node: CompoundAssignment, context: SandboxContext) -> Any:
126:    def execute_assert_statement(self, node: AssertStatement, context: SandboxContext) -> None:
141:    def _execute_python_import(self, module_name: str, context_name: str, context: SandboxContext) -> None:
168:    def _execute_dana_import(self, module_name: str, context_name: str, context: SandboxContext) -> None:
210:    def _execute_python_from_import(self, module_name: str, names: list[tuple[str, str | None]], context: SandboxContext) -> None:
253:    def _execute_dana_from_import(self, module_name: str, names: list[tuple[str, str | None]], context: SandboxContext) -> None:
315:    def _register_imported_function(self, func: callable, context_name: str, module_name: str, original_name: str) -> None:
385:    def execute_import_statement(self, node: ImportStatement, context: SandboxContext) -> Any:
397:    def execute_import_from_statement(self, node: ImportFromStatement, context: SandboxContext) -> Any:
409:    def execute_pass_statement(self, node: PassStatement, context: SandboxContext) -> None:
421:    def execute_raise_statement(self, node: RaiseStatement, context: SandboxContext) -> None:
436:    def execute_use_statement(self, node: UseStatement, context: SandboxContext) -> Any:
448:    def execute_export_statement(self, node: ExportStatement, context: SandboxContext) -> None:
460:    def execute_struct_definition(self, node: StructDefinition, context: SandboxContext) -> None:
472:    def execute_agent_definition(self, node: AgentDefinition, context: SandboxContext) -> None:
484:    def execute_agent_statement(self, node: AgentStatement, context: SandboxContext) -> Any:
496:    def execute_agent_pool_statement(self, node: AgentPoolStatement, context: SandboxContext) -> Any:
508:    def execute_function_definition(self, node: "FunctionDefinition", context: SandboxContext) -> Any:
523:    def execute_method_definition(self, node: "MethodDefinition", context: SandboxContext) -> Any:
541:            func_def = FunctionDefinition(
551:    def execute_declarative_function_definition(self, node: "DeclarativeFunctionDefinition", context: SandboxContext) -> Any:
570:        def create_declarative_function():
571:            def wrapper(*args, **kwargs):
615:    def _bind_declarative_function_parameters(self, parameters: list, args: tuple, kwargs: dict, func_context: SandboxContext) -> None:
674:    def _execute_composition(self, composition, func_context: SandboxContext, args: tuple) -> Any:
698:    def _extract_annotations(self, parameters: list, return_type) -> dict[str, type]:
720:    def _map_dana_type_to_python(self, dana_type: str) -> type:
745:    def _create_signature(self, parameters: list, return_type):
68:    def register_handlers(self):
76:    def execute_function_definition(self, node: FunctionDefinition, context: SandboxContext) -> Any:
142:    def execute_method_definition(self, node: MethodDefinition, context: SandboxContext) -> Any:
216:    def _apply_decorators(self, func, decorators, context):
244:    def _evaluate_expression(self, expr, context):
255:    def _resolve_decorator(self, decorator, context):
287:    def _ensure_fully_evaluated(self, value: Any, context: SandboxContext) -> Any:
309:    def execute_function_call(self, node: FunctionCall, context: SandboxContext) -> Any:
517:    def _get_current_function_context(self, context: SandboxContext) -> str | None:
555:    def _assign_and_coerce_result(self, raw_result: Any, function_name: str) -> Any:
573:    def _apply_function_result_coercion(self, result: Any, function_name: str) -> Any:
604:    def _execute_user_defined_function(self, func_data: dict[str, Any], args: list[Any], context: SandboxContext) -> Any:
42:    def execute_agent_statement(self, node: AgentStatement, context: SandboxContext) -> Any:
87:    def execute_agent_pool_statement(self, node: AgentPoolStatement, context: SandboxContext) -> Any:
132:    def execute_use_statement(self, node: UseStatement, context: SandboxContext) -> Any:
169:    def execute_export_statement(self, node: ExportStatement, context: SandboxContext) -> None:
200:    def execute_struct_definition(self, node: StructDefinition, context: SandboxContext) -> None:
235:            def struct_constructor(**kwargs):
248:    def execute_agent_definition(self, node: AgentDefinition, context: SandboxContext) -> None:
273:            def agent_constructor(**kwargs):
288:    def execute_function_definition(self, node: FunctionDefinition, context: SandboxContext) -> Any:
352:    def _apply_decorators(self, func, decorators, context):
380:    def _resolve_decorator(self, decorator, context):
390:    def _trace_resource_operation(self, operation_type: str, resource_name: str, arg_count: int, kwarg_count: int) -> None:
406:    def get_stats(self) -> dict[str, Any]:
56:    def execute_import_statement(self, node: ImportStatement, context: SandboxContext) -> Any:
93:    def execute_import_from_statement(self, node: ImportFromStatement, context: SandboxContext) -> Any:
123:    def _execute_python_import(self, module_name: str, context_name: str, context: SandboxContext) -> None:
157:    def _execute_dana_import(self, module_name: str, context_name: str, context: SandboxContext) -> None:
229:    def _execute_python_from_import(self, module_name: str, names: list[tuple[str, str | None]], context: SandboxContext) -> None:
276:    def _execute_dana_from_import(self, module_name: str, names: list[tuple[str, str | None]], context: SandboxContext) -> None:
364:    def _register_imported_function(self, func: callable, context_name: str, module_name: str, original_name: str) -> None:
402:    def _ensure_module_system_initialized(self) -> None:
418:    def _create_parent_namespaces(self, context_name: str, module: Any, context: SandboxContext) -> None:
480:    def _resolve_relative_import(self, module_name: str, context: SandboxContext) -> str:
557:    def _trace_import(self, import_type: str, module_name: str, context_info: str) -> None:
572:    def clear_cache(self) -> None:
581:    def get_cache_stats(self) -> dict[str, Any]:
49:    def execute_assignment(self, node: Assignment, context: SandboxContext) -> Any:
89:    def execute_compound_assignment(self, node: CompoundAssignment, context: SandboxContext) -> Any:
167:    def _process_type_hint(self, node: Assignment, context: SandboxContext) -> type | None:
212:    def _apply_type_coercion(self, value: Any, target_type: type | str, target_node: Any) -> Any:
263:    def _execute_assignment_by_target(self, target: Any, value: Any, context: SandboxContext) -> None:
287:    def _execute_subscript_assignment(self, target: SubscriptExpression, value: Any, context: SandboxContext) -> None:
320:    def _execute_slice_assignment(self, target_obj: Any, slice_expr: Any, value: Any, context: SandboxContext) -> None:
342:    def _execute_multidim_slice_assignment(self, target_obj: Any, slice_tuple: Any, value: Any, context: SandboxContext) -> None:
376:    def _execute_attribute_assignment(self, target: AttributeAccess, value: Any, context: SandboxContext) -> None:
397:    def _get_assignment_target_name(self, target: Any) -> str:
417:    def _trace_assignment(self, target: Any, value: Any) -> None:
433:    def clear_cache(self) -> None:
438:    def get_cache_stats(self) -> dict[str, Any]:
73:    def parse_function_name(self, func_name: str) -> FunctionNameInfo:
103:    def resolve_function(self, name_info: FunctionNameInfo, context: SandboxContext, registry: Any) -> ResolvedFunction | None:
133:    def _resolve_from_context_hierarchy(self, name_info: FunctionNameInfo, context: SandboxContext) -> ResolvedFunction | None:
175:    def _create_resolved_function_from_context(self, func_data: Any, name_info: FunctionNameInfo) -> ResolvedFunction:
218:    def _resolve_from_context(self, name_info: FunctionNameInfo, context: SandboxContext) -> ResolvedFunction | None:
252:    def _resolve_from_registry(self, name_info: FunctionNameInfo, registry: Any) -> ResolvedFunction | None:
289:    def execute_resolved_function(
321:    def list_available_functions(self, namespace: str | None = None) -> list[str]:
85:    def _register_all_handlers(self):
99:    def execute(self, node: Any, context: SandboxContext) -> Any:
146:    def _execute_hook(
168:    def get_and_clear_output(self) -> str:
178:    def extract_value(self, node: Any) -> Any:
197:    def configure_optimizations(self, **kwargs) -> None:
206:    def get_optimization_statistics(self) -> dict[str, Any] | None:
216:    def log_optimization_report(self) -> None:
223:    def clear_optimization_caches(self) -> None:
228:    def is_optimization_healthy(self) -> bool:
238:    def execute_with_location_context(self, method: Callable, node: Any, context: SandboxContext) -> Any:
22:    def track_execution(self, node_description: str):
38:    def check_depth_safety(self) -> None:
51:    def get_statistics(self) -> dict[str, Any]:
62:    def reset_statistics(self) -> None:
75:    def visit_node(self, node: Any):
95:    def get_current_path(self) -> list[str]:
99:    def clear(self) -> None:
100:    def register_handlers(self):
121:    def execute_literal_expression(self, node: LiteralExpression, context: SandboxContext) -> Any:
137:    def execute_identifier(self, node: Identifier, context: SandboxContext) -> Any:
150:    def execute_binary_expression(self, node: BinaryExpression, context: SandboxContext) -> Any:
170:    def execute_unary_expression(self, node: UnaryExpression, context: SandboxContext) -> Any:
191:    def execute_tuple_literal(self, node: TupleLiteral, context: SandboxContext) -> tuple:
203:    def execute_dict_literal(self, node: DictLiteral, context: SandboxContext) -> dict:
215:    def execute_set_literal(self, node: SetLiteral, context: SandboxContext) -> set:
227:    def execute_fstring_expression(self, node: FStringExpression, context: SandboxContext) -> str:
239:    def execute_attribute_access(self, node: AttributeAccess, context: SandboxContext) -> Any:
308:    def run_function(self, func: Callable, *args, **kwargs) -> Any:
314:    def execute_object_function_call(self, node: Any, context: SandboxContext) -> Any:
428:    def execute_subscript_expression(self, node: SubscriptExpression, context: SandboxContext) -> Any:
475:    def _execute_slice(self, target: Any, slice_expr: Any, context: SandboxContext) -> Any:
507:    def _evaluate_slice_components(self, slice_expr: Any, context: SandboxContext) -> dict[str, Any]:
548:    def _validate_slice_operation(self, target: Any, components: dict[str, Any]) -> None:
576:    def _validate_sequence_slice_bounds(self, components: dict[str, Any], length: int) -> None:
609:    def _execute_validated_slice(self, target: Any, components: dict[str, Any]) -> Any:
651:    def _execute_slice_tuple(self, target: Any, slice_tuple: Any, context: SandboxContext) -> Any:
702:    def _get_safe_length(self, obj: Any) -> str:
716:    def execute_list_literal(self, node: ListLiteral, context: SandboxContext) -> list:
728:    def execute_named_pipeline_stage(self, node: NamedPipelineStage, context: SandboxContext) -> Any:
743:    def execute_placeholder_expression(self, node: PlaceholderExpression, context: SandboxContext) -> Any:
758:    def _resolve_pipeline_function(self, identifier: Identifier, context: SandboxContext) -> Any:
789:    def execute_pipeline_expression(self, node: PipelineExpression, context: SandboxContext) -> Any:
801:            def identity_function(initial_value):
807:        def composed_function(initial_value):
821:    def execute_function_call(self, node: FunctionCall, context: SandboxContext) -> Any:
843:    def _has_placeholders(self, node: FunctionCall) -> bool:
868:    def _execute_pipeline_stage(self, current_value: Any, stage: Any, context: SandboxContext) -> Any:
921:                    def error_function(value):
972:    def _execute_function_call_stage(self, current_value: Any, func_call: FunctionCall, context: SandboxContext) -> Any:
1029:    def _contains_placeholder(self, expr: Any) -> bool:
52:    def execute_try_block(self, node: TryBlock, context: SandboxContext) -> Any:
162:    def _execute_statement_list(self, statements: list[Any], context: SandboxContext) -> Any:
187:    def _add_exception_trace(self, block_type: str, exception_type: str, action: str) -> None:
208:    def clear_cache(self) -> None:
215:    def get_performance_stats(self) -> dict[str, Any]:
232:    def get_exception_traces(self) -> list[dict[str, Any]]:
240:    def _matches_exception(self, exception: Exception, except_block: ExceptBlock, context: SandboxContext) -> bool:
51:    def resolve_identifier(self, node: Identifier, context: SandboxContext) -> Any:
125:    def _try_direct_context_lookup(self, name: str, context: SandboxContext) -> Any | None:
136:    def _try_cross_scope_search(self, name: str, context: SandboxContext) -> Any | None:
151:    def _try_scoped_resolution(self, name: str, context: SandboxContext) -> Any | None:
163:    def _resolve_colon_notation(self, name: str, context: SandboxContext) -> Any | None:
190:    def _resolve_dot_notation(self, name: str, context: SandboxContext) -> Any | None:
218:    def _try_fallback_scope_search(self, var_name: str, specified_scope: str, context: SandboxContext) -> Any | None:
231:    def _resolve_scoped_attribute_access(self, var_name: str, scope_name: str, context: SandboxContext) -> Any | None:
255:    def _access_attribute_path(self, base_value: Any, attribute_path: str) -> Any:
262:    def _try_function_registry_resolution(self, name: str, context: SandboxContext) -> Any | None:
310:    def _create_registry_wrapper(self, name: str, resolved_func: Any, context: SandboxContext) -> Any:
313:        def registry_function(*args, **kwargs):
324:    def _try_dotted_attribute_access(self, name: str, context: SandboxContext) -> Any | None:
364:    def _try_struct_type_resolution(self, name: str) -> Any | None:
389:    def _cache_result(self, cache_key: tuple, result: Any) -> None:
399:    def clear_cache(self) -> None:
406:    def get_cache_stats(self) -> dict[str, int | float]:
41:    def execute(self, context: SandboxContext, *args, **kwargs) -> list[Any]:
61:    def restore_context(self, context: SandboxContext, original_context: SandboxContext) -> None:
66:    def _call_function(self, func: Any, context: SandboxContext, *args, **kwargs) -> Any:
113:    def execute(self, context: SandboxContext, *args, **kwargs) -> Any:
136:    def restore_context(self, context: SandboxContext, original_context: SandboxContext) -> None:
153:    def execute_pipe(self, left: Any, right: Any, context: SandboxContext) -> Any:
184:    def _unwrap_named_stage(self, expr: Any) -> Any:
201:    def _has_named_stages(self, expr: Any) -> bool:
216:    def _create_pipeline_expression(self, left: Any, right: Any) -> BinaryExpression:
233:    def _resolve_to_function(self, expr: Any, context: SandboxContext) -> Any:
272:    def _resolve_function_call(self, func_call: FunctionCall, context: SandboxContext) -> Any:
310:    def _resolve_list_literal(self, list_literal: ListLiteral, context: SandboxContext) -> Any:
322:    def _create_partial_function(self, func: Any, func_call: FunctionCall, context: SandboxContext) -> Any:
340:            def prepare_context(self, context: SandboxContext, args: list, kwargs: dict) -> SandboxContext:
344:            def restore_context(self, context: SandboxContext, original_context: SandboxContext) -> None:
348:            def execute(self, context: SandboxContext, pipeline_value: Any) -> Any:
390:    def _resolve_identifier(self, identifier: Identifier, context: SandboxContext) -> Any:
31:    def execute_binary_expression(self, node: BinaryExpression, context: SandboxContext) -> Any:
100:    def _apply_binary_coercion(self, left: Any, right: Any, operator: str) -> tuple:
118:    def _extract_value(self, raw_value: Any) -> Any:
124:    def clear_cache(self) -> None:
130:    def get_cache_stats(self) -> dict[str, Any]:
34:    def execute_pipeline(self, pipeline_expr: BinaryExpression, context: SandboxContext, *args, **kwargs) -> Any:
52:    def _extract_pipeline_stages(self, pipeline_expr: BinaryExpression) -> list[NamedPipelineStage]:
81:    def _execute_pipeline_stages(self, stages: list[NamedPipelineStage], context: SandboxContext, *args, **kwargs) -> Any:
109:    def _execute_single_stage(
140:    def _execute_function_call_stage(
187:    def _execute_identifier_stage(
209:    def _resolve_argument(self, arg_expr: Any, current_value: Any, pipeline_context: dict[str, Any], context: SandboxContext) -> Any:
248:    def _resolve_function(self, func_name: Any, context: SandboxContext) -> Any:
284:    def _contains_placeholder_or_named_variable(self, args: list[Any], pipeline_context: dict[str, Any]) -> bool:
301:    def _call_function(self, func: Any, context: SandboxContext, *args, **kwargs) -> Any:
63:    def _initialize_resolvers(self) -> None:
78:    def resolve_function(self, name_info: FunctionNameInfo, context: SandboxContext) -> ResolvedFunction:
145:    def execute_function(
181:    def _execute_registry_function(
197:    def _execute_dana_function(
209:    def _execute_python_function(
221:    def _execute_callable_function(
233:    def _assign_and_coerce_result(self, raw_result: Any, func_name: str) -> Any:
242:    def get_resolution_history(self) -> list[ResolutionAttempt]:
250:    def get_stats(self) -> dict[str, Any]:
258:    def clear_history(self) -> None:
262:    def _raise_function_not_found_error(self, name_info: FunctionNameInfo, attempts: list[ResolutionAttempt]) -> None:
38:    def handle_function_call_error(self, error: Exception, node: FunctionCall, context: Any) -> Any:
64:    def _is_positional_argument_error(self, error: Exception) -> bool:
77:    def _handle_registry_error(self, error: FunctionRegistryError, node: FunctionCall) -> Any:
89:    def _convert_to_user_friendly_name(self, function_name: str) -> str:
108:    def format_error_message(self, error: Exception, function_name: str, context: str = "") -> str:
127:    def handle_registry_execution_error(
171:    def _create_enhanced_sandbox_error(self, error: Exception, node: FunctionCall, func_name: str) -> SandboxError:
204:    def attempt_recovery(self, error: Exception, node: FunctionCall, context: Any) -> Any:
233:    def _try_keyword_conversion(self, node: FunctionCall, context: Any) -> Any:
263:    def _try_reduced_args(self, node: FunctionCall, context: Any) -> Any:
292:    def get_recovery_suggestions(self, error: Exception, function_name: str) -> list[str]:
322:    def can_handle(self, error: Exception, evaluated_kwargs: dict[str, Any]) -> bool:
334:    def _is_positional_argument_error(self, error: Exception) -> bool:
347:    def recover(
52:    def validate_instantiation(self, args: dict[str, Any]) -> bool:
86:    def _validate_field_type(self, field_name: str, value: Any, expected_type: str) -> bool:
123:    def get_field_type(self, field_name: str) -> str | None:
127:    def get_field_comment(self, field_name: str) -> str | None:
131:    def get_field_description(self, field_name: str) -> str:
178:    def struct_type(self) -> StructType:
235:    def _coerce_value(self, value: Any, field_type: str | None) -> Any:
247:    def _find_similar_field(self, name: str, available_fields: list[str]) -> str | None:
253:        def similarity_score(field: str) -> float:
301:    def get_field_names(self) -> list[str]:
305:    def get_field_value(self, field_name: str) -> Any:
309:    def get_field(self, field_name: str) -> Any:
313:    def set_field_value(self, field_name: str, value: Any) -> None:
317:    def to_dict(self) -> dict[str, Any]:
321:    def call_method(self, method_name: str, *args: Any, **kwargs: Any) -> Any:
360:    def register_method(cls, receiver_types: list[str], method_name: str, function: Any) -> None:
375:    def get_method(cls, type_name: str, method_name: str) -> Any | None:
380:    def has_method(cls, type_name: str, method_name: str) -> bool:
385:    def get_methods_for_type(cls, type_name: str) -> dict[str, Any]:
394:    def clear(cls) -> None:
412:    def register(cls, struct_type: StructType) -> None:
428:    def get(cls, struct_name: str) -> StructType | None:
433:    def exists(cls, struct_name: str) -> bool:
438:    def list_types(cls) -> list[str]:
443:    def clear(cls) -> None:
448:    def create_instance(cls, struct_name: str, values: dict[str, Any]) -> StructInstance:
458:    def get_schema(cls, struct_name: str) -> dict[str, Any]:
494:    def _type_to_json_schema(cls, type_name: str) -> dict[str, Any]:
518:    def validate_json(cls, json_data: dict[str, Any], struct_name: str) -> bool:
544:    def create_instance_from_json(cls, json_data: dict[str, Any], struct_name: str) -> StructInstance:
564:def create_struct_type_from_ast(struct_def, context=None) -> StructType:
608:def register_struct_from_ast(struct_def) -> StructType:
615:def create_struct_instance(struct_name: str, **kwargs) -> StructInstance:
36:    def enhance_prompt(self, prompt: str, type_context: TypeContext | None = None) -> str:
58:    def _get_type_handler(self, expected_type: str) -> Callable[[str, TypeContext], str]:
71:    def _build_type_handlers(self) -> dict[str, Callable[[str, TypeContext], str]]:
80:    def _apply_enhancement(self, prompt: str, enhancement: str, type_name: str) -> str:
90:    def _enhance_for_boolean(self, prompt: str, context: TypeContext) -> str:
97:    def _enhance_for_integer(self, prompt: str, context: TypeContext) -> str:
102:    def _enhance_for_float(self, prompt: str, context: TypeContext) -> str:
107:    def _enhance_for_string(self, prompt: str, context: TypeContext) -> str:
117:    def _enhance_for_structure(self, prompt: str, context: TypeContext) -> str:
127:    def _enhance_for_dana_struct(self, prompt: str, context: TypeContext) -> str:
145:    def _get_struct_info(self, expected_type: str) -> dict | None:
171:    def _build_struct_enhancement(self, struct_name: str, struct_info: dict) -> str:
202:    def _build_field_descriptions(self, struct_type) -> list[str]:
210:    def _build_enhancement_patterns(self) -> dict[str, dict[str, str]]:
279:    def get_enhancement_preview(self, prompt: str, expected_type: str) -> str:
304:def enhance_prompt_for_type(prompt: str, type_context: TypeContext | None = None) -> str:
318:def preview_enhancement(prompt: str, expected_type: str) -> str:
30:def main():
51:        async def _validate_document(self, uri: str, text: str):
71:        def _get_document_text(self, uri: str) -> str | None:
84:    async def did_open(ls: DanaLanguageServer, params: lsp.DidOpenTextDocumentParams):
90:    async def did_change(ls: DanaLanguageServer, params: lsp.DidChangeTextDocumentParams):
98:    async def did_save(ls: DanaLanguageServer, params: lsp.DidSaveTextDocumentParams):
120:    async def hover(ls: DanaLanguageServer, params: lsp.HoverParams) -> lsp.Hover | None:
137:    async def completion(ls: DanaLanguageServer, params: lsp.CompletionParams) -> lsp.CompletionList:
132:    async def analyze(self, text: str) -> list[Any]:
165:    def _analyze_dana_specific_rules(self, text: str, program: Program):
176:    def _analyze_line(self, line: str, line_num: int):
221:    def _has_incorrect_scope_syntax(self, line: str) -> bool:
226:    def _has_string_concatenation(self, line: str) -> bool:
234:    def _has_unscoped_assignment(self, line: str) -> bool:
248:    async def get_hover(self, text: str, line: int, character: int) -> str | None:
272:    def _get_word_at_position(self, line: str, character: int) -> str | None:
290:    def _get_dana_hover_info(self, word: str) -> str | None:
315:    async def get_completions(self, text: str, line: int, character: int) -> list[dict[str, Any]]:
357:    def _should_suggest_scope_prefixes(self, prefix: str) -> bool:
362:    def _parse_error_to_diagnostic(self, error: ParseError):
113:    def set_filename(self, filename: str | None) -> None:
131:    def program(self, items):
149:    def _fix_function_boundary_bug(self, statements):
180:    def _fix_nested_statements(self, statements):
243:    def _is_local_scoped_assignment(self, assignment):
251:    def statement(self, items):
267:    def conditional(self, items):
271:    def if_part(self, items):
275:    def else_part(self, items):
279:    def while_stmt(self, items):
283:    def for_stmt(self, items):
287:    def _transform_item(self, item):
313:    def function_def(self, items):
317:    def method_def(self, items):
321:    def decorators(self, items):
325:    def decorator(self, items):
329:    def struct_definition(self, items):
333:    def struct_field(self, items):
337:    def agent_definition(self, items):
341:    def agent_field(self, items):
345:    def try_stmt(self, items):
349:    def if_stmt(self, items):
353:    def elif_stmts(self, items):
357:    def elif_stmt(self, items):
362:    def assignment(self, items):
371:    def declarative_function_assignment(self, items):
378:    def expr_stmt(self, items):
382:    def return_stmt(self, items):
386:    def break_stmt(self, items):
390:    def continue_stmt(self, items):
394:    def pass_stmt(self, items):
398:    def raise_stmt(self, items):
402:    def assert_stmt(self, items):
406:    def use_stmt(self, items):
410:    def agent_stmt(self, items):
414:    def agent_pool_stmt(self, items):
419:    def import_stmt(self, items):
423:    def simple_import(self, items):
427:    def from_import(self, items):
432:    def arg_list(self, items):
436:    def positional_args(self, items):
440:    def named_args(self, items):
444:    def named_arg(self, items):
449:    def _filter_body(self, items):
456:    def identifier(self, items):
460:    def _transform_block(self, block):
497:    def _process_statements_with_boundary_detection(self, statements):
524:    def _is_program_level_statement(self, stmt):
547:    def _is_assignment_to_local_scope(self, assignment_tree):
560:    def _target_uses_local_scope(self, target_tree):
579:    def parameters(self, items):
583:    def parameter(self, items):
587:    def binary_expr(self, items):
601:    def _filter_relevant_items(self, items):
622:    def basic_type(self, items):
626:    def typed_assignment(self, items):
630:    def simple_assignment(self, items):
634:    def function_call_assignment(self, items):
638:    def compound_assignment(self, items):
642:    def compound_op(self, items):
646:    def return_object_stmt(self, items):
650:    def typed_parameter(self, items):
654:    def mixed_arguments(self, items):
658:    def with_arg(self, items):
662:    def with_context_manager(self, items):
666:    def with_stmt(self, items):
670:    def create_location(self, item: Any) -> Location | None:
679:    def statements(self, items):
76:    def set_declarative_function_context(self, in_declarative_function: bool):
80:    def expression(self, items):
115:            def custom_transformer(node: Any) -> Any:
179:    def _extract_operator_string(self, op_token):
183:    def _op_tree_to_str(self, tree):
194:    def _left_associative_binop(self, items, operator_getter):
202:    def _get_binary_operator(self, op_str):
230:    def or_expr(self, items):
241:    def and_expr(self, items):
252:    def placeholder_expression(self, items):
256:    def pipe_expr(self, items):
299:                "Use 'def function_name() = expr1 | expr2' syntax instead of assignment."
305:    def _is_in_declarative_function_context(self):
309:    def _is_literal_expression(self, expr):
329:    def not_expr(self, items):
371:    def comparison(self, items):
374:    def sum_expr(self, items):
378:    def term(self, items):
382:    def factor(self, items):
434:    def power(self, items):
470:    def atom(self, items):
518:    def _atom_from_token(self, token):
556:    def literal(self, items):
560:    def identifier(self, items):
566:    def argument(self, items):
579:    def _process_function_arguments(self, arg_children):
604:    def tuple(self, items):
616:    def list(self, items):
631:    def dict(self, items):
644:    def set(self, items):
656:    def TRUE(self, items=None):
659:    def FALSE(self, items=None):
662:    def NONE(self, items=None):
665:    def trailer(self, items):
703:    def _get_full_attribute_name(self, attr):
715:    def key_value_pair(self, items):
721:    def expr(self, items):
725:    def string(self, items):
802:    def product(self, items):
810:    def POW(self, token):
814:    def ADD(self, token):
818:    def SUB(self, token):
822:    def MUL(self, token):
826:    def DIV(self, token):
830:    def FDIV(self, token):
834:    def MOD(self, token):
838:    def string_literal(self, items):
891:    def slice_or_index(self, items):
895:    def slice_start_only(self, items):
899:    def slice_stop_only(self, items):
903:    def slice_start_stop(self, items):
907:    def slice_start_stop_step(self, items):
911:    def slice_all(self, items):
915:    def slice_step_only(self, items):
919:    def slice_expr(self, items):
924:    def slice_list(self, items):
936:    def function_composition_expr(self, items):
941:    def function_pipe_expr(self, items):
956:    def pipeline_stage(self, items):
983:    def function_expr(self, items):
988:    def function_name(self, items):
993:    def function_call(self, items):
1016:    def function_list_literal(self, items):
1024:    def _contains_placeholder(self, arguments):
1042:    def _is_placeholder_expression(self, expr):
46:    def assignment(self, items):
55:    def typed_assignment(self, items):
64:    def simple_assignment(self, items):
72:    def compound_assignment(self, items):
124:    def compound_op(self, items):
129:    def function_call_assignment(self, items):
153:    def declarative_function_assignment(self, items):
206:    def _transform_function_composition(self, composition_tree):
226:    def _transform_parameter(self, param_tree):
243:    def _transform_type_hint(self, type_tree):
257:    def return_object_stmt(self, items):
271:    def basic_type(self, items):
275:    def typed_parameter(self, items):
5:- Function definitions (def statements)
45:    def function_def(self, items):
81:    def method_def(self, items):
150:    def _extract_decorators_and_name(self, relevant_items):
171:    def _resolve_function_parameters(self, relevant_items, current_index):
195:    def _extract_return_type(self, relevant_items, current_index):
214:    def _extract_function_body(self, relevant_items, current_index):
229:    def decorators(self, items):
233:    def decorator(self, items):
237:    def _transform_decorators(self, decorators_tree):
245:    def _transform_decorator(self, decorator_tree):
251:    def _transform_decorator_from_items(self, items):
268:    def _parse_decorator_arguments(self, arguments_tree):
291:    def _transform_parameters(self, parameters_tree):
297:    def _transform_parameter(self, param_tree):
306:    def parameters(self, items):
342:    def parameter(self, items):
364:    def struct_definition(self, items):
385:    def struct_field(self, items):
423:    def agent_definition(self, items):
444:    def agent_field(self, items):
38:    def expr_stmt(self, items):
42:    def return_stmt(self, items):
46:    def break_stmt(self, items):
50:    def continue_stmt(self, items):
54:    def pass_stmt(self, items):
58:    def raise_stmt(self, items):
62:    def assert_stmt(self, items):
68:    def import_stmt(self, items):
73:    def simple_import(self, items):
117:    def from_import(self, items):
211:    def arg_list(self, items):
215:    def positional_args(self, items):
219:    def named_args(self, items):
228:    def named_arg(self, items):
43:    def conditional(self, items):
53:    def if_part(self, items):
59:    def else_part(self, items):
63:    def if_stmt(self, items):
111:    def elif_stmts(self, items):
142:    def elif_stmt(self, items):
152:    def while_stmt(self, items):
161:    def for_stmt(self, items):
209:    def try_stmt(self, items):
239:    def except_clause(self, items):
258:    def except_spec(self, items):
278:    def exception_type(self, items):
295:    def exception_list(self, items):
30:    def variable(self, items):
38:    def scoped_var(self, items):
54:        def raw_name(item):
72:    def simple_name(self, items):
84:    def dotted_access(self, items):
123:    def identifier(self, items):
137:    def _extract_name(self, item):
158:    def _join_dotted(self, parts):
164:    def _insert_scope_if_missing(self, name):
31:    def set_filename(self, filename: str | None) -> None:
35:    def _parse_literal(self, text):
39:    def _create_literal(self, token):
43:    def _insert_local_scope(self, parts: list[str] | str) -> Any:
48:    def get_leaf_node(item: Tree | Token | ASTNode) -> Token | ASTNode:
52:    def flatten_items(self, items):
59:    def unwrap_single_child_tree(self, item, stop_at=None):
73:    def get_location(self, item: Any) -> tuple[int, int] | None:
89:    def create_location(self, item: Any) -> Location | None:
30:    def set_filename(self, filename: str | None) -> None:
43:    def transform(self, tree):
29:    def trailer(self, items):
160:    def argument(self, items):
175:    def _process_function_arguments(self, arg_children):
202:    def slice_or_index(self, items):
206:    def slice_start_only(self, items):
210:    def slice_stop_only(self, items):
214:    def slice_start_stop(self, items):
218:    def slice_start_stop_step(self, items):
222:    def slice_all(self, items):
226:    def slice_step_only(self, items):
230:    def slice_expr(self, items):
235:    def slice_list(self, items):
246:    def _get_full_attribute_name(self, attr):
24:    def extract_operator_string(op_token):
47:    def op_tree_to_str(tree):
55:    def left_associative_binop(items, operator_getter):
79:    def get_binary_operator(op_str):
114:    def atom_from_token(token):
138:    def process_string_literal(item):
179:    def get_full_attribute_name(attr):
27:    def _extract_operator_string(self, op_token):
38:    def _op_tree_to_str(self, tree):
45:    def _left_associative_binop(self, items, operator_getter):
69:    def _get_binary_operator(self, op_str):
99:    def or_expr(self, items):
103:    def and_expr(self, items):
107:    def pipe_expr(self, items):
111:    def not_expr(self, items):
136:    def comparison(self, items):
140:    def sum_expr(self, items):
144:    def term(self, items):
148:    def factor(self, items):
173:    def power(self, items):
193:    def ADD(self, token):
197:    def SUB(self, token):
201:    def MUL(self, token):
205:    def DIV(self, token):
209:    def FDIV(self, token):
213:    def MOD(self, token):
217:    def POW(self, token):
221:    def PIPE(self, token):
225:    def EQ_OP(self, token):
229:    def NE_OP(self, token):
233:    def LT_OP(self, token):
237:    def GT_OP(self, token):
241:    def LE_OP(self, token):
245:    def GE_OP(self, token):
249:    def IN_OP(self, token):
253:    def NOT_IN_OP(self, token):
257:    def IS_OP(self, token):
261:    def IS_NOT_OP(self, token):
265:    def NOT_OP(self, token):
35:    def validate_function_call_trailer(trailer: Any) -> None:
47:    def validate_attribute_trailer(trailer: Any) -> None:
66:    def handle_function_call(self, current_base: Expression, trailer: Any) -> ObjectFunctionCall | FunctionCall:
94:    def _create_method_call(self, attribute_access: AttributeAccess, args: dict[str, Any]) -> ObjectFunctionCall:
103:    def _create_function_call(self, base: Expression, args: dict[str, Any]) -> FunctionCall:
119:    def handle_attribute_access(self, current_base: Expression, trailer: Any) -> AttributeAccess:
149:    def handle_indexing(self, current_base: Expression, trailer: Any) -> SubscriptExpression:
170:    def analyze_chain(self, trailers: list[Any]) -> dict[str, Any]:
198:    def _count_trailer_types(self, trailers: list[Any]) -> dict[str, int]:
230:    def process_trailers(self, base: Expression, trailers: list[Any]) -> Expression:
267:    def _process_single_trailer(self, current_base: Expression, trailer: Any, position: int) -> Expression:
76:    def from_type_hint(type_hint: "TypeHint") -> "DanaType":
103:    def get(self, name: str) -> DanaType | None:
111:    def set(self, name: str, type_: DanaType) -> None:
115:    def register(self, name: str, type_: DanaType) -> None:
119:    def push_scope(self):
123:    def pop_scope(self):
134:    def check_program(self, program: Program) -> None:
139:    def check_statement(self, statement: Any) -> None:
185:    def check_assignment(self, node: Assignment) -> None:
225:    def check_compound_assignment(self, node: CompoundAssignment) -> None:
256:    def check_conditional(self, node: Conditional) -> None:
267:    def check_while_loop(self, node: WhileLoop) -> None:
276:    def check_for_loop(self, node: ForLoop) -> None:
306:    def check_try_block(self, node: TryBlock) -> None:
316:    def check_except_block(self, node: ExceptBlock) -> None:
321:    def check_function_definition(self, node: FunctionDefinition) -> None:
376:    def check_method_definition(self, node: MethodDefinition) -> None:
427:    def check_struct_definition(self, node: StructDefinition) -> None:
442:    def check_import_statement(self, node: ImportStatement) -> None:
446:    def check_import_from_statement(self, node: ImportFromStatement) -> None:
450:    def check_expression(self, expression: Any) -> DanaType:
492:    def check_literal_expression(self, node: LiteralExpression) -> DanaType:
496:    def check_identifier(self, node: Identifier) -> DanaType:
514:    def check_binary_expression(self, node: BinaryExpression) -> DanaType:
580:    def check_unary_expression(self, node: UnaryExpression) -> DanaType:
589:    def check_attribute_access(self, node: AttributeAccess) -> DanaType:
596:    def check_subscript_expression(self, node: SubscriptExpression) -> DanaType:
614:    def check_dict_literal(self, node: DictLiteral) -> DanaType:
623:    def check_set_literal(self, node: SetLiteral) -> DanaType:
629:    def check_tuple_literal(self, node: TupleLiteral) -> DanaType:
635:    def check_list_literal(self, node: ListLiteral) -> DanaType:
641:    def check_function_call(self, node: FunctionCall) -> DanaType:
651:    def check_assert_statement(self, node: AssertStatement) -> None:
661:    def check_raise_statement(self, node: RaiseStatement) -> None:
671:    def check_return_statement(self, node: ReturnStatement) -> None:
677:    def check_use_statement(self, node: UseStatement) -> DanaType:
688:    def check_types(program: Program) -> None:
52:    def is_valid(self) -> bool:
129:    def parse(self, program_text: str, do_transform: bool = True, do_type_check: bool = False, filename: str | None = None) -> Any:
156:    def transform(self, parse_tree: Tree, do_type_check: bool = False) -> Program:
184:    def parse_expression(self, expr_text: str):
208:    def _deprecated_transform_identifier(self, node: Tree) -> Identifier:
224:def parse_program(program_text: str, do_type_check: bool = ENABLE_TYPE_CHECK) -> Program:
103:    def _register_cleanup(self):
109:    def _create_default_context(self) -> SandboxContext:
115:        def feedback_placeholder(result: Any, feedback_data: Any):
123:    def _ensure_initialized(self):
155:    def _can_reuse_shared_resources(self) -> bool:
163:    def _use_shared_resources(self):
171:    def _initialize_new_resources(self):
203:    def _cleanup(self):
247:    def _cleanup_instance_resources(self):
274:    def _cleanup_shared_resources(cls):
301:    def _cleanup_on_deletion(weakref_obj):
322:    def _cleanup_all_instances(cls):
338:    def cleanup_all(cls):
346:    def is_healthy(self) -> bool:
359:    def run_file(self, file_path: str | Path) -> ExecutionResult:
445:    def eval(self, source_code: str, filename: str | None = None) -> ExecutionResult:
529:    def quick_run(cls, file_path: str | Path, debug_mode: bool = False, context: SandboxContext | None = None) -> ExecutionResult:
545:    def quick_eval(
587:    def context(self) -> SandboxContext:
591:    def load_file(self, file_path: str) -> None:
598:    def function_registry(self):
31:    def evaluate(self, context) -> Any:
152:    def type(self):
466:    """Method definition statement with explicit receiver (e.g., def (point: Point) translate(dx, dy):)."""
479:    """Declarative function definition statement (e.g., def func(x: int) -> str = f1 | f2)."""
89:    def parent_context(self) -> Optional["SandboxContext"]:
94:    def manager(self) -> Optional["ContextManager"]:
99:    def manager(self, manager: "ContextManager") -> None:
104:    def interpreter(self) -> "DanaInterpreter":
111:    def interpreter(self, interpreter: "DanaInterpreter"):
120:    def error_context(self):
124:    def get_interpreter(self) -> Optional["DanaInterpreter"]:
132:    def _validate_key(self, key: str) -> tuple[str, str]:
163:    def _normalize_key(self, scope: str, var_name: str) -> str:
175:    def set(self, key: str, value: Any) -> None:
201:    def get(self, key: str, default: Any = None) -> Any:
234:    def get_execution_status(self) -> ExecutionStatus:
242:    def set_execution_status(self, status: ExecutionStatus) -> None:
250:    def add_execution_history(self, entry: dict[str, Any]) -> None:
261:    def reset_execution_state(self) -> None:
267:    def from_dict(cls, data: dict[str, Any], base_context: Optional["SandboxContext"] = None) -> "SandboxContext":
308:    def set_in_scope(self, var_name: str, value: Any, scope: str = "local") -> None:
333:    def has(self, key: str) -> bool:
353:    def delete(self, key: str) -> None:
375:    def clear(self, scope: str | None = None) -> None:
392:    def get_state(self) -> dict[str, dict[str, Any]]:
400:    def set_state(self, state: dict[str, dict[str, Any]]) -> None:
418:    def merge(self, other: "SandboxContext") -> None:
427:    def copy(self) -> "SandboxContext":
456:    def sanitize(self) -> "SandboxContext":
550:    def get_scope(self, scope: str) -> dict[str, Any]:
561:    def set_scope(self, scope: str, context: dict[str, Any] | None = None) -> None:
570:    def get_from_scope(self, var_name: str, scope: str = "local") -> Any:
605:    def get_assignment_target_type(self) -> Any | None:
627:    def set_resource(self, name: str, resource: BaseResource) -> None:
641:    def get_resource(self, name: str) -> BaseResource:
647:    def get_resources(self, included: list[str | BaseResource] | None = None) -> dict[str, BaseResource]:
677:    def soft_delete_resource(self, name: str) -> None:
684:    def list_resources(self) -> list[str]:
693:    def delete_from_scope(self, var_name: str, scope: str = "local") -> None:
721:    def set_agent(self, name: str, agent: BaseResource) -> None:
735:    def get_agent(self, name: str) -> BaseResource:
741:    def get_agents(self, included: list[str | BaseResource] | None = None) -> dict[str, BaseResource]:
757:    def soft_delete_agent(self, name: str) -> None:
764:    def list_agents(self) -> list[str]:
773:    def get_self_agent_card(self, included_resources: list[str | BaseResource] | None = None) -> dict[str, dict[str, Any]]:
810:    def get_other_agent_cards(self, included_agents: list[str | BaseResource] | None = None) -> dict[str, dict[str, Any]]:
816:    def startup(self) -> None:
821:    def shutdown(self) -> None:
37:    def _smart_max(*args):
55:    def _smart_min(*args):
73:    def _smart_sum(*args):
405:    def _semantic_bool_wrapper(cls, value):
416:    def create_function(cls, name: str):
431:        def dana_wrapper(context: SandboxContext, *args, **kwargs):
446:    def _raise_unsupported_error(cls, name: str):
470:    def _handle_unknown_builtin(cls, name: str):
575:    def _validate_args(cls, name: str, args: tuple, expected_signatures: list[tuple]):
618:    def _execute_with_guards(cls, func: callable, args: tuple):
625:    def get_available_functions(cls) -> list[str]:
630:    def get_function_info(cls, name: str) -> dict[str, Any]:
637:    def get_unsupported_functions(cls) -> list[str]:
642:    def get_unsupported_info(cls, name: str) -> dict[str, Any]:
649:    def is_supported(cls, name: str) -> bool:
654:    def is_unsupported(cls, name: str) -> bool:
659:    def get_functions_by_reason(cls, reason: UnsupportedReason) -> list[str]:
664:    def get_security_report(cls) -> dict[str, Any]:
696:def register_pythonic_builtins(registry: FunctionRegistry) -> None:
735:        def create_unsupported_handler(name):
736:            def unsupported_handler(context: SandboxContext, *args, **kwargs):
9:def create_function_with_better_doc_string(func: Callable, doc_string: str) -> Callable:
13:    def wrapper(*args, **kwargs):
17:    async def async_wrapper(*args, **kwargs):
28:def use_function(context: SandboxContext, function_name: str, *args, _name: str | None = None, **kwargs) -> BaseResource:
19:def cast_function(context: SandboxContext, target_type: Any, value: Any) -> Any:
15:def noop_function(
7:def agent_function(context: SandboxContext, *args, _name: str | None = None, **kwargs) -> AbstractDanaAgent:
31:def _create_module_agent(context: SandboxContext, name: str, module, **kwargs) -> AbstractDanaAgent:
60:def _create_a2a_agent(context: SandboxContext, name: str, *args, **kwargs) -> AbstractDanaAgent:
94:def agent_pool_function(context: SandboxContext, *args, _name: str | None = None, **kwargs) -> BaseResource:
20:def register_core_functions(registry: FunctionRegistry) -> None:
16:def load_dana_env(dot_env_file_path: Path | str | None = None):
53:    def _resolve_user_identity(self, provided_user_id: str = None) -> str:
82:    def _resolve_instance_identity(self, provided_instance_id: str = None) -> str:
115:    def _resolve_session_identity(self, provided_session_id: str = None) -> str:
138:    def _initialize_simplified_memory_system(self):
183:    def _initialize_cross_session_persistence(self):
195:    def _restore_session_context(self):
224:    def _wrap_agent_methods(self):
235:    def _context_aware_solve(self, input_data: str, context: str | None = None) -> str:
245:    def _solve_with_memory_system(self, input_data: str, context: str | None = None) -> str:
281:    def _get_memory_context(self, input_data: str) -> dict:
290:    def _store_interaction_in_memory(self, input_data: str, response: str, complete_conversation: str):
299:    def _solve_with_basic_context(self, input_data: str, context: str | None = None) -> str:
330:    def _context_aware_reason(self, prompt: str, **kwargs) -> str:
353:    def _build_contextual_prompt(self, input_data: str) -> str:
393:    def _enhance_prompt_with_context(self, original_prompt: str) -> str:
412:    def _build_memory_enhanced_prompt(self, input_data: str, memory_context: dict) -> str:
448:    def _build_persistent_context_prompt(self, input_data: str, memory_context: dict) -> str:
495:    def _build_memory_context_summary(self, memory_context: dict) -> str:
517:    def _build_memory_enhanced_input(self, input_data: str) -> str:
544:    def _get_comprehensive_memory_context(self) -> str:
585:    def _extract_conversations_from_memories(self, memories) -> list:
634:    def _extract_user_facts_from_memories(self, memories) -> list:
645:    def _build_direct_memory_context(self, memory_items: list) -> str:
661:    def _run_async_safely(self, coro):
668:    def get_context_info(self) -> dict[str, Any]:
699:    def get_conversation_summary(self) -> str:
720:    def get_persistence_status(self) -> dict[str, Any]:
741:    def reset_context(self):
50:    def add_turn(self, user_input: str, agent_response: str, context_used: dict[str, Any] = None):
61:    def get_recent_history(self, n: int = 5) -> list[ConversationTurn]:
65:    def get_conversation_context(self) -> str:
78:    def extract_user_info(self, text: str) -> dict[str, Any]:
106:    def get_user_context(self) -> dict[str, Any]:
120:    def _generate_conversation_summary(self) -> str:
142:    def should_include_context(self) -> bool:
147:    def clear_session(self):
45:def _default_metadata() -> MemoryMetadata:
60:    def content(self) -> str:
64:    def embedding(self) -> list[float] | None:
68:    def memory_type(self) -> MemoryType:
72:    def confidence(self) -> float | None:
85:    def add_memory(self, memory: MemoryItem, target_type: str | None = None):
89:    def get_all_memories(self) -> list[MemoryItem]:
29:    async def initialize(self):
35:    async def extract_memories(self, conversation_content: str, user_id: str) -> list[dict[str, Any]]:
63:    def _build_extraction_prompt(self, content: str) -> str:
113:    def _parse_memory_response(self, response_content: Any, original_content: str) -> list[dict[str, Any]]:
138:    def _validate_memories(self, memories: list[dict[str, Any]]) -> list[dict[str, Any]]:
186:    def _fallback_extraction(self, content: str) -> list[dict[str, Any]]:
232:    async def initialize(self):
238:    async def detect_intent(self, query: str, working_memory: list[MemoryItem]) -> dict[str, Any]:
267:    def _format_memory_context(self, memories: list[MemoryItem]) -> str:
278:    def _build_intent_prompt(self, query: str, memory_context: str) -> str:
302:    def _parse_intent_response(self, response_content: Any, query: str) -> dict[str, Any]:
332:    def _fallback_intent_detection(self, query: str, working_memory: list[MemoryItem]) -> dict[str, Any]:
361:    async def initialize(self):
367:    async def rank_memories(self, query: str, memories: list[MemoryItem]) -> list[MemoryItem]:
403:    def _build_ranking_prompt(self, query: str, memory_texts: list[str]) -> str:
423:    def _parse_ranking_response(self, response_content: Any, memories: list[MemoryItem]) -> list[MemoryItem]:
457:    def _simple_rank_memories(self, query: str, memories: list[MemoryItem]) -> list[MemoryItem]:
465:        def relevance_score(memory: MemoryItem) -> float:
21:    def _serialize_memory_item(self, memory: MemoryItem) -> dict[str, Any]:
41:    def _deserialize_memory_item(self, data: dict[str, Any]) -> MemoryItem:
63:    def _load_memories(self) -> list[MemoryItem]:
76:    def _save_memories(self, memories: list[MemoryItem]):
82:    def _text_search(self, memories: list[MemoryItem], query: str, limit: int) -> list[MemoryItem]:
127:    async def store(self, memory: MemoryItem) -> bool:
145:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
153:    async def search_by_text(self, query: str, limit: int = 10) -> list[MemoryItem]:
159:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
168:    def _is_duplicate(self, new_memory: MemoryItem, existing_memories: list[MemoryItem]) -> bool:
202:    async def store(self, memory: MemoryItem) -> bool:
210:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
216:    async def search_by_text(self, query: str, limit: int = 10) -> list[MemoryItem]:
222:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
231:    async def get_user_profile_summary(self) -> dict[str, Any]:
279:    async def store(self, memory: MemoryItem) -> bool:
298:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
304:    async def search_by_text(self, query: str, limit: int = 10) -> list[MemoryItem]:
310:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
319:    def _should_share(self, memory: MemoryItem) -> bool:
348:    def _sanitize_memory(self, memory: MemoryItem) -> MemoryItem:
361:    async def get_collective_stats(self) -> dict[str, Any]:
12:    async def store(self, memory: MemoryItem) -> bool:
16:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
20:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
41:    def _get_storage_file_path(self) -> Path:
47:    def _load_memories(self):
60:    def _save_memories(self):
77:    def _serialize_memory(self, memory: MemoryItem) -> dict:
97:    def _deserialize_memory(self, data: dict) -> MemoryItem | None:
123:    async def store(self, memory: MemoryItem) -> bool:
131:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
136:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
143:    def clear_and_keep_recent(self, keep_count: int = 10):
150:    def replace_with_items(self, items_to_keep: list):
165:    async def store(self, memory: MemoryItem) -> bool:
173:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
178:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
194:    async def store(self, memory: MemoryItem) -> bool:
199:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
203:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
221:    async def store(self, memory: MemoryItem) -> bool:
228:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
232:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
67:    def _initialize_index(self):
98:    def _load_memory_metadata(self):
130:    def _save_memory_metadata(self):
158:    def _create_document_from_memory(self, memory: MemoryItem) -> Document:
176:    async def store(self, memory: MemoryItem) -> bool:
207:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
215:    async def search_by_text(self, query: str, limit: int) -> list[MemoryItem]:
242:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
247:    def get_query_engine(self, similarity_top_k: int = 10):
264:    def get_memory_count(self) -> int:
282:    async def store(self, memory: MemoryItem) -> bool:
300:    def _is_semantic_duplicate(self, new_content: str, existing_content: str) -> bool:
325:    async def get_user_profile_summary(self, query: str = "user preferences and characteristics") -> str:
347:    async def search_user_preferences(self, topic: str, limit: int = 10) -> list[MemoryItem]:
375:    async def store(self, memory: MemoryItem) -> bool:
403:    def _should_store_in_shared(self, memory: MemoryItem) -> bool:
432:    async def _rebuild_index(self):
462:    async def search_collective_knowledge(self, query: str, limit: int = 10) -> list[MemoryItem]:
466:    async def get_popular_topics(self, limit: int = 10) -> list[str]:
81:    def _count_tokens(self, text: str) -> int:
87:    def _get_working_memory_token_count(self, memories: list[MemoryItem]) -> int:
92:    def _get_recent_items_by_token_limit(self, memories: list[MemoryItem], token_limit: int) -> list[MemoryItem]:
113:    async def add_conversation_memory(self, memory_content: str) -> list[MemoryItem]:
142:    async def process_working_memory_batch(self):
222:    async def manual_batch_process(self):
226:    async def chat_with_memory(self, query: str) -> dict[str, Any]:
255:    async def retrieve_context(self, query: str) -> list[str]:
274:    async def get_user_profile(self) -> dict[str, Any]:
300:    async def advanced_query(self, query: str, memory_type: str = "long_term") -> str:
328:    async def search_by_text(self, query: str, memory_type: str = "all", limit: int = 10) -> list[MemoryItem]:
357:    async def get_current_working_memory_tokens(self) -> int:
362:    async def get_memory_statistics(self) -> dict[str, Any]:
409:    async def _search_persistent_memories(self, missing_evidence: list[str]) -> list[MemoryItem]:
426:    async def _replace_working_memory_with_llm_ranking(self, query: str, original: list[MemoryItem], retrieved: list[MemoryItem]) -> None:
88:    def with_planning(
121:    def with_reasoning(
152:    def _create_llm(self, llm: dict | str | LLMResource, name: str) -> LLMResource:
164:    def runtime_context(self) -> RuntimeContext:
171:    def planner(self) -> Planner:
178:    def planner(self, planner: Planner | None) -> None:
183:    def reasoner(self) -> Reasoner:
190:    def reasoner(self, reasoner: Reasoner | None) -> None:
195:    def _current_plan(self) -> Plan:
210:        def handle_plan_get(key: str, default: Any) -> Any:
214:        def handle_plan_set(key: str, value: Any) -> None:
231:    async def execute(self, plan: "Plan") -> Any:
30:    def create_agent(cls, config: dict[str, Any]) -> Agent:
18:def default_plan_method(context: SandboxContext, agent_instance: "AgentInstance", task: str, user_context: dict | None = None) -> Any:
39:def default_solve_method(context: SandboxContext, agent_instance: "AgentInstance", problem: str, user_context: dict | None = None) -> Any:
75:    def add_method(self, method_name: str, method_func: Any) -> None:
78:    def get_method(self, method_name: str) -> Any | None:
87:    def has_method(self, method_name: str) -> bool:
130:    def _initialize_context_management(self):
141:    def agent_card(self) -> dict[str, Any]:
158:    def skills(self) -> list[dict[str, Any]]:
162:    def agent_type(self) -> AgentType:
165:    def solve(self, task: str) -> str:
179:    def plan(self, task: str, user_context: dict | None = None) -> Any:
182:    def get_context_info(self) -> dict:
189:    def get_conversation_summary(self) -> str:
196:    def reset_context(self):
201:    def get_persistence_status(self) -> dict:
208:    def _call_method(self, method, *args, **kwargs):
244:    def _call_method_with_current_context(self, method, *args, **kwargs):
269:    def _get_current_execution_context(self):
307:    def call_method(self, method_name: str, *args: Any, **kwargs: Any) -> Any:
314:    def to_dict(self) -> dict[str, Any]:
321:    def _try_global_function_fallback(self, method_name: str) -> Any | None:
340:                def agent_method_wrapper(*args, **kwargs):
351:    def _function_matches_agent_type(self, func: Any, agent_type_name: str) -> bool:
394:    def _get_function_registry(self):
419:    def register(cls, agent_type: AgentType) -> None:
423:    def get(cls, agent_name: str) -> AgentType | None:
427:    def exists(cls, agent_name: str) -> bool:
431:    def list_types(cls) -> list[str]:
435:    def clear(cls) -> None:
439:    def create_instance(cls, agent_name: str, values: dict[str, Any], context: SandboxContext, instance_id: str = None) -> AgentInstance:
447:def create_agent_type_from_ast(agent_def) -> AgentType:
468:def register_agent_from_ast(agent_def) -> AgentType:
474:def create_agent_instance(agent_name: str, context: SandboxContext, **kwargs) -> AgentInstance:
478:def register_agent_method_from_function_def(node, dana_func):
67:    def _load_default_config(self) -> dict[str, Any]:
79:    def _find_first_available_model(self) -> str | None:
112:    def _get_required_env_vars_for_model(self, model_name: str) -> list[str]:
143:    def _load_from_file(self, config_path: str) -> None:
185:    def _load_json_file(self, path: Path) -> None:
204:    def _update_logging_from_env(self) -> None:
208:        def safe_int(value: str, default: int) -> int:
225:    def get(self, key: str, default: Any = None) -> Any:
229:    def update(self, config: dict[str, Any]) -> None:
53:    def new_instance(cls, response: BaseResponse | dict[str, Any] | Any) -> "AgentResponse":
97:    def state(self) -> AgentState:
104:    def runtime(self) -> AgentRuntime:
111:    def agent_llm(self) -> LLMResource:
118:    def available_resources(self) -> dict[str, BaseResource]:
125:    def capabilities(self) -> dict[str, BaseCapability]:
132:    def io(self) -> BaseIO:
139:    def with_model(self, model: str) -> "Agent":
144:    def with_llm(self, llm: dict | str | LLMResource) -> "Agent":
154:    def with_resources(self, resources: dict[str, BaseResource]) -> "Agent":
161:    def with_capabilities(self, capabilities: dict[str, BaseCapability]) -> "Agent":
168:    def with_io(self, io: BaseIO) -> "Agent":
173:    def with_planning(
189:    def with_reasoning(
206:    def _get_default_llm_resource(self):
210:    def _create_llm(self, llm: dict | str | LLMResource, name: str) -> LLMResource:
221:    def _initialize(self) -> "Agent":
236:    async def cleanup(self) -> None:
242:    async def initialize(self) -> "Agent":
256:    async def async_run(self, plan: Plan, context: RuntimeContext | None = None) -> AgentResponse:
262:    def run(self, plan: Plan) -> AgentResponse:
265:        async def _run_async():
270:    def ask(self, question: str) -> AgentResponse:
275:    def runtime_context(self) -> RuntimeContext:
280:    async def set_variable(self, name: str, value: Any) -> BaseResponse:
285:    async def query(self, request: BaseRequest) -> BaseResponse:
289:    def has_capability(self, capability: BaseCapability | str) -> bool:
303:    def add_capability(self, name: str, capability: BaseCapability) -> None:
312:    def remove_capability(self, name: str) -> None:
57:    async def create(cls, name: str, agent: "Agent", description: str) -> "AgentResource":
73:    async def query(self, request: BaseRequest | None = None) -> BaseResponse:
99:    async def initialize(self) -> None:
111:    async def cleanup(self) -> None:
98:    def expertise(self) -> DomainExpertise | None:
103:    def confidence_threshold(self) -> float:
108:    def system_prompt(self) -> str | None:
113:    def llm_config(self) -> dict[str, Any]:
117:    async def initialize(self) -> None:
123:    async def query(self, request: BaseRequest | None = None) -> BaseResponse:
143:    async def cleanup(self) -> None:
148:    def can_handle(self, request: dict[str, Any]) -> bool:
16:    def create_resource(cls, resource_type: str, config: dict[str, Any]) -> BaseResource:
25:    def create_llm_resource(cls, config: dict[str, Any]) -> LLMResource:
16:def main():
28:def parse_dana_input_args(input_strs: list[str] | tuple[str, ...]) -> dict[str, str]:
72:    def resolve_at_file(value: str, is_file: bool) -> str:
46:    def mcp_tool_decorator(self, func_name: str) -> Any:
49:        def wrapper(**kwargs) -> Any:
78:    async def initialize(self) -> None:
83:    async def _discover_tools(self) -> None:
94:    def _list_tools(self, format_converter: OpenAIToolFormat) -> list[Any]:
105:    async def call_tool(self, tool_name: str, arguments: dict[str, Any]) -> Any:
123:    async def query(self, request: BaseRequest) -> BaseResponse:
145:    def can_handle(self, request: BaseRequest) -> bool:
159:    async def main():
12:    def parse_init_params(cls, *args, **kwargs) -> ParsedArgKwargsResults:
86:    def _validate_transport(cls, *args, **kwargs) -> BaseTransport:
96:    async def _try_client_with_valid_transport(cls, transport: BaseTransport) -> bool:
6:def extract_text_from_response(response: Message) -> str:
34:    def select_agent(self, task: any, strategy: str = "llm", included_resources: list[str | Any] | None = None) -> Any:
52:    def _select_by_llm(self, task: any, included_resources: list[str | Any] | None = None) -> Any:
126:    def _get_agent_skills(self, agent: Any) -> list[str]:
139:    def _format_agent_cards(self, cards: dict[str, dict]) -> str:
168:    def update_performance_metrics(self, agent_name: str, metrics: dict[str, float]) -> None:
82:    def get_base_path(cls) -> Path:
91:    def get_config_path(
163:    def from_dict(cls, data: dict[str, Any]) -> "Configurable":
183:    def _load_config(self, config_path: str | Path | None = None) -> dict[str, Any]:
218:    def _apply_overrides(self, overrides: dict[str, Any]) -> None:
232:    def _validate_required(self, key: str, error_msg: str | None = None) -> None:
256:    def _validate_type(self, key: str, expected_type: type[T], error_msg: str | None = None) -> None:
282:    def _validate_enum(self, key: str, valid_values: list[Any], error_msg: str | None = None) -> None:
308:    def _validate_path(self, key: str, must_exist: bool = True, error_msg: str | None = None) -> None:
334:    def _validate_config(self) -> None:
350:    def get(self, key: str, default: Any = None) -> Any:
362:    def set(self, key: str, value: Any) -> None:
375:    def update(self, config: dict[str, Any]) -> None:
387:    def to_dict(self) -> dict[str, Any]:
395:    def save(self, path: str | Path) -> None:
418:    def get_yaml_path(cls, path: str | None = None) -> Path:
474:    def get_prompt(cls, config_path: str | None = None, prompt_ref: str | None = None, custom_prompts: dict[str, str] | None = None) -> str:
521:    def load_config(cls, path: str | None = None) -> dict[str, Any]:
29:def configure_asyncio_threshold():
66:    def load_yaml_config(path: str | Path) -> dict[str, Any]:
90:    def _resolve_yaml_path(path: Path) -> Path:
105:    def get_class_by_name(class_path: str) -> type[Any]:
116:    def get_base_path(for_class: type[Any]) -> Path:
121:    def get_config_path(
174:    def safe_asyncio_run(func: Callable[..., Any], *args: Any, **kwargs: Any) -> Any:
206:    def _run_in_existing_loop(func: Callable[..., Any], *args: Any, **kwargs: Any) -> Any:
216:        def run_in_thread():
225:    def get_field(obj: dict | object, field_name: str, default: Any = None) -> Any:
241:    def has_field(obj: dict | object, field_name: str) -> bool:
248:    def generate_base64_uuid(length: int | None = None) -> str:
278:    def parse_args_kwargs(func, *args, **kwargs) -> ParsedArgKwargsResults:
343:    def get_hash(key: str, length: int | None = None) -> str:
350:    def generate_uuid(length: int | None = None) -> str:
358:    def text_to_dict(text: str) -> dict[str, Any]:
378:    def get_response_content(response: BaseResponse) -> Any:
39:    def build_request_params(
75:    def get_openai_functions(self, resources: dict[str, BaseResource]) -> list[OpenAIFunctionCall]:
89:    async def call_requested_tools(self, tool_calls: list[OpenAIFunctionCall]) -> list[dict[str, Any]]:
189:    async def call_tools_legacy(self, tool_calls: list[dict[str, Any]], available_resources: list[BaseResource]) -> list[BaseResponse]:
218:    def format_tool_call_message(self, response_message: dict[str, Any], tool_calls: list[OpenAIFunctionCall]) -> dict[str, Any]:
236:    def has_tool_calls(self, response_message: dict[str, Any]) -> bool:
250:    def register_resources(self, available_resources: dict[str, Any]) -> None:
259:    def unregister_resources(self, available_resources: dict[str, Any]) -> None:
38:    async def initialize(self) -> None:
45:    async def query(self, query: str, num_results: int = 10) -> str:
136:    def _validate_decay_parameters(self) -> None:
150:    def decay_rate(self) -> float:
155:    def decay_rate(self, value: float) -> None:
174:    def half_life(self) -> float:
186:    def decay_interval(self) -> int:
191:    def decay_interval(self, value: int) -> None:
209:    def _should_decay(self) -> bool:
221:    async def _maybe_decay(self) -> None:
240:            def run_decay():
247:    async def decay_memories(self, intervals_passed: float = 1.0) -> None:
280:    async def initialize(self) -> None:
287:    async def cleanup(self) -> None:
295:    async def store(
339:    async def retrieve(self, query: str | None = None, limit: int | None = None) -> BaseResponse:
364:    async def update_importance(self, memory_id: int, importance: float) -> BaseResponse:
384:    def get_decay_stats(self) -> dict[str, Any]:
403:    def can_handle(self, request: dict[str, Any]) -> bool:
449:    def can_handle(self, request: dict[str, Any]) -> bool:
495:    def can_handle(self, request: dict[str, Any]) -> bool:
541:    async def _maybe_decay(self) -> None:
545:    async def decay_memories(self, intervals_passed: float = 1.0) -> None:
549:    def get_decay_stats(self) -> dict[str, Any]:
559:    def can_handle(self, request: dict[str, Any]) -> bool:
17:async def configure_poet(config: dict[str, Any]):
50:async def get_poet_domains():
21:async def upload_document(
43:async def create_document(
69:async def get_document(document_id: int, db: Session = Depends(get_db), document_service=Depends(get_document_service)):
85:async def list_documents(
104:async def download_document(document_id: int, db: Session = Depends(get_db), document_service=Depends(get_document_service)):
126:async def update_document(
144:async def delete_document(document_id: int, db: Session = Depends(get_db), document_service=Depends(get_document_service)):
40:async def generate_agent(request: AgentGenerationRequest, agent_service=Depends(get_agent_service)):
117:async def refine_agent_description(request: AgentDescriptionRequest, db: Session = Depends(get_db)):
196:async def generate_agent_code(request: AgentCodeGenerationRequest, agent_service=Depends(get_agent_service)):
234:async def deploy_agent(request: AgentDeployRequest, db: Session = Depends(get_db)):
284:async def check_dana_syntax(request: DanaSyntaxCheckRequest):
307:async def validate_code(request: CodeValidationRequest):
330:async def fix_code(request: CodeFixRequest):
358:async def process_agent_documents(request: ProcessAgentDocumentsRequest, agent_service=Depends(get_agent_service)):
394:async def list_agents(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
418:async def get_agent(agent_id: int, db: Session = Depends(get_db)):
444:async def create_agent(agent: AgentCreate, db: Session = Depends(get_db)):
470:async def update_agent(agent_id: int, agent: AgentCreate, db: Session = Depends(get_db)):
503:async def delete_agent(agent_id: int, db: Session = Depends(get_db)):
525:async def generate_agent_from_prompt(
560:async def update_agent_description(agent_id: int, request: AgentDescriptionRequest, agent_service=Depends(get_agent_service)):
585:async def validate_agent_code(request: CodeValidationRequest):
599:async def fix_agent_code(request: CodeFixRequest):
613:async def upload_knowledge_file(
668:async def open_file(file_path: str):
681:def _extract_agent_info_from_code(dana_code: str) -> tuple[str | None, str | None]:
19:async def send_chat_message(request: ChatRequest, db: Session = Depends(get_db), chat_service=Depends(get_chat_service)):
19:async def create_topic(request: TopicCreate, db: Session = Depends(get_db), topic_service=Depends(get_topic_service)):
33:async def get_topic(topic_id: int, db: Session = Depends(get_db), topic_service=Depends(get_topic_service)):
49:async def list_topics(
63:async def update_topic(topic_id: int, topic_data: TopicCreate, db: Session = Depends(get_db), topic_service=Depends(get_topic_service)):
81:async def delete_topic(topic_id: int, db: Session = Depends(get_db), topic_service=Depends(get_topic_service)):
19:async def create_conversation(
33:async def get_conversation(
54:async def list_conversations(
72:async def update_conversation(
90:async def delete_conversation(conversation_id: int, db: Session = Depends(get_db), conversation_service=Depends(get_conversation_service)):
107:async def create_message(
121:async def list_messages(
139:async def get_message(
157:async def update_message(
179:async def delete_message(
16:def get_db():
49:async def generate_agent_na(request: AgentGeneratorNARequest):
148:def health():
26:def run_na_file(request: RunNAFileRequest):
31:async def write_multi_file_project(project: MultiFileProject):
77:async def write_multi_file_project_temp(project: MultiFileProject):
124:async def validate_multi_file_project(project: MultiFileProject):
174:            if "agent" in file_info.content.lower() and "def solve" not in file_info.content:
186:        def has_circular_deps(filename, visited=None, path=None):
228:async def open_agent_folder(request: dict):
263:async def get_task_status(task_id: str):
288:async def deep_train_agent(request: dict):
38:async def _llm_fallback(agent_name: str, agent_description: str, message: str) -> str:
109:async def test_agent(request: AgentTestRequest):
10:def health():
15:def get_root_info():
34:def serve_react_index():
12:def run_na_file_service(request: RunNAFileRequest):
23:async def lifespan(app: FastAPI):
31:def create_app():
86:    async def serve_spa(full_path: str):
119:    def startup(self) -> None:
137:    def shutdown(self) -> None:
155:    def get_client(self) -> APIClient:
163:    def local_mode(self) -> bool:
169:    def _load_config(self) -> None:
198:    def _normalize_service_uri(self) -> None:
221:    def _init_api_client(self) -> None:
229:    def _start_local_server(self) -> None:
284:    def _is_server_running(self, port: int) -> bool:
294:    def _find_free_port(self) -> int:
300:    def _wait_for_server_ready(self, port: int, timeout: int = 30) -> None:
319:    def _validate_remote_connection(self) -> None:
343:    def check_health(self) -> bool:
362:    def get_service_uri(self) -> str:
366:    def get_api_key(self) -> str:
9:def main() -> None:
6:def get_multi_file_agent_generation_prompt(intentions: str, current_code: str = "", has_docs_folder: bool = False) -> str:
42:def solve(self : RetrievalExpertAgent, query: str) -> str:
65:def search_document(package: RetrievalPackage) -> RetrievalPackage:
72:def refine_query(package: RetrievalPackage) -> RetrievalPackage:
77:def should_use_rag(package: RetrievalPackage) -> RetrievalPackage:
81:def get_answer(package: RetrievalPackage) -> str:
6:def generate_mock_agent_code(messages, current_code=""):
34:def solve(weather_agent : WeatherAgent, problem : str):
46:def solve(assistant_agent : AssistantAgent, problem : str):
62:def solve(data_agent : DataAgent, problem : str):
78:def solve(document_agent : DocumentAgent, problem : str):
94:def solve(email_agent : EmailAgent, problem : str):
110:def solve(knowledge_agent : KnowledgeAgent, problem : str):
122:def solve(custom_agent : CustomAgent, problem : str):
42:    def startup(self) -> None:
63:    def shutdown(self) -> None:
75:    def _ensure_started(self) -> None:
80:    def post(self, endpoint: str, data: dict[str, Any]) -> dict[str, Any]:
118:    def get(self, endpoint: str, params: dict[str, Any] | None = None) -> dict[str, Any]:
153:    def health_check(self) -> bool:
178:    def close(self):
193:def create_client(base_uri: str, api_key: str | None = None) -> APIClient:
24:    async def process_chat_message(self, chat_request: ChatRequest, db_session) -> ChatResponse:
81:    async def _get_or_create_conversation(self, chat_request: ChatRequest, db_session) -> Conversation:
102:    async def _save_message(self, conversation_id: int, sender: str, content: str, db_session) -> Message:
113:    async def _generate_agent_response(self, chat_request: ChatRequest, conversation: Conversation, db_session) -> str:
124:def get_chat_service() -> ChatService:
24:    async def create_conversation(self, conversation_data: ConversationCreate, db_session) -> ConversationRead:
54:    async def get_conversation(
110:    async def list_conversations(
144:    async def update_conversation_title(self, conversation_id: int, new_title: str, db_session) -> ConversationRead | None:
178:    async def update_conversation(self, conversation_id: int, conversation_data: ConversationCreate, db_session) -> ConversationRead | None:
213:    async def create_message(self, conversation_id: int, message_data: MessageCreate, db_session) -> MessageRead:
245:    async def list_messages(self, conversation_id: int, limit: int = 100, offset: int = 0, db_session=None) -> list[MessageRead]:
284:    async def get_message(self, conversation_id: int, message_id: int, db_session) -> MessageRead | None:
315:    async def update_message(self, conversation_id: int, message_id: int, message_data: MessageCreate, db_session) -> MessageRead | None:
352:    async def delete_message(self, conversation_id: int, message_id: int, db_session) -> bool:
378:    async def delete_conversation(self, conversation_id: int, db_session) -> bool:
408:    async def add_message(self, conversation_id: int, message_data: MessageCreate, db_session) -> MessageRead:
440:    async def get_conversation_messages(
486:def get_conversation_service() -> ConversationService:
34:    async def upload_document(
99:    async def get_document(self, document_id: int, db_session) -> DocumentRead | None:
131:    async def update_document(self, document_id: int, document_data: DocumentUpdate, db_session) -> DocumentRead | None:
178:    async def delete_document(self, document_id: int, db_session) -> bool:
210:    async def list_documents(
255:    async def get_file_path(self, document_id: int, db_session) -> str | None:
277:    def _get_mime_type(self, filename: str) -> str:
311:def get_document_service() -> DocumentService:
26:    async def create_topic(self, topic_data: TopicCreate, db_session) -> TopicRead:
58:    async def get_topic(self, topic_id: int, db_session) -> TopicRead | None:
83:    async def get_topic_by_name(self, name: str, db_session) -> TopicRead | None:
108:    async def list_topics(self, limit: int = 100, offset: int = 0, search: str | None = None, db_session=None) -> list[TopicRead]:
140:    async def update_topic(self, topic_id: int, topic_data: TopicCreate, db_session) -> TopicRead | None:
182:    async def delete_topic(self, topic_id: int, db_session) -> bool:
216:    async def get_topic_statistics(self, topic_id: int, db_session) -> dict[str, Any]:
255:def get_topic_service() -> TopicService:
13:    def clean_generated_code(code: str) -> str:
79:    def parse_multi_file_response(response: str) -> dict:
209:                if line.startswith("def "):
218:                    stub_lines.append(f"def {tool}(query: str) -> str:")
232:    def ensure_all_files_present(project: dict) -> dict:
258:    def get_file_template(filename: str) -> str:
268:def solve(self : Georgia, query: str) -> str:
282:def process_request(package: AgentPackage) -> AgentPackage:
287:def generate_response(package: AgentPackage) -> str:
316:    def determine_file_type(filename: str) -> str:
332:    def get_file_description(filename: str) -> str:
344:    def extract_dependencies(content: str) -> list[str]:
360:    def get_fallback_template() -> str:
369:def solve(basic_agent : BasicAgent, problem : str):
45:    async def initialize(self):
59:    async def generate_agent_code(
156:    async def generate_agent_files_from_prompt(
242:    async def analyze_agent_capabilities(
320:    async def analyze_conversation_completeness(self, messages: list[dict[str, Any]]) -> dict[str, Any]:
393:    async def cleanup(self):
400:    async def _extract_user_intentions(self, messages: list[dict[str, Any]], current_code: str = "") -> str:
442:    def _extract_requirements(self, messages: list[dict[str, Any]]) -> str:
452:    def _create_generation_prompt(self, intentions: str, current_code: str = "", multi_file: bool = False) -> str:
480:    def _create_phase_2_prompt(self, prompt: str, messages: list[dict[str, Any]], agent_summary: dict[str, Any], multi_file: bool) -> str:
505:    def _create_capabilities_analysis_prompt(self, conversation_text: str, all_code_content: str) -> str:
519:    def _extract_response_content(self, result) -> str:
533:    def _extract_summary_from_code_and_conversation(self, dana_code: str, conversation_text: str) -> str:
555:    def _extract_knowledge_domains_from_code(self, dana_code: str, conversation_text: str) -> list[str]:
562:    def _extract_workflow_steps_from_code(self, dana_code: str, conversation_text: str) -> list[str]:
571:    def _extract_agent_tools_from_code(self, dana_code: str) -> list[str]:
583:async def get_agent_service() -> AgentService:
599:def get_multi_file_agent_generation_prompt(intentions: str, current_code: str = "", has_docs_folder: bool = False) -> str:
635:def solve(self : RetrievalExpertAgent, query: str) -> str:
658:def search_document(package: RetrievalPackage) -> RetrievalPackage:
665:def refine_query(package: RetrievalPackage) -> RetrievalPackage:
670:def should_use_rag(package: RetrievalPackage) -> RetrievalPackage:
674:def get_answer(package: RetrievalPackage) -> str:
806:def generate_mock_agent_code(messages, current_code=""):
834:def solve(weather_agent : WeatherAgent, problem : str):
846:def solve(assistant_agent : AssistantAgent, problem : str):
862:def solve(data_agent : DataAgent, problem : str):
878:def solve(document_agent : DocumentAgent, problem : str):
894:def solve(email_agent : EmailAgent, problem : str):
910:def solve(knowledge_agent : KnowledgeAgent, problem : str):
922:def solve(custom_agent : CustomAgent, problem : str):
45:    async def initialize(self):
59:    async def generate_agent_code(
159:    async def _extract_user_intentions(self, messages: list[dict[str, Any]], current_code: str = "") -> str:
224:    def _extract_requirements(self, messages: list[dict[str, Any]]) -> str:
245:    def _create_generation_prompt(self, intentions: str, current_code: str = "", multi_file: bool = False) -> str:
293:def solve([agent_name] : [AgentName], problem : str):
341:def solve([agent_name] : [AgentName], problem : str):
362:    async def cleanup(self):
373:async def get_agent_generator() -> AgentGenerator:
391:async def generate_agent_code_from_messages(
416:async def generate_agent_code_na(messages: list[dict[str, Any]], current_code: str = "") -> tuple[str, str | None]:
492:def _create_agent_generator_na_code(messages: list[dict[str, Any]], current_code: str) -> str:
519:def extract_intentions(messages: list) -> str:
551:def generate_agent_code(messages: list, current_code: str) -> str:
574:- Function parameters must be unquoted: def solve(agent_name : AgentName, problem : str)
576:- **All function definitions (like def solve(...)) must be outside the agent block. The agent block should only contain attribute assignments.**
589:def solve([agent_name] : [AgentName], problem : str):
625:def _test_generated_code(code: str) -> Any:
665:async def _fix_generated_code_with_agent(code: str, error: str, messages: list[dict[str, Any]]) -> str:
722:def _create_code_fixer_na_code(code: str, error: str, messages: list[dict[str, Any]]) -> str:
754:def solve(code_fixer : CodeFixerAgent, problem : str):
776:- Function parameters must be unquoted: def solve(agent_name : AgentName, problem : str)
778:- **All function definitions (like def solve(...)) must be outside the agent block. The agent block should only contain attribute assignments.**
791:def solve([agent_name] : [AgentName], problem : str):
814:def _generate_simple_fallback_agent(messages: list[dict[str, Any]]) -> str:
883:def solve({agent_name.lower()} : {agent_name}, problem : str):
891:async def analyze_conversation_completeness(messages: list[dict[str, Any]]) -> dict[str, Any]:
988:async def analyze_agent_capabilities(
1119:def _extract_summary_from_code_and_conversation(dana_code: str, conversation_text: str) -> str:
1232:def _extract_knowledge_domains_from_code(dana_code: str, conversation_text: str) -> list[str]:
1292:def _extract_workflow_steps_from_code(dana_code: str, conversation_text: str) -> list[str]:
1361:def _extract_agent_tools_from_code(dana_code: str) -> list[str]:
1407:        if line.strip().startswith("def ") and "solve(" not in line:
1408:            func_name = line.strip().split("(")[0].replace("def ", "")
1482:def _extract_solve_function_content(dana_code: str) -> str:
1489:        if "def solve(" in line:
1501:def _extract_agent_name_from_code(dana_code: str) -> str:
1510:def _extract_agent_description_from_code(dana_code: str) -> str:
1519:def _get_fallback_template() -> str:
1534:def solve(basic_agent : BasicAgent, problem : str):
1543:async def generate_agent_files_from_prompt(
1658:def _create_phase_2_prompt(prompt: str, messages: list[dict[str, Any]], agent_summary: dict[str, Any], multi_file: bool) -> str:
1715:def solve(self : {agent_class}, query: str) -> str:
1729:def search_document(package: RetrievalPackage) -> RetrievalPackage:
1736:def refine_query(package: RetrievalPackage) -> RetrievalPackage:
1741:def should_use_rag(package: RetrievalPackage) -> RetrievalPackage:
1745:def get_answer(package: RetrievalPackage) -> str:
1940:def get_multi_file_agent_generation_prompt(intentions: str, current_code: str = "", has_docs_folder: bool = False) -> str:
1976:def solve(self : RetrievalExpertAgent, query: str) -> str:
1999:def search_document(package: RetrievalPackage) -> RetrievalPackage:
2006:def refine_query(package: RetrievalPackage) -> RetrievalPackage:
2011:def should_use_rag(package: RetrievalPackage) -> RetrievalPackage:
2015:def get_answer(package: RetrievalPackage) -> str:
2147:def generate_mock_agent_code(messages, current_code=""):
2175:def solve(weather_agent : WeatherAgent, problem : str):
2187:def solve(assistant_agent : AssistantAgent, problem : str):
2203:def solve(data_agent : DataAgent, problem : str):
2219:def solve(document_agent : DocumentAgent, problem : str):
2235:def solve(email_agent : EmailAgent, problem : str):
2251:def solve(knowledge_agent : KnowledgeAgent, problem : str):
2263:def solve(custom_agent : CustomAgent, problem : str):
42:    async def create_agent_description(
121:    async def generate_agent_code(self, agent_metadata: dict[str, Any], messages: list[dict[str, Any]], prompt: str = "") -> dict[str, Any]:
184:    async def upload_knowledge_file(
284:    async def update_agent_description(self, agent_metadata: dict[str, Any], messages: list[dict[str, Any]]) -> dict[str, Any]:
304:    def get_agent_folder(self, agent_id: int) -> Path | None:
319:    def _create_agent_folder(self, agent_id: int, agent_name: str) -> Path:
327:    async def _extract_agent_requirements(self, messages: list[dict[str, Any]]) -> dict[str, Any]:
472:    def _merge_agent_requirements(self, new_requirements: dict[str, Any], existing_data: dict[str, Any]) -> dict[str, Any]:
501:    async def _generate_intelligent_response(
512:    def _is_ready_for_code_generation(self, agent_requirements: dict[str, Any], conversation_analysis: dict[str, Any]) -> bool:
523:    async def _analyze_capabilities_for_description(self, messages: list[dict[str, Any]]) -> AgentCapabilities | None:
537:    async def _store_multi_file_project(
556:    def _create_multi_file_project_object(self, multi_file_project: dict[str, Any]) -> MultiFileProject:
577:    async def _update_tools_with_rag(self, agent_folder: Path):
598:    async def _clear_rag_cache(self, agent_folder: Path):
605:    async def _regenerate_agent_with_knowledge(
710:    async def _generate_consistent_summary_with_knowledge(
821:    async def _generate_llm_summary_with_knowledge(
985:    def _format_conversation_context(self, conversation_context: list[dict[str, Any]]) -> str:
994:    def _format_existing_capabilities(self, existing_capabilities: dict[str, Any]) -> str:
1024:    def _fallback_summary_enhancement(
1046:    def _merge_capabilities_with_knowledge(self, existing_capabilities: dict[str, Any], uploaded_filename: str) -> dict[str, Any]:
1112:    def _enhance_description_with_knowledge(self, existing_description: str, filename: str, requirements: dict[str, Any]) -> str:
1129:    def _enhance_capabilities_with_knowledge(self, existing_capabilities: Any, filename: str) -> dict[str, Any]:
1133:    def _generate_knowledge_follow_up(self, filename: str, requirements: dict[str, Any]) -> str:
1138:    async def _check_ready_for_code_generation(self, conversation_context: list[dict[str, Any]], agent_metadata: dict[str, Any]) -> bool:
1154:    async def _generate_upload_response(
1198:def get_agent_manager() -> AgentManager:
62:    def generate_enhanced_function(self, func_info: FunctionInfo) -> str:
83:    def generate_perceive(self, func_info: FunctionInfo) -> CodeBlock:
94:    def generate_operate(self, func_info: FunctionInfo) -> CodeBlock:
105:    def generate_enforce(self, func_info: FunctionInfo) -> CodeBlock:
116:    def generate_train(self, func_info: FunctionInfo) -> CodeBlock | None:
133:    def _generate_perceive(self, func_info: FunctionInfo) -> CodeBlock:
138:    def _generate_operate(self, func_info: FunctionInfo) -> CodeBlock:
143:    def _generate_enforce(self, func_info: FunctionInfo) -> CodeBlock:
147:    def _generate_train(self, func_info: FunctionInfo) -> CodeBlock | None:
151:    def _merge_code_blocks(self, parent: CodeBlock | None, child: CodeBlock | None, phase: str) -> CodeBlock:
184:    def _generate_orchestrator(
216:def enhanced_{func_info.name}{signature}:
295:    def _indent_code(self, code: str, spaces: int) -> str:
300:    def _extract_parameter_names(self, signature: str) -> list[str]:
329:    def _generate_perceive(self, func_info: FunctionInfo) -> CodeBlock:
341:    def _generate_operate(self, func_info: FunctionInfo) -> CodeBlock:
370:    def _generate_enforce(self, func_info: FunctionInfo) -> CodeBlock:
14:def poet(
37:        def diagnose(symptoms: list) -> dict:
49:        def assess_credit_risk(score: int) -> str:
86:    def dana_decorator(original_func: Any) -> Any:
92:        def poet_enhanced_function(*args, **kwargs):
249:def extract_poet_metadata(func: Any) -> dict[str, Any]:
31:    def dict(self) -> dict[str, Any]:
49:    def from_dict(cls, data: builtins.dict[str, Any]) -> "POETConfig":
63:    def from_response(cls, response_data: dict[str, Any]) -> "TranspiledFunction":
92:    def poet(self) -> dict[str, Any]:
197:    def unwrap(self) -> Any:
201:    def raw(self) -> Any:
21:def create_workflow_metadata(
42:        def ingest_document(file_path):
47:        def perform_ocr(document):
61:def create_pipeline_metadata(
104:def with_workflow_metadata(workflow_id: str | None = None, description: str | None = None, version: str = "1.0.0") -> Callable:
119:        def document_processing_workflow(input_data):
127:    def decorator(pipeline_func: Callable) -> Callable:
139:def auto_workflow_metadata(func: Callable) -> Callable:
156:        def ingest_document(file_path):
174:def build_workflow_metadata(*args, **kwargs) -> dict[str, Any]:
35:    def to_dict(self) -> dict[str, Any]:
66:    def extract_function_metadata(self, func: Callable) -> FunctionMetadata:
97:    def _extract_description_from_docstring(self, func: Callable) -> str:
123:    def _extract_poet_config(self, func: Callable) -> dict[str, Any]:
151:    def _extract_additional_params(self, poet_config: dict[str, Any]) -> dict[str, Any]:
185:def extract_workflow_metadata(
219:def extract_pipeline_metadata(pipeline_func: Callable) -> dict[str, Any]:
244:def _extract_functions_from_pipeline(pipeline_func: Callable) -> list[Callable]:
280:def with_metadata(func: Callable, **metadata) -> Callable:
295:def workflow_step(
312:    def decorator(func: Callable) -> Callable:
329:def _extract_first_line_docstring(func: Callable) -> str:
19:    def generate_dana_wrapper(self, function_name: str, config: POETConfig) -> str:
36:def poet_wrapper_{function_name}(*args, **kwargs):
85:    def enhance_function_definition(self, original_function_code: str, config: POETConfig) -> str:
29:    def enforce(self, output: Any, context: dict[str, Any], expected_type: type | None = None) -> Any:
55:    def _validate_output(self, output: Any, expected_type: type | None = None) -> None:
66:    def _enforce_domain_rules(self, output: Any, context: dict[str, Any]) -> None:
11:def financial_services(**kwargs) -> dict[str, Any]:
59:def healthcare(**kwargs) -> dict[str, Any]:
106:def retail_ecommerce(**kwargs) -> dict[str, Any]:
153:def data_processing(**kwargs) -> dict[str, Any]:
200:def security(**kwargs) -> dict[str, Any]:
248:def quick_setup(domain: str, **kwargs) -> dict[str, Any]:
274:def poet_for_domain(domain: str, **kwargs):
41:    def debug_perceive(self, *args, **kwargs) -> dict[str, Any]:
70:    def debug_operate(self, *args, **kwargs) -> dict[str, Any]:
106:    def debug_enforce(self, operation_result: Any) -> dict[str, Any]:
138:    def debug_train(self, operation_result: Any) -> dict[str, Any]:
165:    def debug_full_execution(self, *args, **kwargs) -> dict[str, Any]:
197:def debug_poet_function(func: Callable, config: POETConfig, *args, **kwargs) -> dict[str, Any]:
214:def test_poet_function(func: Callable, test_cases: list[dict[str, Any]], config: POETConfig | None = None) -> dict[str, Any]:
263:def performance_benchmark(func: Callable, iterations: int = 100, *args, **kwargs) -> dict[str, Any]:
30:    def operate(self, func: Callable, args: tuple[Any, ...], kwargs: dict[str, Any], context: dict[str, Any]) -> Any:
29:    def perceive(self, args: tuple[Any, ...], kwargs: dict[str, Any]) -> tuple[tuple[Any, ...], dict[str, Any], dict[str, Any]]:
60:    def _validate_inputs(self, args: tuple[Any, ...], kwargs: dict[str, Any]) -> None:
72:    def _process_domain_inputs(self, args: tuple[Any, ...], kwargs: dict[str, Any], context: dict[str, Any]) -> None:
29:    def train(
74:    def _track_performance(self, training_data: dict[str, Any], execution_time: float) -> None:
83:    def _domain_learning(
98:    def _basic_pattern_recognition(self, training_data: dict[str, Any], input_args: tuple[Any, ...], output: Any) -> None:
110:    def _financial_learning(self, training_data: dict[str, Any], input_args: tuple[Any, ...], output: Any) -> None:
118:    def _healthcare_learning(self, training_data: dict[str, Any], input_args: tuple[Any, ...], output: Any) -> None:
126:    def _data_processing_learning(self, training_data: dict[str, Any], input_args: tuple[Any, ...], output: Any) -> None:
22:    def register_ko_type(self, name: str, ko_class: type) -> None:
35:    def register_ko_config(self, name: str, config: dict[str, Any]) -> None:
45:    def get_ko_type(self, name: str) -> type:
63:    def get_ko_config(self, name: str) -> dict[str, Any]:
81:    def list_ko_types(self) -> list[str]:
89:    def list_ko_configs(self) -> list[str]:
97:    def create_ko_instance(self, name: str, **kwargs) -> Any:
98:    def load_document(self, source: str) -> Document:
103:    def validate_document(self, document: Document) -> bool:
112:    def process(self, input_data: Any) -> Any:
117:    def validate_input(self, input_data: Any) -> bool:
126:    def extract_knowledge(self, document: Document) -> list[KnowledgePoint]:
131:    def validate_knowledge(self, knowledge: KnowledgePoint) -> ValidationResult:
13:def _get_context_manager() -> ContextManager:
25:def _parse_context_type(context_type_str: str) -> ContextType:
58:def context_set(context_type: str, key: str, value: Any) -> bool:
78:def context_get(context_type: str, key: str, default: Any = None) -> Any:
97:def context_has(context_type: str, key: str) -> bool:
115:def context_remove(context_type: str, key: str) -> bool:
133:def context_clear(context_type: str) -> bool:
151:def context_clear_all() -> bool:
165:def context_sync(source_type: str, target_type: str, keys: list[str] | None = None) -> bool:
186:def context_keys(context_type: str) -> list[str]:
204:def context_size(context_type: str) -> int:
222:def context_info(context_type: str) -> dict[str, Any]:
239:def context_snapshot(context_type: str) -> dict[str, Any]:
256:def context_restore(context_type: str, snapshot: dict[str, Any]) -> bool:
275:def context_types() -> list[str]:
289:def context_metrics() -> dict[str, Any]:
305:def context_merge(source_type: str, target_type: str) -> bool:
318:def context_copy(source_type: str, target_type: str, keys: list[str]) -> bool:
332:def context_exists(context_type: str) -> bool:
350:def context_is_empty(context_type: str) -> bool:
365:def to_context_dict(context_type: str) -> dict[str, Any]:
383:def from_context_dict(context_type: str, data: dict[str, Any]) -> bool:
407:def context_validate_key(key: str) -> bool:
424:def context_validate_value(value: Any) -> bool:
444:def context_configure(settings_dict: dict[str, Any]) -> bool:
462:def context_reset() -> bool:
33:    def get_context(self, context_type: ContextType) -> Context:
51:    def set_context_value(self, context_type: ContextType, key: str, value: Any) -> None:
71:    def get_context_value(self, context_type: ContextType, key: str, default: Any = None) -> Any:
85:    def has_context_value(self, context_type: ContextType, key: str) -> bool:
98:    def remove_context_value(self, context_type: ContextType, key: str) -> bool:
116:    def clear_context(self, context_type: ContextType) -> None:
127:    def clear_all_contexts(self) -> None:
134:    def sync_contexts(self, source_type: ContextType, target_type: ContextType, keys: list[str] | None = None) -> None:
167:    def get_context_snapshot(self, context_type: ContextType) -> dict[str, Any]:
179:    def restore_context_snapshot(self, context_type: ContextType, snapshot: dict[str, Any]) -> None:
201:    def get_all_context_types(self) -> list[ContextType]:
210:    def get_context_info(self, context_type: ContextType) -> dict[str, Any]:
228:    def get_metrics(self) -> dict[str, Any]:
242:    def _validate_key(self, key: str) -> None:
257:    def _validate_value(self, value: Any) -> None:
277:    def _invalidate_cache(self, context_type: ContextType) -> None:
287:    def _cleanup_expired_cache(self) -> None:
48:    def set(self, key: str, value: Any) -> None:
64:    def get(self, key: str, default: Any = None) -> Any:
76:    def has(self, key: str) -> bool:
87:    def remove(self, key: str) -> bool:
102:    def clear(self) -> None:
107:    def keys(self) -> list[str]:
115:    def values(self) -> list[Any]:
123:    def items(self) -> list[tuple[str, Any]]:
131:    def size(self) -> int:
139:    def copy(self) -> "Context":
151:    def merge(self, other: "Context") -> None:
166:    def to_dict(self) -> dict[str, Any]:
180:    def from_dict(cls, data: dict[str, Any]) -> "Context":
25:def create_store(store_type: str, settings: dict[str, Any]) -> None:
56:def store_value(key: str, value: Any, store_type: str) -> None:
77:def retrieve_value(key: str, store_type: str) -> Any | None:
100:def delete_value(key: str, store_type: str) -> None:
120:def query_values(store_type: str, **kwargs) -> list[Any]:
143:def close_stores() -> None:
154:def get_store_types() -> dict[str, str]:
168:def get_active_stores() -> list[str]:
178:def convert_dana_to_python(value: Any) -> Any:
196:def convert_python_to_dana(value: Any) -> Any:
28:    def _create_connection(self) -> psycopg2.extensions.connection:
49:    def _ensure_extension(self) -> None:
62:    def _ensure_table(self) -> None:
82:    def _parse_vector(self, vector_data) -> list[float]:
100:    def _validate_key(self, key: str) -> None:
122:    def store(self, key: str, value: Any) -> None:
164:    def retrieve(self, key: str) -> dict[str, Any] | None:
195:    def delete(self, key: str) -> None:
220:    def query(self, **kwargs) -> list[Any]:
271:    def close(self) -> None:
27:    def _create_connection(self) -> psycopg2.extensions.connection:
48:    def _ensure_extension(self) -> None:
61:    def _ensure_table(self) -> None:
91:    def _validate_key(self, key: str) -> None:
113:    def store(self, key: str, value: Any) -> None:
160:    def retrieve(self, key: str, start_time: str | datetime | None = None, end_time: str | datetime | None = None) -> list[dict[str, Any]]:
209:    def delete(self, key: str) -> None:
234:    def query(self, **kwargs) -> list[Any]:
302:    def close(self) -> None:
25:    def _create_connection(self) -> psycopg2.extensions.connection:
46:    def _ensure_default_tables(self) -> None:
69:    def _ensure_table(self, table_name: str) -> None:
92:    def _validate_key(self, key: str) -> None:
115:    def store(self, key: str, value: Any) -> None:
154:    def retrieve(self, key: str) -> dict[str, Any] | None:
189:    def delete(self, key: str) -> None:
219:    def query(
267:    def close(self) -> None:
28:    def _create_client(self) -> redis.Redis:
52:    def _validate_key(self, key: str) -> None:
74:    def store(self, key: str, value: Any) -> None:
103:    def retrieve(self, key: str) -> Any | None:
131:    def delete(self, key: str) -> None:
156:    def query(self, pattern: str) -> list[Any]:
188:    def close(self) -> None:
12:    def store(self, key: str, value: Any) -> None:
16:    def retrieve(self, key: str) -> Any | None:
20:    def delete(self, key: str) -> None:
24:    def query(self, **kwargs) -> list[Any]:
30:    def process(self, parsed_doc: ParsedDocument) -> str:
69:    def validate_input(self, parsed_doc: ParsedDocument) -> bool:
92:    def _extract_from_text_document(self, parsed_doc: ParsedDocument) -> str:
149:    def _extract_from_json_document(self, parsed_doc: ParsedDocument) -> str:
182:    def _extract_from_csv_document(self, parsed_doc: ParsedDocument) -> str:
229:    def _extract_generic_text(self, parsed_doc: ParsedDocument) -> str:
253:    def _json_to_text(self, data: Any, indent: int = 0) -> list[str]:
285:    def _clean_text(self, text: str) -> str:
305:    def _format_metadata(self, metadata: dict[str, Any]) -> str:
22:    def process(self, document: Document) -> ParsedDocument:
63:    def validate_input(self, document: Document) -> bool:
86:    def _parse_text_document(self, document: Document) -> dict[str, Any]:
134:    def _parse_json_document(self, document: Document) -> dict[str, Any]:
164:    def _parse_csv_document(self, document: Document) -> dict[str, Any]:
197:    def _parse_generic_document(self, document: Document) -> dict[str, Any]:
221:    def _analyze_json_schema(self, data: Any, path: str = "") -> dict[str, Any]:
31:    def load_document(self, source: str) -> Document:
81:    def load_documents(self, sources: list[str]) -> list[Document]:
108:    def validate_document(self, document: Document) -> bool:
143:    def _load_content(self, source: str, format_ext: str) -> str:
164:    def _load_text_file(self, source: str) -> str:
169:    def _load_json_file(self, source: str) -> str:
175:    def _load_csv_file(self, source: str) -> str:
180:    def _load_pdf_file(self, source: str) -> str:
239:    def _generate_document_id(self, source: str) -> str:
68:    def process(self, knowledge_points: list[KnowledgePoint]) -> dict[str, Any]:
118:    def validate_input(self, knowledge_points: list[KnowledgePoint]) -> bool:
142:    def search_similar(self, query_point: KnowledgePoint, candidate_points: list[KnowledgePoint] | None = None) -> SimilarityResult:
195:    def _build_knowledge_index(self, knowledge_points: list[KnowledgePoint]) -> None:
204:    def _generate_content_vectors(self, knowledge_points: list[KnowledgePoint]) -> None:
216:    def _generate_content_vector(self, content: str) -> np.ndarray:
272:    def _calculate_vector_similarity(self, vector1: np.ndarray, vector2: np.ndarray) -> float:
300:    def _identify_matching_features(self, kp1: KnowledgePoint, kp2: KnowledgePoint) -> list[str]:
340:    def _find_similarities(self, knowledge_points: list[KnowledgePoint]) -> list[dict[str, Any]]:
378:    def _create_semantic_matches(self, similarity_mappings: list[dict[str, Any]]) -> list[SemanticMatch]:
406:    def _determine_match_type(self, matching_features: list[str]) -> str:
429:    def _generate_similarity_clusters(self, semantic_matches: list[SemanticMatch]) -> list[dict[str, Any]]:
465:    def _find_connected_points(self, start_id: str, semantic_matches: list[SemanticMatch]) -> set:
491:    def _calculate_cluster_similarity(self, cluster_ids: list[str], semantic_matches: list[SemanticMatch]) -> float:
508:    def _get_dominant_match_type(self, cluster_ids: list[str], semantic_matches: list[SemanticMatch]) -> str:
531:    def _calculate_search_confidence(self, similarities: list[dict[str, Any]]) -> float:
552:    def _get_vector_dimensions(self) -> int:
150:    def process(self, knowledge_points: list[KnowledgePoint]) -> dict[str, Any]:
204:    def validate_input(self, knowledge_points: list[KnowledgePoint]) -> bool:
228:    def expand_context(self, knowledge_point: KnowledgePoint) -> list[ContextExpansion]:
271:    def validate_context(self, knowledge_point: KnowledgePoint) -> ContextValidation:
310:    def _parse_expansion_response(self, response: BaseResponse, source_id: str) -> list[ContextExpansion]:
363:    def _parse_validation_response(self, response: BaseResponse, context_id: str) -> ContextValidation:
434:    def _rule_based_expansion(self, knowledge_point: KnowledgePoint) -> list[ContextExpansion]:
501:    def _rule_based_validation(self, knowledge_point: KnowledgePoint) -> ContextValidation:
562:    def _assess_response_quality(self, expansion_data: dict[str, Any]) -> float:
593:    def _create_context_relationships(
641:    def _generate_context_summary(self, expansions: list[ContextExpansion], validations: list[ContextValidation]) -> dict[str, Any]:
675:    def _calculate_average_confidence(self, expansions: list[ContextExpansion]) -> float:
689:    def _calculate_average_validation_score(self, validations: list[ContextValidation]) -> float:
703:    def _calculate_validation_pass_rate(self, validations: list[ContextValidation]) -> float:
718:    def _get_common_issues(self, validations: list[ContextValidation]) -> list[str]:
41:    def process(self, document: Document) -> list[KnowledgePoint]:
77:    def validate_input(self, document: Document) -> bool:
99:    def _extract_with_llm(self, document: Document) -> list[KnowledgePoint]:
146:    def _build_extraction_prompt(self, document: Document) -> str:
191:    def _extract_response_text(self, response_content: Any) -> str:
258:    def _parse_llm_response(self, response: str, document: Document) -> list[KnowledgePoint]:
310:    def _create_knowledge_point(self, data: dict[str, Any], document: Document) -> KnowledgePoint | None:
357:    def _fallback_extraction(self, document: Document) -> list[KnowledgePoint]:
400:    def _is_potentially_important(self, sentence: str) -> bool:
442:    def _generate_knowledge_point_id(self) -> str:
450:    def _get_timestamp(self) -> str:
108:    def process(self, knowledge_points: list[KnowledgePoint]) -> dict[str, Any]:
166:    def validate_input(self, knowledge_points: list[KnowledgePoint]) -> bool:
190:    def _categorize_knowledge_point(self, knowledge_point: KnowledgePoint) -> list[dict[str, Any]]:
245:    def _calculate_keyword_similarity(self, text: str, keywords: list[str]) -> float:
272:    def _determine_relationship_type(self, similarity_score: float) -> str:
288:    def _map_knowledge_point_relationships(self, knowledge_points: list[KnowledgePoint]) -> list[dict[str, Any]]:
329:    def _calculate_content_similarity(self, content1: str, content2: str) -> float:
351:    def _have_contextual_relationship(self, kp1: KnowledgePoint, kp2: KnowledgePoint) -> bool:
378:    def _find_shared_context(self, kp1: KnowledgePoint, kp2: KnowledgePoint) -> dict[str, Any]:
398:    def _build_category_hierarchy(self) -> dict[str, Any]:
422:    def _generate_categorization_summary(
15:    def extract_text(self, content: str) -> str:
19:    def extract_metadata(self, content: str) -> dict[str, Any]:
15:    def parse(self, content: str) -> dict[str, Any]:
19:    def parse_batch(self, contents: list[str]) -> list[dict[str, Any]]:
15:    def load(self, source: str) -> str:
20:    def load_batch(self, sources: list[str]) -> list[str]:
91:    def execute(self, input_data: Any, context: Any = None) -> Any:
131:    def _create_step_context(self, input_data: Any, context: Any = None) -> StepExecutionContext:
156:    def _validate_pre_conditions(self, input_data: Any, context: StepExecutionContext) -> None:
166:    def _validate_post_conditions(self, result: Any, context: StepExecutionContext) -> None:
176:    def _execute_function(self, input_data: Any, context: StepExecutionContext) -> Any:
180:        def _timeout_handler(signum, frame):
217:        def composed_function(input_data: Any) -> Any:
232:    def clone(self, **overrides) -> "WorkflowStep":
255:    def from_function(
279:        def decorator(func: Callable) -> "WorkflowStep":
39:    def add_context(self, key: str, value: Any) -> None:
43:    def get_context(self, key: str, default: Any = None) -> Any:
72:    def execute(
132:    def _validate_workflow(self, workflow: Any) -> None:
140:    def _execute_step_list(self, steps: list[WorkflowStep], input_data: Any, context: WorkflowExecutionContext) -> Any:
177:    def _execute_composed_function(self, composed_func: Callable, input_data: Any, context: WorkflowExecutionContext) -> Any:
189:    def _post_execution_processing(self, context: WorkflowExecutionContext, result: Any) -> None:
201:    def _handle_execution_error(self, context: WorkflowExecutionContext, error: Exception) -> None:
220:    def create_workflow_step(
65:    def validate_workflow(self, workflow: Any, context: Any = None) -> SafetyResult:
103:    def validate_step(self, step: Any, context: Any = None) -> SafetyResult:
169:    def add_validation_rule(self, name: str, rule: Callable) -> None:
180:    def remove_validation_rule(self, name: str) -> bool:
196:    def _register_default_rules(self) -> None:
203:    def _validate_step_list(self, steps: list, context: Any = None) -> SafetyResult:
249:    def _validate_composed_function(self, func: Callable, context: Any = None) -> SafetyResult:
285:    def _validate_function(self, func: Callable, name: str) -> SafetyResult:
316:    def _check_dangerous_operations(self, func: Callable, name: str) -> SafetyResult:
355:    def _is_workflow_list(self, workflow: Any) -> bool:
359:    def _rule_basic_structure(self, workflow: Any, context: Any = None) -> SafetyResult:
368:    def _rule_no_infinite_recursion(self, workflow: Any, context: Any = None) -> SafetyResult:
382:    def _rule_reasonable_complexity(self, workflow: Any, context: Any = None) -> SafetyResult:
400:    def get_validation_summary(self) -> dict[str, Any]:
72:    def add_knowledge(self, content: str, source: str, tags: list[str] | None = None, metadata: dict[str, Any] | None = None) -> str:
106:    def get_knowledge(self, knowledge_id: str) -> KnowledgePoint | None:
118:    def find_by_tag(self, tag: str) -> list[KnowledgePoint]:
131:    def search_knowledge(
166:    def create_context_snapshot(self, metadata: dict[str, Any] | None = None) -> str:
186:    def get_context_snapshot(self, snapshot_id: str) -> ContextSnapshot | None:
198:    def clear_knowledge(self, source: str | None = None) -> int:
231:    def get_stats(self) -> dict[str, Any]:
250:    def _enforce_limit(self) -> None:
264:    def export_knowledge(self, source: str | None = None) -> dict[str, Any]:
291:    def import_knowledge(self, data: dict[str, Any]) -> int:
40:    def search(self, query: str, candidates: list[str]) -> SimilarityResult:
50:    def validate_input(self, knowledge_points: list[Any]) -> bool:
36:    def expand(self, context: dict[str, Any], knowledge_base: list[Any]) -> ContextExpansion:
41:    def validate(self, context: dict[str, Any]) -> ContextValidation:
15:    def extract(self, content: str) -> dict[str, Any]:
20:    def extract_batch(self, contents: list[str]) -> list[dict[str, Any]]:
34:    def categorize(self, content: str) -> list[KnowledgeCategory]:
39:    def find_relationships(self, categories: list[KnowledgeCategory]) -> list[CategoryRelationship]:
15:    def search(self, query: str, candidates: list[str]) -> list[str]:
20:    def rank(self, query: str, candidates: list[str]) -> list[tuple[str, float]]:
34:    def expand(self, context: str, knowledge_base: list[str]) -> list[str]:
44:    def to_dict(self) -> dict[str, any]:
62:def create_dana_exception(exc: Exception, error_context=None) -> DanaException:
42:    def find_spec(self, fullname: str, path: Sequence[str | bytes] | None = None, target: Module | None = None) -> PyModuleSpec | None:
67:    def _find_spec_with_context(self, fullname: str, importing_module_path: str | None = None) -> PyModuleSpec | None:
300:    def _setup_package_attributes(self, spec: ModuleSpec) -> None:
333:    def create_module(self, spec: PyModuleSpec) -> Module | None:
375:    def exec_module(self, module: Module) -> None:
473:    def _setup_module_function_context(self, module: Module, interpreter: DanaInterpreter, context: SandboxContext) -> None:
516:    def _find_module_in_directory(self, module_name: str, directory: Path) -> Path | None:
538:    def _find_module_file(self, module_name: str) -> Path | None:
75:def show_help():
98:def execute_file(file_path, debug=False):
147:async def start_repl(debug=False):
168:def handle_start_command(args):
214:def handle_init_command(args):
251:    def greet(self, name):
309:def handle_new_command(args):
324:    def process(self, data):
330:    def analyze(self, input_data):
359:def handle_serve_command(args):
389:def main():
525:def handle_main_command():
571:def handle_deploy_command(args):
598:def handle_config_command(args):
627:def deploy_thru_mcp(file_path, args):
644:def deploy_thru_a2a(file_path, args):
657:def configure_debug_logging():
664:def validate_na_file(file_path):
114:    def run_configuration_wizard(self) -> bool:
160:    def _select_providers(self) -> list[str]:
210:    def _configure_provider(self, provider_key: str) -> dict[str, str] | None:
262:    def _write_env_file(self, env_vars: dict[str, str]):
299:    def validate_configuration(self) -> bool:
355:    def _load_env_file(self):
11:def validate_agent_module(na_file_path: str, na_module):
59:def make_agent_class(agent_name: str, agent_description: str, entry_func: Callable):
77:        def solve_query(self, query: str) -> str:
85:        def handle_task(self, task):
103:def color_text(text, color_code):
107:def print_a2a_server_banner(host, port, agent_name, agent_description):
129:def deploy_dana_agents_thru_a2a(na_file_path, host, port):
8:def validate_agent_module(na_file_path: str, na_module):
48:def create_mcp_server_for_file(na_file_path):
68:        def solve(query: str) -> str:
84:def color_text(text, color_code):
88:def print_mcp_server_banner(host, port, agent_name):
110:def deploy_dana_agents_thru_mcp(na_file_path, host, port):
142:    async def lifespan(app: FastAPI):
52:    def detect_assignment_context(self, assignment_node: Assignment) -> TypeContext | None:
84:    def detect_function_call_context(self, func_call_node: FunctionCall) -> TypeContext | None:
143:    def detect_function_parameter_context(self, param_name: str, param_type: str) -> TypeContext:
163:    def detect_conditional_context(self, condition_node: Any) -> TypeContext:
182:    def infer_context_from_usage(self, variable_name: str, usage_context: str) -> TypeContext | None:
215:    def get_cached_context(self, cache_key: str) -> TypeContext | None:
226:    def cache_context(self, cache_key: str, context: TypeContext) -> None:
236:    def clear_cache(self) -> None:
241:    def get_cache_size(self) -> int:
245:    def detect_current_context(self, context: Any) -> TypeContext | None:
293:    def _infer_from_execution_context(self, context: Any) -> TypeContext | None:
346:    def analyze_assignment_chain(self, assignments: list[Assignment]) -> list[TypeContext]:
365:    def find_strongest_context(self, contexts: list[TypeContext]) -> TypeContext | None:
381:    def merge_contexts(self, contexts: list[TypeContext]) -> TypeContext | None:
431:def detect_assignment_context(assignment_node: Assignment) -> TypeContext | None:
437:def detect_conditional_context(condition_node: Any) -> TypeContext:
443:def analyze_contexts(assignments: list[Assignment]) -> list[TypeContext]:
55:    def push_location(self, location: ExecutionLocation) -> None:
60:    def pop_location(self) -> ExecutionLocation | None:
68:    def set_file(self, filename: str | Path) -> None:
73:    def load_source(self, filename: str) -> list[str] | None:
87:    def get_source_line(self, filename: str, line_num: int) -> str | None:
94:    def format_stack_trace(self) -> str:
48:def _patched_format_user_error(e, user_input=None):
87:    def _init_function_registry(self):
108:    def function_registry(self) -> FunctionRegistry:
122:    def _run(self, file_path: str | Path, source_code: str, context: SandboxContext) -> Any:
136:    def _eval(self, source_code: str, context: SandboxContext, filename: str | None = None) -> Any:
155:    def _execute(self, ast: Program, context: SandboxContext) -> Any:
192:    def evaluate_expression(self, expression: Any, context: SandboxContext) -> Any:
204:    def execute_program(self, program: Program, context: SandboxContext) -> Any:
217:    def execute_statement(self, statement: Any, context: SandboxContext) -> Any:
230:    def get_and_clear_output(self) -> str:
234:    def get_evaluated(self, key: str, context: SandboxContext) -> Any:
250:    def call_function(
278:    def evaluate_ast(self, ast: Program, context: SandboxContext) -> Any:
294:    def _process_function_definition(self, func_def: FunctionDefinition, context: SandboxContext) -> None:
325:    def _create_dana_function(self, func_def: FunctionDefinition, context: SandboxContext, register: bool = True):
339:        def dana_function(*args, **kwargs):
362:    def _bind_function_parameters(self, parameters: list, args: tuple, kwargs: dict, context: SandboxContext) -> None:
376:    def _register_function_normally(self, func_def: FunctionDefinition, context: SandboxContext) -> None:
381:    def is_repl_mode(self) -> bool:
18:    def format_error(error: Exception, error_context: ErrorContext | None = None, show_traceback: bool = True) -> str:
86:    def format_developer_error(error: Exception, error_context: ErrorContext | None = None, show_traceback: bool = True) -> str:
164:    def format_simple_error(error: Exception, filename: str | None = None) -> str:
36:    def _build_boolean_patterns(self) -> dict[str, bool]:
87:    def _build_numeric_patterns(self) -> dict[str, re.Pattern]:
97:    def coerce_to_bool(self, value: Any, context: str | None = None) -> bool:
126:    def _coerce_string_to_bool(self, text: str) -> bool:
160:    def _is_zero_equivalent(self, text: str) -> bool:
165:    def _is_positive_numeric(self, text: str) -> bool:
173:    def _apply_contextual_boolean_logic(self, text: str) -> bool | None:
192:    def coerce_value(self, value: Any, target_type: str, context: str | None = None) -> Any:
237:    def _coerce_to_dict(self, value: Any, context: str | None = None) -> dict:
278:    def _coerce_to_list(self, value: Any, context: str | None = None) -> list:
319:    def _extract_final_answer(self, text: str) -> str:
338:    def _try_coerce_to_struct(self, value: Any, target_type: str, context: str | None = None) -> Any | None:
396:    def _coerce_string_to_struct(self, text: str, target_type: str, context: str | None = None) -> Any:
440:    def _coerce_dict_to_struct(self, data: dict, target_type: str, context: str | None = None) -> Any:
466:    def _clean_json_string(self, value: str) -> str:
487:    def test_semantic_equivalence(self, left: Any, right: Any) -> bool:
513:def coerce_value(value: Any, target_type: str, context: str | None = None) -> Any:
518:def semantic_bool(value: Any) -> bool:
523:def semantic_equals(left: Any, right: Any) -> bool:
49:    def prepare_context(self, context: SandboxContext | Any, args: list[Any], kwargs: dict[str, Any]) -> SandboxContext:
108:    def restore_context(self, context: SandboxContext, original_context: SandboxContext) -> None:
121:    def execute(self, context: Any, *args: Any, **kwargs: Any) -> Any:
56:    def prepare_context(self, context: SandboxContext, args: list[Any], kwargs: dict[str, Any]) -> SandboxContext:
73:    def restore_context(self, context: SandboxContext, original_context: SandboxContext) -> None:
86:    def execute(self, context: SandboxContext, *args: Any, **kwargs: Any) -> Any:
108:    def _resolve_function(self, func: SandboxFunction | str | Callable, context: SandboxContext) -> SandboxFunction:
167:    def _wrap_callable(self, func: callable, func_name: str, context: SandboxContext) -> SandboxFunction:
185:            def execute(self, context: SandboxContext, *args, **kwargs):
208:            def restore_context(self, context: SandboxContext, original_context: SandboxContext) -> None:
81:    def register_handlers(self):
102:    def execute_assignment(self, node: Assignment, context: SandboxContext) -> Any:
114:    def execute_compound_assignment(self, node: CompoundAssignment, context: SandboxContext) -> Any:
126:    def execute_assert_statement(self, node: AssertStatement, context: SandboxContext) -> None:
141:    def _execute_python_import(self, module_name: str, context_name: str, context: SandboxContext) -> None:
168:    def _execute_dana_import(self, module_name: str, context_name: str, context: SandboxContext) -> None:
210:    def _execute_python_from_import(self, module_name: str, names: list[tuple[str, str | None]], context: SandboxContext) -> None:
253:    def _execute_dana_from_import(self, module_name: str, names: list[tuple[str, str | None]], context: SandboxContext) -> None:
315:    def _register_imported_function(self, func: callable, context_name: str, module_name: str, original_name: str) -> None:
385:    def execute_import_statement(self, node: ImportStatement, context: SandboxContext) -> Any:
397:    def execute_import_from_statement(self, node: ImportFromStatement, context: SandboxContext) -> Any:
409:    def execute_pass_statement(self, node: PassStatement, context: SandboxContext) -> None:
421:    def execute_raise_statement(self, node: RaiseStatement, context: SandboxContext) -> None:
436:    def execute_use_statement(self, node: UseStatement, context: SandboxContext) -> Any:
448:    def execute_export_statement(self, node: ExportStatement, context: SandboxContext) -> None:
460:    def execute_struct_definition(self, node: StructDefinition, context: SandboxContext) -> None:
472:    def execute_agent_definition(self, node: AgentDefinition, context: SandboxContext) -> None:
484:    def execute_agent_statement(self, node: AgentStatement, context: SandboxContext) -> Any:
496:    def execute_agent_pool_statement(self, node: AgentPoolStatement, context: SandboxContext) -> Any:
508:    def execute_function_definition(self, node: "FunctionDefinition", context: SandboxContext) -> Any:
523:    def execute_method_definition(self, node: "MethodDefinition", context: SandboxContext) -> Any:
541:            func_def = FunctionDefinition(
551:    def execute_declarative_function_definition(self, node: "DeclarativeFunctionDefinition", context: SandboxContext) -> Any:
570:        def create_declarative_function():
571:            def wrapper(*args, **kwargs):
615:    def _bind_declarative_function_parameters(self, parameters: list, args: tuple, kwargs: dict, func_context: SandboxContext) -> None:
674:    def _execute_composition(self, composition, func_context: SandboxContext, args: tuple) -> Any:
698:    def _extract_annotations(self, parameters: list, return_type) -> dict[str, type]:
720:    def _map_dana_type_to_python(self, dana_type: str) -> type:
745:    def _create_signature(self, parameters: list, return_type):
68:    def register_handlers(self):
76:    def execute_function_definition(self, node: FunctionDefinition, context: SandboxContext) -> Any:
142:    def execute_method_definition(self, node: MethodDefinition, context: SandboxContext) -> Any:
216:    def _apply_decorators(self, func, decorators, context):
244:    def _evaluate_expression(self, expr, context):
255:    def _resolve_decorator(self, decorator, context):
287:    def _ensure_fully_evaluated(self, value: Any, context: SandboxContext) -> Any:
309:    def execute_function_call(self, node: FunctionCall, context: SandboxContext) -> Any:
517:    def _get_current_function_context(self, context: SandboxContext) -> str | None:
555:    def _assign_and_coerce_result(self, raw_result: Any, function_name: str) -> Any:
573:    def _apply_function_result_coercion(self, result: Any, function_name: str) -> Any:
604:    def _execute_user_defined_function(self, func_data: dict[str, Any], args: list[Any], context: SandboxContext) -> Any:
42:    def execute_agent_statement(self, node: AgentStatement, context: SandboxContext) -> Any:
87:    def execute_agent_pool_statement(self, node: AgentPoolStatement, context: SandboxContext) -> Any:
132:    def execute_use_statement(self, node: UseStatement, context: SandboxContext) -> Any:
169:    def execute_export_statement(self, node: ExportStatement, context: SandboxContext) -> None:
200:    def execute_struct_definition(self, node: StructDefinition, context: SandboxContext) -> None:
235:            def struct_constructor(**kwargs):
248:    def execute_agent_definition(self, node: AgentDefinition, context: SandboxContext) -> None:
273:            def agent_constructor(**kwargs):
288:    def execute_function_definition(self, node: FunctionDefinition, context: SandboxContext) -> Any:
352:    def _apply_decorators(self, func, decorators, context):
380:    def _resolve_decorator(self, decorator, context):
390:    def _trace_resource_operation(self, operation_type: str, resource_name: str, arg_count: int, kwarg_count: int) -> None:
406:    def get_stats(self) -> dict[str, Any]:
56:    def execute_import_statement(self, node: ImportStatement, context: SandboxContext) -> Any:
93:    def execute_import_from_statement(self, node: ImportFromStatement, context: SandboxContext) -> Any:
123:    def _execute_python_import(self, module_name: str, context_name: str, context: SandboxContext) -> None:
157:    def _execute_dana_import(self, module_name: str, context_name: str, context: SandboxContext) -> None:
229:    def _execute_python_from_import(self, module_name: str, names: list[tuple[str, str | None]], context: SandboxContext) -> None:
276:    def _execute_dana_from_import(self, module_name: str, names: list[tuple[str, str | None]], context: SandboxContext) -> None:
364:    def _register_imported_function(self, func: callable, context_name: str, module_name: str, original_name: str) -> None:
402:    def _ensure_module_system_initialized(self) -> None:
418:    def _create_parent_namespaces(self, context_name: str, module: Any, context: SandboxContext) -> None:
480:    def _resolve_relative_import(self, module_name: str, context: SandboxContext) -> str:
557:    def _trace_import(self, import_type: str, module_name: str, context_info: str) -> None:
572:    def clear_cache(self) -> None:
581:    def get_cache_stats(self) -> dict[str, Any]:
49:    def execute_assignment(self, node: Assignment, context: SandboxContext) -> Any:
89:    def execute_compound_assignment(self, node: CompoundAssignment, context: SandboxContext) -> Any:
167:    def _process_type_hint(self, node: Assignment, context: SandboxContext) -> type | None:
212:    def _apply_type_coercion(self, value: Any, target_type: type | str, target_node: Any) -> Any:
263:    def _execute_assignment_by_target(self, target: Any, value: Any, context: SandboxContext) -> None:
287:    def _execute_subscript_assignment(self, target: SubscriptExpression, value: Any, context: SandboxContext) -> None:
320:    def _execute_slice_assignment(self, target_obj: Any, slice_expr: Any, value: Any, context: SandboxContext) -> None:
342:    def _execute_multidim_slice_assignment(self, target_obj: Any, slice_tuple: Any, value: Any, context: SandboxContext) -> None:
376:    def _execute_attribute_assignment(self, target: AttributeAccess, value: Any, context: SandboxContext) -> None:
397:    def _get_assignment_target_name(self, target: Any) -> str:
417:    def _trace_assignment(self, target: Any, value: Any) -> None:
433:    def clear_cache(self) -> None:
438:    def get_cache_stats(self) -> dict[str, Any]:
73:    def parse_function_name(self, func_name: str) -> FunctionNameInfo:
103:    def resolve_function(self, name_info: FunctionNameInfo, context: SandboxContext, registry: Any) -> ResolvedFunction | None:
133:    def _resolve_from_context_hierarchy(self, name_info: FunctionNameInfo, context: SandboxContext) -> ResolvedFunction | None:
175:    def _create_resolved_function_from_context(self, func_data: Any, name_info: FunctionNameInfo) -> ResolvedFunction:
218:    def _resolve_from_context(self, name_info: FunctionNameInfo, context: SandboxContext) -> ResolvedFunction | None:
252:    def _resolve_from_registry(self, name_info: FunctionNameInfo, registry: Any) -> ResolvedFunction | None:
289:    def execute_resolved_function(
321:    def list_available_functions(self, namespace: str | None = None) -> list[str]:
85:    def _register_all_handlers(self):
99:    def execute(self, node: Any, context: SandboxContext) -> Any:
146:    def _execute_hook(
168:    def get_and_clear_output(self) -> str:
178:    def extract_value(self, node: Any) -> Any:
197:    def configure_optimizations(self, **kwargs) -> None:
206:    def get_optimization_statistics(self) -> dict[str, Any] | None:
216:    def log_optimization_report(self) -> None:
223:    def clear_optimization_caches(self) -> None:
228:    def is_optimization_healthy(self) -> bool:
238:    def execute_with_location_context(self, method: Callable, node: Any, context: SandboxContext) -> Any:
22:    def track_execution(self, node_description: str):
38:    def check_depth_safety(self) -> None:
51:    def get_statistics(self) -> dict[str, Any]:
62:    def reset_statistics(self) -> None:
75:    def visit_node(self, node: Any):
95:    def get_current_path(self) -> list[str]:
99:    def clear(self) -> None:
100:    def register_handlers(self):
121:    def execute_literal_expression(self, node: LiteralExpression, context: SandboxContext) -> Any:
137:    def execute_identifier(self, node: Identifier, context: SandboxContext) -> Any:
150:    def execute_binary_expression(self, node: BinaryExpression, context: SandboxContext) -> Any:
170:    def execute_unary_expression(self, node: UnaryExpression, context: SandboxContext) -> Any:
191:    def execute_tuple_literal(self, node: TupleLiteral, context: SandboxContext) -> tuple:
203:    def execute_dict_literal(self, node: DictLiteral, context: SandboxContext) -> dict:
215:    def execute_set_literal(self, node: SetLiteral, context: SandboxContext) -> set:
227:    def execute_fstring_expression(self, node: FStringExpression, context: SandboxContext) -> str:
239:    def execute_attribute_access(self, node: AttributeAccess, context: SandboxContext) -> Any:
308:    def run_function(self, func: Callable, *args, **kwargs) -> Any:
314:    def execute_object_function_call(self, node: Any, context: SandboxContext) -> Any:
428:    def execute_subscript_expression(self, node: SubscriptExpression, context: SandboxContext) -> Any:
475:    def _execute_slice(self, target: Any, slice_expr: Any, context: SandboxContext) -> Any:
507:    def _evaluate_slice_components(self, slice_expr: Any, context: SandboxContext) -> dict[str, Any]:
548:    def _validate_slice_operation(self, target: Any, components: dict[str, Any]) -> None:
576:    def _validate_sequence_slice_bounds(self, components: dict[str, Any], length: int) -> None:
609:    def _execute_validated_slice(self, target: Any, components: dict[str, Any]) -> Any:
651:    def _execute_slice_tuple(self, target: Any, slice_tuple: Any, context: SandboxContext) -> Any:
702:    def _get_safe_length(self, obj: Any) -> str:
716:    def execute_list_literal(self, node: ListLiteral, context: SandboxContext) -> list:
728:    def execute_named_pipeline_stage(self, node: NamedPipelineStage, context: SandboxContext) -> Any:
743:    def execute_placeholder_expression(self, node: PlaceholderExpression, context: SandboxContext) -> Any:
758:    def _resolve_pipeline_function(self, identifier: Identifier, context: SandboxContext) -> Any:
789:    def execute_pipeline_expression(self, node: PipelineExpression, context: SandboxContext) -> Any:
801:            def identity_function(initial_value):
807:        def composed_function(initial_value):
821:    def execute_function_call(self, node: FunctionCall, context: SandboxContext) -> Any:
843:    def _has_placeholders(self, node: FunctionCall) -> bool:
868:    def _execute_pipeline_stage(self, current_value: Any, stage: Any, context: SandboxContext) -> Any:
921:                    def error_function(value):
972:    def _execute_function_call_stage(self, current_value: Any, func_call: FunctionCall, context: SandboxContext) -> Any:
1029:    def _contains_placeholder(self, expr: Any) -> bool:
52:    def execute_try_block(self, node: TryBlock, context: SandboxContext) -> Any:
162:    def _execute_statement_list(self, statements: list[Any], context: SandboxContext) -> Any:
187:    def _add_exception_trace(self, block_type: str, exception_type: str, action: str) -> None:
208:    def clear_cache(self) -> None:
215:    def get_performance_stats(self) -> dict[str, Any]:
232:    def get_exception_traces(self) -> list[dict[str, Any]]:
240:    def _matches_exception(self, exception: Exception, except_block: ExceptBlock, context: SandboxContext) -> bool:
51:    def resolve_identifier(self, node: Identifier, context: SandboxContext) -> Any:
125:    def _try_direct_context_lookup(self, name: str, context: SandboxContext) -> Any | None:
136:    def _try_cross_scope_search(self, name: str, context: SandboxContext) -> Any | None:
151:    def _try_scoped_resolution(self, name: str, context: SandboxContext) -> Any | None:
163:    def _resolve_colon_notation(self, name: str, context: SandboxContext) -> Any | None:
190:    def _resolve_dot_notation(self, name: str, context: SandboxContext) -> Any | None:
218:    def _try_fallback_scope_search(self, var_name: str, specified_scope: str, context: SandboxContext) -> Any | None:
231:    def _resolve_scoped_attribute_access(self, var_name: str, scope_name: str, context: SandboxContext) -> Any | None:
255:    def _access_attribute_path(self, base_value: Any, attribute_path: str) -> Any:
262:    def _try_function_registry_resolution(self, name: str, context: SandboxContext) -> Any | None:
310:    def _create_registry_wrapper(self, name: str, resolved_func: Any, context: SandboxContext) -> Any:
313:        def registry_function(*args, **kwargs):
324:    def _try_dotted_attribute_access(self, name: str, context: SandboxContext) -> Any | None:
364:    def _try_struct_type_resolution(self, name: str) -> Any | None:
389:    def _cache_result(self, cache_key: tuple, result: Any) -> None:
399:    def clear_cache(self) -> None:
406:    def get_cache_stats(self) -> dict[str, int | float]:
41:    def execute(self, context: SandboxContext, *args, **kwargs) -> list[Any]:
61:    def restore_context(self, context: SandboxContext, original_context: SandboxContext) -> None:
66:    def _call_function(self, func: Any, context: SandboxContext, *args, **kwargs) -> Any:
113:    def execute(self, context: SandboxContext, *args, **kwargs) -> Any:
136:    def restore_context(self, context: SandboxContext, original_context: SandboxContext) -> None:
153:    def execute_pipe(self, left: Any, right: Any, context: SandboxContext) -> Any:
184:    def _unwrap_named_stage(self, expr: Any) -> Any:
201:    def _has_named_stages(self, expr: Any) -> bool:
216:    def _create_pipeline_expression(self, left: Any, right: Any) -> BinaryExpression:
233:    def _resolve_to_function(self, expr: Any, context: SandboxContext) -> Any:
272:    def _resolve_function_call(self, func_call: FunctionCall, context: SandboxContext) -> Any:
310:    def _resolve_list_literal(self, list_literal: ListLiteral, context: SandboxContext) -> Any:
322:    def _create_partial_function(self, func: Any, func_call: FunctionCall, context: SandboxContext) -> Any:
340:            def prepare_context(self, context: SandboxContext, args: list, kwargs: dict) -> SandboxContext:
344:            def restore_context(self, context: SandboxContext, original_context: SandboxContext) -> None:
348:            def execute(self, context: SandboxContext, pipeline_value: Any) -> Any:
390:    def _resolve_identifier(self, identifier: Identifier, context: SandboxContext) -> Any:
31:    def execute_binary_expression(self, node: BinaryExpression, context: SandboxContext) -> Any:
100:    def _apply_binary_coercion(self, left: Any, right: Any, operator: str) -> tuple:
118:    def _extract_value(self, raw_value: Any) -> Any:
124:    def clear_cache(self) -> None:
130:    def get_cache_stats(self) -> dict[str, Any]:
34:    def execute_pipeline(self, pipeline_expr: BinaryExpression, context: SandboxContext, *args, **kwargs) -> Any:
52:    def _extract_pipeline_stages(self, pipeline_expr: BinaryExpression) -> list[NamedPipelineStage]:
81:    def _execute_pipeline_stages(self, stages: list[NamedPipelineStage], context: SandboxContext, *args, **kwargs) -> Any:
109:    def _execute_single_stage(
140:    def _execute_function_call_stage(
187:    def _execute_identifier_stage(
209:    def _resolve_argument(self, arg_expr: Any, current_value: Any, pipeline_context: dict[str, Any], context: SandboxContext) -> Any:
248:    def _resolve_function(self, func_name: Any, context: SandboxContext) -> Any:
284:    def _contains_placeholder_or_named_variable(self, args: list[Any], pipeline_context: dict[str, Any]) -> bool:
301:    def _call_function(self, func: Any, context: SandboxContext, *args, **kwargs) -> Any:
63:    def _initialize_resolvers(self) -> None:
78:    def resolve_function(self, name_info: FunctionNameInfo, context: SandboxContext) -> ResolvedFunction:
145:    def execute_function(
181:    def _execute_registry_function(
197:    def _execute_dana_function(
209:    def _execute_python_function(
221:    def _execute_callable_function(
233:    def _assign_and_coerce_result(self, raw_result: Any, func_name: str) -> Any:
242:    def get_resolution_history(self) -> list[ResolutionAttempt]:
250:    def get_stats(self) -> dict[str, Any]:
258:    def clear_history(self) -> None:
262:    def _raise_function_not_found_error(self, name_info: FunctionNameInfo, attempts: list[ResolutionAttempt]) -> None:
38:    def handle_function_call_error(self, error: Exception, node: FunctionCall, context: Any) -> Any:
64:    def _is_positional_argument_error(self, error: Exception) -> bool:
77:    def _handle_registry_error(self, error: FunctionRegistryError, node: FunctionCall) -> Any:
89:    def _convert_to_user_friendly_name(self, function_name: str) -> str:
108:    def format_error_message(self, error: Exception, function_name: str, context: str = "") -> str:
127:    def handle_registry_execution_error(
171:    def _create_enhanced_sandbox_error(self, error: Exception, node: FunctionCall, func_name: str) -> SandboxError:
204:    def attempt_recovery(self, error: Exception, node: FunctionCall, context: Any) -> Any:
233:    def _try_keyword_conversion(self, node: FunctionCall, context: Any) -> Any:
263:    def _try_reduced_args(self, node: FunctionCall, context: Any) -> Any:
292:    def get_recovery_suggestions(self, error: Exception, function_name: str) -> list[str]:
322:    def can_handle(self, error: Exception, evaluated_kwargs: dict[str, Any]) -> bool:
334:    def _is_positional_argument_error(self, error: Exception) -> bool:
347:    def recover(
52:    def validate_instantiation(self, args: dict[str, Any]) -> bool:
86:    def _validate_field_type(self, field_name: str, value: Any, expected_type: str) -> bool:
123:    def get_field_type(self, field_name: str) -> str | None:
127:    def get_field_comment(self, field_name: str) -> str | None:
131:    def get_field_description(self, field_name: str) -> str:
178:    def struct_type(self) -> StructType:
235:    def _coerce_value(self, value: Any, field_type: str | None) -> Any:
247:    def _find_similar_field(self, name: str, available_fields: list[str]) -> str | None:
253:        def similarity_score(field: str) -> float:
301:    def get_field_names(self) -> list[str]:
305:    def get_field_value(self, field_name: str) -> Any:
309:    def get_field(self, field_name: str) -> Any:
313:    def set_field_value(self, field_name: str, value: Any) -> None:
317:    def to_dict(self) -> dict[str, Any]:
321:    def call_method(self, method_name: str, *args: Any, **kwargs: Any) -> Any:
360:    def register_method(cls, receiver_types: list[str], method_name: str, function: Any) -> None:
375:    def get_method(cls, type_name: str, method_name: str) -> Any | None:
380:    def has_method(cls, type_name: str, method_name: str) -> bool:
385:    def get_methods_for_type(cls, type_name: str) -> dict[str, Any]:
394:    def clear(cls) -> None:
412:    def register(cls, struct_type: StructType) -> None:
428:    def get(cls, struct_name: str) -> StructType | None:
433:    def exists(cls, struct_name: str) -> bool:
438:    def list_types(cls) -> list[str]:
443:    def clear(cls) -> None:
448:    def create_instance(cls, struct_name: str, values: dict[str, Any]) -> StructInstance:
458:    def get_schema(cls, struct_name: str) -> dict[str, Any]:
494:    def _type_to_json_schema(cls, type_name: str) -> dict[str, Any]:
518:    def validate_json(cls, json_data: dict[str, Any], struct_name: str) -> bool:
544:    def create_instance_from_json(cls, json_data: dict[str, Any], struct_name: str) -> StructInstance:
564:def create_struct_type_from_ast(struct_def, context=None) -> StructType:
608:def register_struct_from_ast(struct_def) -> StructType:
615:def create_struct_instance(struct_name: str, **kwargs) -> StructInstance:
36:    def enhance_prompt(self, prompt: str, type_context: TypeContext | None = None) -> str:
58:    def _get_type_handler(self, expected_type: str) -> Callable[[str, TypeContext], str]:
71:    def _build_type_handlers(self) -> dict[str, Callable[[str, TypeContext], str]]:
80:    def _apply_enhancement(self, prompt: str, enhancement: str, type_name: str) -> str:
90:    def _enhance_for_boolean(self, prompt: str, context: TypeContext) -> str:
97:    def _enhance_for_integer(self, prompt: str, context: TypeContext) -> str:
102:    def _enhance_for_float(self, prompt: str, context: TypeContext) -> str:
107:    def _enhance_for_string(self, prompt: str, context: TypeContext) -> str:
117:    def _enhance_for_structure(self, prompt: str, context: TypeContext) -> str:
127:    def _enhance_for_dana_struct(self, prompt: str, context: TypeContext) -> str:
145:    def _get_struct_info(self, expected_type: str) -> dict | None:
171:    def _build_struct_enhancement(self, struct_name: str, struct_info: dict) -> str:
202:    def _build_field_descriptions(self, struct_type) -> list[str]:
210:    def _build_enhancement_patterns(self) -> dict[str, dict[str, str]]:
279:    def get_enhancement_preview(self, prompt: str, expected_type: str) -> str:
304:def enhance_prompt_for_type(prompt: str, type_context: TypeContext | None = None) -> str:
318:def preview_enhancement(prompt: str, expected_type: str) -> str:
30:def main():
51:        async def _validate_document(self, uri: str, text: str):
71:        def _get_document_text(self, uri: str) -> str | None:
84:    async def did_open(ls: DanaLanguageServer, params: lsp.DidOpenTextDocumentParams):
90:    async def did_change(ls: DanaLanguageServer, params: lsp.DidChangeTextDocumentParams):
98:    async def did_save(ls: DanaLanguageServer, params: lsp.DidSaveTextDocumentParams):
120:    async def hover(ls: DanaLanguageServer, params: lsp.HoverParams) -> lsp.Hover | None:
137:    async def completion(ls: DanaLanguageServer, params: lsp.CompletionParams) -> lsp.CompletionList:
132:    async def analyze(self, text: str) -> list[Any]:
165:    def _analyze_dana_specific_rules(self, text: str, program: Program):
176:    def _analyze_line(self, line: str, line_num: int):
221:    def _has_incorrect_scope_syntax(self, line: str) -> bool:
226:    def _has_string_concatenation(self, line: str) -> bool:
234:    def _has_unscoped_assignment(self, line: str) -> bool:
248:    async def get_hover(self, text: str, line: int, character: int) -> str | None:
272:    def _get_word_at_position(self, line: str, character: int) -> str | None:
290:    def _get_dana_hover_info(self, word: str) -> str | None:
315:    async def get_completions(self, text: str, line: int, character: int) -> list[dict[str, Any]]:
357:    def _should_suggest_scope_prefixes(self, prefix: str) -> bool:
362:    def _parse_error_to_diagnostic(self, error: ParseError):
113:    def set_filename(self, filename: str | None) -> None:
131:    def program(self, items):
149:    def _fix_function_boundary_bug(self, statements):
180:    def _fix_nested_statements(self, statements):
243:    def _is_local_scoped_assignment(self, assignment):
251:    def statement(self, items):
267:    def conditional(self, items):
271:    def if_part(self, items):
275:    def else_part(self, items):
279:    def while_stmt(self, items):
283:    def for_stmt(self, items):
287:    def _transform_item(self, item):
313:    def function_def(self, items):
317:    def method_def(self, items):
321:    def decorators(self, items):
325:    def decorator(self, items):
329:    def struct_definition(self, items):
333:    def struct_field(self, items):
337:    def agent_definition(self, items):
341:    def agent_field(self, items):
345:    def try_stmt(self, items):
349:    def if_stmt(self, items):
353:    def elif_stmts(self, items):
357:    def elif_stmt(self, items):
362:    def assignment(self, items):
371:    def declarative_function_assignment(self, items):
378:    def expr_stmt(self, items):
382:    def return_stmt(self, items):
386:    def break_stmt(self, items):
390:    def continue_stmt(self, items):
394:    def pass_stmt(self, items):
398:    def raise_stmt(self, items):
402:    def assert_stmt(self, items):
406:    def use_stmt(self, items):
410:    def agent_stmt(self, items):
414:    def agent_pool_stmt(self, items):
419:    def import_stmt(self, items):
423:    def simple_import(self, items):
427:    def from_import(self, items):
432:    def arg_list(self, items):
436:    def positional_args(self, items):
440:    def named_args(self, items):
444:    def named_arg(self, items):
449:    def _filter_body(self, items):
456:    def identifier(self, items):
460:    def _transform_block(self, block):
497:    def _process_statements_with_boundary_detection(self, statements):
524:    def _is_program_level_statement(self, stmt):
547:    def _is_assignment_to_local_scope(self, assignment_tree):
560:    def _target_uses_local_scope(self, target_tree):
579:    def parameters(self, items):
583:    def parameter(self, items):
587:    def binary_expr(self, items):
601:    def _filter_relevant_items(self, items):
622:    def basic_type(self, items):
626:    def typed_assignment(self, items):
630:    def simple_assignment(self, items):
634:    def function_call_assignment(self, items):
638:    def compound_assignment(self, items):
642:    def compound_op(self, items):
646:    def return_object_stmt(self, items):
650:    def typed_parameter(self, items):
654:    def mixed_arguments(self, items):
658:    def with_arg(self, items):
662:    def with_context_manager(self, items):
666:    def with_stmt(self, items):
670:    def create_location(self, item: Any) -> Location | None:
679:    def statements(self, items):
76:    def set_declarative_function_context(self, in_declarative_function: bool):
80:    def expression(self, items):
115:            def custom_transformer(node: Any) -> Any:
179:    def _extract_operator_string(self, op_token):
183:    def _op_tree_to_str(self, tree):
194:    def _left_associative_binop(self, items, operator_getter):
202:    def _get_binary_operator(self, op_str):
230:    def or_expr(self, items):
241:    def and_expr(self, items):
252:    def placeholder_expression(self, items):
256:    def pipe_expr(self, items):
299:                "Use 'def function_name() = expr1 | expr2' syntax instead of assignment."
305:    def _is_in_declarative_function_context(self):
309:    def _is_literal_expression(self, expr):
329:    def not_expr(self, items):
371:    def comparison(self, items):
374:    def sum_expr(self, items):
378:    def term(self, items):
382:    def factor(self, items):
434:    def power(self, items):
470:    def atom(self, items):
518:    def _atom_from_token(self, token):
556:    def literal(self, items):
560:    def identifier(self, items):
566:    def argument(self, items):
579:    def _process_function_arguments(self, arg_children):
604:    def tuple(self, items):
616:    def list(self, items):
631:    def dict(self, items):
644:    def set(self, items):
656:    def TRUE(self, items=None):
659:    def FALSE(self, items=None):
662:    def NONE(self, items=None):
665:    def trailer(self, items):
703:    def _get_full_attribute_name(self, attr):
715:    def key_value_pair(self, items):
721:    def expr(self, items):
725:    def string(self, items):
802:    def product(self, items):
810:    def POW(self, token):
814:    def ADD(self, token):
818:    def SUB(self, token):
822:    def MUL(self, token):
826:    def DIV(self, token):
830:    def FDIV(self, token):
834:    def MOD(self, token):
838:    def string_literal(self, items):
891:    def slice_or_index(self, items):
895:    def slice_start_only(self, items):
899:    def slice_stop_only(self, items):
903:    def slice_start_stop(self, items):
907:    def slice_start_stop_step(self, items):
911:    def slice_all(self, items):
915:    def slice_step_only(self, items):
919:    def slice_expr(self, items):
924:    def slice_list(self, items):
936:    def function_composition_expr(self, items):
941:    def function_pipe_expr(self, items):
956:    def pipeline_stage(self, items):
983:    def function_expr(self, items):
988:    def function_name(self, items):
993:    def function_call(self, items):
1016:    def function_list_literal(self, items):
1024:    def _contains_placeholder(self, arguments):
1042:    def _is_placeholder_expression(self, expr):
46:    def assignment(self, items):
55:    def typed_assignment(self, items):
64:    def simple_assignment(self, items):
72:    def compound_assignment(self, items):
124:    def compound_op(self, items):
129:    def function_call_assignment(self, items):
153:    def declarative_function_assignment(self, items):
206:    def _transform_function_composition(self, composition_tree):
226:    def _transform_parameter(self, param_tree):
243:    def _transform_type_hint(self, type_tree):
257:    def return_object_stmt(self, items):
271:    def basic_type(self, items):
275:    def typed_parameter(self, items):
5:- Function definitions (def statements)
45:    def function_def(self, items):
81:    def method_def(self, items):
150:    def _extract_decorators_and_name(self, relevant_items):
171:    def _resolve_function_parameters(self, relevant_items, current_index):
195:    def _extract_return_type(self, relevant_items, current_index):
214:    def _extract_function_body(self, relevant_items, current_index):
229:    def decorators(self, items):
233:    def decorator(self, items):
237:    def _transform_decorators(self, decorators_tree):
245:    def _transform_decorator(self, decorator_tree):
251:    def _transform_decorator_from_items(self, items):
268:    def _parse_decorator_arguments(self, arguments_tree):
291:    def _transform_parameters(self, parameters_tree):
297:    def _transform_parameter(self, param_tree):
306:    def parameters(self, items):
342:    def parameter(self, items):
364:    def struct_definition(self, items):
385:    def struct_field(self, items):
423:    def agent_definition(self, items):
444:    def agent_field(self, items):
38:    def expr_stmt(self, items):
42:    def return_stmt(self, items):
46:    def break_stmt(self, items):
50:    def continue_stmt(self, items):
54:    def pass_stmt(self, items):
58:    def raise_stmt(self, items):
62:    def assert_stmt(self, items):
68:    def import_stmt(self, items):
73:    def simple_import(self, items):
117:    def from_import(self, items):
211:    def arg_list(self, items):
215:    def positional_args(self, items):
219:    def named_args(self, items):
228:    def named_arg(self, items):
43:    def conditional(self, items):
53:    def if_part(self, items):
59:    def else_part(self, items):
63:    def if_stmt(self, items):
111:    def elif_stmts(self, items):
142:    def elif_stmt(self, items):
152:    def while_stmt(self, items):
161:    def for_stmt(self, items):
209:    def try_stmt(self, items):
239:    def except_clause(self, items):
258:    def except_spec(self, items):
278:    def exception_type(self, items):
295:    def exception_list(self, items):
30:    def variable(self, items):
38:    def scoped_var(self, items):
54:        def raw_name(item):
72:    def simple_name(self, items):
84:    def dotted_access(self, items):
123:    def identifier(self, items):
137:    def _extract_name(self, item):
158:    def _join_dotted(self, parts):
164:    def _insert_scope_if_missing(self, name):
31:    def set_filename(self, filename: str | None) -> None:
35:    def _parse_literal(self, text):
39:    def _create_literal(self, token):
43:    def _insert_local_scope(self, parts: list[str] | str) -> Any:
48:    def get_leaf_node(item: Tree | Token | ASTNode) -> Token | ASTNode:
52:    def flatten_items(self, items):
59:    def unwrap_single_child_tree(self, item, stop_at=None):
73:    def get_location(self, item: Any) -> tuple[int, int] | None:
89:    def create_location(self, item: Any) -> Location | None:
30:    def set_filename(self, filename: str | None) -> None:
43:    def transform(self, tree):
29:    def trailer(self, items):
160:    def argument(self, items):
175:    def _process_function_arguments(self, arg_children):
202:    def slice_or_index(self, items):
206:    def slice_start_only(self, items):
210:    def slice_stop_only(self, items):
214:    def slice_start_stop(self, items):
218:    def slice_start_stop_step(self, items):
222:    def slice_all(self, items):
226:    def slice_step_only(self, items):
230:    def slice_expr(self, items):
235:    def slice_list(self, items):
246:    def _get_full_attribute_name(self, attr):
24:    def extract_operator_string(op_token):
47:    def op_tree_to_str(tree):
55:    def left_associative_binop(items, operator_getter):
79:    def get_binary_operator(op_str):
114:    def atom_from_token(token):
138:    def process_string_literal(item):
179:    def get_full_attribute_name(attr):
27:    def _extract_operator_string(self, op_token):
38:    def _op_tree_to_str(self, tree):
45:    def _left_associative_binop(self, items, operator_getter):
69:    def _get_binary_operator(self, op_str):
99:    def or_expr(self, items):
103:    def and_expr(self, items):
107:    def pipe_expr(self, items):
111:    def not_expr(self, items):
136:    def comparison(self, items):
140:    def sum_expr(self, items):
144:    def term(self, items):
148:    def factor(self, items):
173:    def power(self, items):
193:    def ADD(self, token):
197:    def SUB(self, token):
201:    def MUL(self, token):
205:    def DIV(self, token):
209:    def FDIV(self, token):
213:    def MOD(self, token):
217:    def POW(self, token):
221:    def PIPE(self, token):
225:    def EQ_OP(self, token):
229:    def NE_OP(self, token):
233:    def LT_OP(self, token):
237:    def GT_OP(self, token):
241:    def LE_OP(self, token):
245:    def GE_OP(self, token):
249:    def IN_OP(self, token):
253:    def NOT_IN_OP(self, token):
257:    def IS_OP(self, token):
261:    def IS_NOT_OP(self, token):
265:    def NOT_OP(self, token):
35:    def validate_function_call_trailer(trailer: Any) -> None:
47:    def validate_attribute_trailer(trailer: Any) -> None:
66:    def handle_function_call(self, current_base: Expression, trailer: Any) -> ObjectFunctionCall | FunctionCall:
94:    def _create_method_call(self, attribute_access: AttributeAccess, args: dict[str, Any]) -> ObjectFunctionCall:
103:    def _create_function_call(self, base: Expression, args: dict[str, Any]) -> FunctionCall:
119:    def handle_attribute_access(self, current_base: Expression, trailer: Any) -> AttributeAccess:
149:    def handle_indexing(self, current_base: Expression, trailer: Any) -> SubscriptExpression:
170:    def analyze_chain(self, trailers: list[Any]) -> dict[str, Any]:
198:    def _count_trailer_types(self, trailers: list[Any]) -> dict[str, int]:
230:    def process_trailers(self, base: Expression, trailers: list[Any]) -> Expression:
267:    def _process_single_trailer(self, current_base: Expression, trailer: Any, position: int) -> Expression:
76:    def from_type_hint(type_hint: "TypeHint") -> "DanaType":
103:    def get(self, name: str) -> DanaType | None:
111:    def set(self, name: str, type_: DanaType) -> None:
115:    def register(self, name: str, type_: DanaType) -> None:
119:    def push_scope(self):
123:    def pop_scope(self):
134:    def check_program(self, program: Program) -> None:
139:    def check_statement(self, statement: Any) -> None:
185:    def check_assignment(self, node: Assignment) -> None:
225:    def check_compound_assignment(self, node: CompoundAssignment) -> None:
256:    def check_conditional(self, node: Conditional) -> None:
267:    def check_while_loop(self, node: WhileLoop) -> None:
276:    def check_for_loop(self, node: ForLoop) -> None:
306:    def check_try_block(self, node: TryBlock) -> None:
316:    def check_except_block(self, node: ExceptBlock) -> None:
321:    def check_function_definition(self, node: FunctionDefinition) -> None:
376:    def check_method_definition(self, node: MethodDefinition) -> None:
427:    def check_struct_definition(self, node: StructDefinition) -> None:
442:    def check_import_statement(self, node: ImportStatement) -> None:
446:    def check_import_from_statement(self, node: ImportFromStatement) -> None:
450:    def check_expression(self, expression: Any) -> DanaType:
492:    def check_literal_expression(self, node: LiteralExpression) -> DanaType:
496:    def check_identifier(self, node: Identifier) -> DanaType:
514:    def check_binary_expression(self, node: BinaryExpression) -> DanaType:
580:    def check_unary_expression(self, node: UnaryExpression) -> DanaType:
589:    def check_attribute_access(self, node: AttributeAccess) -> DanaType:
596:    def check_subscript_expression(self, node: SubscriptExpression) -> DanaType:
614:    def check_dict_literal(self, node: DictLiteral) -> DanaType:
623:    def check_set_literal(self, node: SetLiteral) -> DanaType:
629:    def check_tuple_literal(self, node: TupleLiteral) -> DanaType:
635:    def check_list_literal(self, node: ListLiteral) -> DanaType:
641:    def check_function_call(self, node: FunctionCall) -> DanaType:
651:    def check_assert_statement(self, node: AssertStatement) -> None:
661:    def check_raise_statement(self, node: RaiseStatement) -> None:
671:    def check_return_statement(self, node: ReturnStatement) -> None:
677:    def check_use_statement(self, node: UseStatement) -> DanaType:
688:    def check_types(program: Program) -> None:
52:    def is_valid(self) -> bool:
129:    def parse(self, program_text: str, do_transform: bool = True, do_type_check: bool = False, filename: str | None = None) -> Any:
156:    def transform(self, parse_tree: Tree, do_type_check: bool = False) -> Program:
184:    def parse_expression(self, expr_text: str):
208:    def _deprecated_transform_identifier(self, node: Tree) -> Identifier:
224:def parse_program(program_text: str, do_type_check: bool = ENABLE_TYPE_CHECK) -> Program:
103:    def _register_cleanup(self):
109:    def _create_default_context(self) -> SandboxContext:
115:        def feedback_placeholder(result: Any, feedback_data: Any):
123:    def _ensure_initialized(self):
155:    def _can_reuse_shared_resources(self) -> bool:
163:    def _use_shared_resources(self):
171:    def _initialize_new_resources(self):
203:    def _cleanup(self):
247:    def _cleanup_instance_resources(self):
274:    def _cleanup_shared_resources(cls):
301:    def _cleanup_on_deletion(weakref_obj):
322:    def _cleanup_all_instances(cls):
338:    def cleanup_all(cls):
346:    def is_healthy(self) -> bool:
359:    def run_file(self, file_path: str | Path) -> ExecutionResult:
445:    def eval(self, source_code: str, filename: str | None = None) -> ExecutionResult:
529:    def quick_run(cls, file_path: str | Path, debug_mode: bool = False, context: SandboxContext | None = None) -> ExecutionResult:
545:    def quick_eval(
587:    def context(self) -> SandboxContext:
591:    def load_file(self, file_path: str) -> None:
598:    def function_registry(self):
31:    def evaluate(self, context) -> Any:
152:    def type(self):
466:    """Method definition statement with explicit receiver (e.g., def (point: Point) translate(dx, dy):)."""
479:    """Declarative function definition statement (e.g., def func(x: int) -> str = f1 | f2)."""
89:    def parent_context(self) -> Optional["SandboxContext"]:
94:    def manager(self) -> Optional["ContextManager"]:
99:    def manager(self, manager: "ContextManager") -> None:
104:    def interpreter(self) -> "DanaInterpreter":
111:    def interpreter(self, interpreter: "DanaInterpreter"):
120:    def error_context(self):
124:    def get_interpreter(self) -> Optional["DanaInterpreter"]:
132:    def _validate_key(self, key: str) -> tuple[str, str]:
163:    def _normalize_key(self, scope: str, var_name: str) -> str:
175:    def set(self, key: str, value: Any) -> None:
201:    def get(self, key: str, default: Any = None) -> Any:
234:    def get_execution_status(self) -> ExecutionStatus:
242:    def set_execution_status(self, status: ExecutionStatus) -> None:
250:    def add_execution_history(self, entry: dict[str, Any]) -> None:
261:    def reset_execution_state(self) -> None:
267:    def from_dict(cls, data: dict[str, Any], base_context: Optional["SandboxContext"] = None) -> "SandboxContext":
308:    def set_in_scope(self, var_name: str, value: Any, scope: str = "local") -> None:
333:    def has(self, key: str) -> bool:
353:    def delete(self, key: str) -> None:
375:    def clear(self, scope: str | None = None) -> None:
392:    def get_state(self) -> dict[str, dict[str, Any]]:
400:    def set_state(self, state: dict[str, dict[str, Any]]) -> None:
418:    def merge(self, other: "SandboxContext") -> None:
427:    def copy(self) -> "SandboxContext":
456:    def sanitize(self) -> "SandboxContext":
550:    def get_scope(self, scope: str) -> dict[str, Any]:
561:    def set_scope(self, scope: str, context: dict[str, Any] | None = None) -> None:
570:    def get_from_scope(self, var_name: str, scope: str = "local") -> Any:
605:    def get_assignment_target_type(self) -> Any | None:
627:    def set_resource(self, name: str, resource: BaseResource) -> None:
641:    def get_resource(self, name: str) -> BaseResource:
647:    def get_resources(self, included: list[str | BaseResource] | None = None) -> dict[str, BaseResource]:
677:    def soft_delete_resource(self, name: str) -> None:
684:    def list_resources(self) -> list[str]:
693:    def delete_from_scope(self, var_name: str, scope: str = "local") -> None:
721:    def set_agent(self, name: str, agent: BaseResource) -> None:
735:    def get_agent(self, name: str) -> BaseResource:
741:    def get_agents(self, included: list[str | BaseResource] | None = None) -> dict[str, BaseResource]:
757:    def soft_delete_agent(self, name: str) -> None:
764:    def list_agents(self) -> list[str]:
773:    def get_self_agent_card(self, included_resources: list[str | BaseResource] | None = None) -> dict[str, dict[str, Any]]:
810:    def get_other_agent_cards(self, included_agents: list[str | BaseResource] | None = None) -> dict[str, dict[str, Any]]:
816:    def startup(self) -> None:
821:    def shutdown(self) -> None:
37:    def _smart_max(*args):
55:    def _smart_min(*args):
73:    def _smart_sum(*args):
405:    def _semantic_bool_wrapper(cls, value):
416:    def create_function(cls, name: str):
431:        def dana_wrapper(context: SandboxContext, *args, **kwargs):
446:    def _raise_unsupported_error(cls, name: str):
470:    def _handle_unknown_builtin(cls, name: str):
575:    def _validate_args(cls, name: str, args: tuple, expected_signatures: list[tuple]):
618:    def _execute_with_guards(cls, func: callable, args: tuple):
625:    def get_available_functions(cls) -> list[str]:
630:    def get_function_info(cls, name: str) -> dict[str, Any]:
637:    def get_unsupported_functions(cls) -> list[str]:
642:    def get_unsupported_info(cls, name: str) -> dict[str, Any]:
649:    def is_supported(cls, name: str) -> bool:
654:    def is_unsupported(cls, name: str) -> bool:
659:    def get_functions_by_reason(cls, reason: UnsupportedReason) -> list[str]:
664:    def get_security_report(cls) -> dict[str, Any]:
696:def register_pythonic_builtins(registry: FunctionRegistry) -> None:
735:        def create_unsupported_handler(name):
736:            def unsupported_handler(context: SandboxContext, *args, **kwargs):
9:def create_function_with_better_doc_string(func: Callable, doc_string: str) -> Callable:
13:    def wrapper(*args, **kwargs):
17:    async def async_wrapper(*args, **kwargs):
28:def use_function(context: SandboxContext, function_name: str, *args, _name: str | None = None, **kwargs) -> BaseResource:
19:def cast_function(context: SandboxContext, target_type: Any, value: Any) -> Any:
15:def noop_function(
7:def agent_function(context: SandboxContext, *args, _name: str | None = None, **kwargs) -> AbstractDanaAgent:
31:def _create_module_agent(context: SandboxContext, name: str, module, **kwargs) -> AbstractDanaAgent:
60:def _create_a2a_agent(context: SandboxContext, name: str, *args, **kwargs) -> AbstractDanaAgent:
94:def agent_pool_function(context: SandboxContext, *args, _name: str | None = None, **kwargs) -> BaseResource:
20:def register_core_functions(registry: FunctionRegistry) -> None:
16:def load_dana_env(dot_env_file_path: Path | str | None = None):
53:    def _resolve_user_identity(self, provided_user_id: str = None) -> str:
82:    def _resolve_instance_identity(self, provided_instance_id: str = None) -> str:
115:    def _resolve_session_identity(self, provided_session_id: str = None) -> str:
138:    def _initialize_simplified_memory_system(self):
183:    def _initialize_cross_session_persistence(self):
195:    def _restore_session_context(self):
224:    def _wrap_agent_methods(self):
235:    def _context_aware_solve(self, input_data: str, context: str | None = None) -> str:
245:    def _solve_with_memory_system(self, input_data: str, context: str | None = None) -> str:
281:    def _get_memory_context(self, input_data: str) -> dict:
290:    def _store_interaction_in_memory(self, input_data: str, response: str, complete_conversation: str):
299:    def _solve_with_basic_context(self, input_data: str, context: str | None = None) -> str:
330:    def _context_aware_reason(self, prompt: str, **kwargs) -> str:
353:    def _build_contextual_prompt(self, input_data: str) -> str:
393:    def _enhance_prompt_with_context(self, original_prompt: str) -> str:
412:    def _build_memory_enhanced_prompt(self, input_data: str, memory_context: dict) -> str:
448:    def _build_persistent_context_prompt(self, input_data: str, memory_context: dict) -> str:
495:    def _build_memory_context_summary(self, memory_context: dict) -> str:
517:    def _build_memory_enhanced_input(self, input_data: str) -> str:
544:    def _get_comprehensive_memory_context(self) -> str:
585:    def _extract_conversations_from_memories(self, memories) -> list:
634:    def _extract_user_facts_from_memories(self, memories) -> list:
645:    def _build_direct_memory_context(self, memory_items: list) -> str:
661:    def _run_async_safely(self, coro):
668:    def get_context_info(self) -> dict[str, Any]:
699:    def get_conversation_summary(self) -> str:
720:    def get_persistence_status(self) -> dict[str, Any]:
741:    def reset_context(self):
50:    def add_turn(self, user_input: str, agent_response: str, context_used: dict[str, Any] = None):
61:    def get_recent_history(self, n: int = 5) -> list[ConversationTurn]:
65:    def get_conversation_context(self) -> str:
78:    def extract_user_info(self, text: str) -> dict[str, Any]:
106:    def get_user_context(self) -> dict[str, Any]:
120:    def _generate_conversation_summary(self) -> str:
142:    def should_include_context(self) -> bool:
147:    def clear_session(self):
45:def _default_metadata() -> MemoryMetadata:
60:    def content(self) -> str:
64:    def embedding(self) -> list[float] | None:
68:    def memory_type(self) -> MemoryType:
72:    def confidence(self) -> float | None:
85:    def add_memory(self, memory: MemoryItem, target_type: str | None = None):
89:    def get_all_memories(self) -> list[MemoryItem]:
29:    async def initialize(self):
35:    async def extract_memories(self, conversation_content: str, user_id: str) -> list[dict[str, Any]]:
63:    def _build_extraction_prompt(self, content: str) -> str:
113:    def _parse_memory_response(self, response_content: Any, original_content: str) -> list[dict[str, Any]]:
138:    def _validate_memories(self, memories: list[dict[str, Any]]) -> list[dict[str, Any]]:
186:    def _fallback_extraction(self, content: str) -> list[dict[str, Any]]:
232:    async def initialize(self):
238:    async def detect_intent(self, query: str, working_memory: list[MemoryItem]) -> dict[str, Any]:
267:    def _format_memory_context(self, memories: list[MemoryItem]) -> str:
278:    def _build_intent_prompt(self, query: str, memory_context: str) -> str:
302:    def _parse_intent_response(self, response_content: Any, query: str) -> dict[str, Any]:
332:    def _fallback_intent_detection(self, query: str, working_memory: list[MemoryItem]) -> dict[str, Any]:
361:    async def initialize(self):
367:    async def rank_memories(self, query: str, memories: list[MemoryItem]) -> list[MemoryItem]:
403:    def _build_ranking_prompt(self, query: str, memory_texts: list[str]) -> str:
423:    def _parse_ranking_response(self, response_content: Any, memories: list[MemoryItem]) -> list[MemoryItem]:
457:    def _simple_rank_memories(self, query: str, memories: list[MemoryItem]) -> list[MemoryItem]:
465:        def relevance_score(memory: MemoryItem) -> float:
21:    def _serialize_memory_item(self, memory: MemoryItem) -> dict[str, Any]:
41:    def _deserialize_memory_item(self, data: dict[str, Any]) -> MemoryItem:
63:    def _load_memories(self) -> list[MemoryItem]:
76:    def _save_memories(self, memories: list[MemoryItem]):
82:    def _text_search(self, memories: list[MemoryItem], query: str, limit: int) -> list[MemoryItem]:
127:    async def store(self, memory: MemoryItem) -> bool:
145:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
153:    async def search_by_text(self, query: str, limit: int = 10) -> list[MemoryItem]:
159:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
168:    def _is_duplicate(self, new_memory: MemoryItem, existing_memories: list[MemoryItem]) -> bool:
202:    async def store(self, memory: MemoryItem) -> bool:
210:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
216:    async def search_by_text(self, query: str, limit: int = 10) -> list[MemoryItem]:
222:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
231:    async def get_user_profile_summary(self) -> dict[str, Any]:
279:    async def store(self, memory: MemoryItem) -> bool:
298:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
304:    async def search_by_text(self, query: str, limit: int = 10) -> list[MemoryItem]:
310:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
319:    def _should_share(self, memory: MemoryItem) -> bool:
348:    def _sanitize_memory(self, memory: MemoryItem) -> MemoryItem:
361:    async def get_collective_stats(self) -> dict[str, Any]:
12:    async def store(self, memory: MemoryItem) -> bool:
16:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
20:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
41:    def _get_storage_file_path(self) -> Path:
47:    def _load_memories(self):
60:    def _save_memories(self):
77:    def _serialize_memory(self, memory: MemoryItem) -> dict:
97:    def _deserialize_memory(self, data: dict) -> MemoryItem | None:
123:    async def store(self, memory: MemoryItem) -> bool:
131:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
136:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
143:    def clear_and_keep_recent(self, keep_count: int = 10):
150:    def replace_with_items(self, items_to_keep: list):
165:    async def store(self, memory: MemoryItem) -> bool:
173:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
178:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
194:    async def store(self, memory: MemoryItem) -> bool:
199:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
203:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
221:    async def store(self, memory: MemoryItem) -> bool:
228:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
232:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
67:    def _initialize_index(self):
98:    def _load_memory_metadata(self):
130:    def _save_memory_metadata(self):
158:    def _create_document_from_memory(self, memory: MemoryItem) -> Document:
176:    async def store(self, memory: MemoryItem) -> bool:
207:    async def search(self, query_embedding: list[float], limit: int) -> list[MemoryItem]:
215:    async def search_by_text(self, query: str, limit: int) -> list[MemoryItem]:
242:    async def retrieve(self, memory_id: str) -> MemoryItem | None:
247:    def get_query_engine(self, similarity_top_k: int = 10):
264:    def get_memory_count(self) -> int:
282:    async def store(self, memory: MemoryItem) -> bool:
300:    def _is_semantic_duplicate(self, new_content: str, existing_content: str) -> bool:
325:    async def get_user_profile_summary(self, query: str = "user preferences and characteristics") -> str:
347:    async def search_user_preferences(self, topic: str, limit: int = 10) -> list[MemoryItem]:
375:    async def store(self, memory: MemoryItem) -> bool:
403:    def _should_store_in_shared(self, memory: MemoryItem) -> bool:
432:    async def _rebuild_index(self):
462:    async def search_collective_knowledge(self, query: str, limit: int = 10) -> list[MemoryItem]:
466:    async def get_popular_topics(self, limit: int = 10) -> list[str]:
81:    def _count_tokens(self, text: str) -> int:
87:    def _get_working_memory_token_count(self, memories: list[MemoryItem]) -> int:
92:    def _get_recent_items_by_token_limit(self, memories: list[MemoryItem], token_limit: int) -> list[MemoryItem]:
113:    async def add_conversation_memory(self, memory_content: str) -> list[MemoryItem]:
142:    async def process_working_memory_batch(self):
222:    async def manual_batch_process(self):
226:    async def chat_with_memory(self, query: str) -> dict[str, Any]:
255:    async def retrieve_context(self, query: str) -> list[str]:
274:    async def get_user_profile(self) -> dict[str, Any]:
300:    async def advanced_query(self, query: str, memory_type: str = "long_term") -> str:
328:    async def search_by_text(self, query: str, memory_type: str = "all", limit: int = 10) -> list[MemoryItem]:
357:    async def get_current_working_memory_tokens(self) -> int:
362:    async def get_memory_statistics(self) -> dict[str, Any]:
409:    async def _search_persistent_memories(self, missing_evidence: list[str]) -> list[MemoryItem]:
426:    async def _replace_working_memory_with_llm_ranking(self, query: str, original: list[MemoryItem], retrieved: list[MemoryItem]) -> None:
88:    def with_planning(
121:    def with_reasoning(
152:    def _create_llm(self, llm: dict | str | LLMResource, name: str) -> LLMResource:
164:    def runtime_context(self) -> RuntimeContext:
171:    def planner(self) -> Planner:
178:    def planner(self, planner: Planner | None) -> None:
183:    def reasoner(self) -> Reasoner:
190:    def reasoner(self, reasoner: Reasoner | None) -> None:
195:    def _current_plan(self) -> Plan:
210:        def handle_plan_get(key: str, default: Any) -> Any:
214:        def handle_plan_set(key: str, value: Any) -> None:
231:    async def execute(self, plan: "Plan") -> Any:
30:    def create_agent(cls, config: dict[str, Any]) -> Agent:
18:def default_plan_method(context: SandboxContext, agent_instance: "AgentInstance", task: str, user_context: dict | None = None) -> Any:
39:def default_solve_method(context: SandboxContext, agent_instance: "AgentInstance", problem: str, user_context: dict | None = None) -> Any:
75:    def add_method(self, method_name: str, method_func: Any) -> None:
78:    def get_method(self, method_name: str) -> Any | None:
87:    def has_method(self, method_name: str) -> bool:
130:    def _initialize_context_management(self):
141:    def agent_card(self) -> dict[str, Any]:
158:    def skills(self) -> list[dict[str, Any]]:
162:    def agent_type(self) -> AgentType:
165:    def solve(self, task: str) -> str:
179:    def plan(self, task: str, user_context: dict | None = None) -> Any:
182:    def get_context_info(self) -> dict:
189:    def get_conversation_summary(self) -> str:
196:    def reset_context(self):
201:    def get_persistence_status(self) -> dict:
208:    def _call_method(self, method, *args, **kwargs):
244:    def _call_method_with_current_context(self, method, *args, **kwargs):
269:    def _get_current_execution_context(self):
307:    def call_method(self, method_name: str, *args: Any, **kwargs: Any) -> Any:
314:    def to_dict(self) -> dict[str, Any]:
321:    def _try_global_function_fallback(self, method_name: str) -> Any | None:
340:                def agent_method_wrapper(*args, **kwargs):
351:    def _function_matches_agent_type(self, func: Any, agent_type_name: str) -> bool:
394:    def _get_function_registry(self):
419:    def register(cls, agent_type: AgentType) -> None:
423:    def get(cls, agent_name: str) -> AgentType | None:
427:    def exists(cls, agent_name: str) -> bool:
431:    def list_types(cls) -> list[str]:
435:    def clear(cls) -> None:
439:    def create_instance(cls, agent_name: str, values: dict[str, Any], context: SandboxContext, instance_id: str = None) -> AgentInstance:
447:def create_agent_type_from_ast(agent_def) -> AgentType:
468:def register_agent_from_ast(agent_def) -> AgentType:
474:def create_agent_instance(agent_name: str, context: SandboxContext, **kwargs) -> AgentInstance:
478:def register_agent_method_from_function_def(node, dana_func):
67:    def _load_default_config(self) -> dict[str, Any]:
79:    def _find_first_available_model(self) -> str | None:
112:    def _get_required_env_vars_for_model(self, model_name: str) -> list[str]:
143:    def _load_from_file(self, config_path: str) -> None:
185:    def _load_json_file(self, path: Path) -> None:
204:    def _update_logging_from_env(self) -> None:
208:        def safe_int(value: str, default: int) -> int:
225:    def get(self, key: str, default: Any = None) -> Any:
229:    def update(self, config: dict[str, Any]) -> None:
53:    def new_instance(cls, response: BaseResponse | dict[str, Any] | Any) -> "AgentResponse":
97:    def state(self) -> AgentState:
104:    def runtime(self) -> AgentRuntime:
111:    def agent_llm(self) -> LLMResource:
118:    def available_resources(self) -> dict[str, BaseResource]:
125:    def capabilities(self) -> dict[str, BaseCapability]:
132:    def io(self) -> BaseIO:
139:    def with_model(self, model: str) -> "Agent":
144:    def with_llm(self, llm: dict | str | LLMResource) -> "Agent":
154:    def with_resources(self, resources: dict[str, BaseResource]) -> "Agent":
161:    def with_capabilities(self, capabilities: dict[str, BaseCapability]) -> "Agent":
168:    def with_io(self, io: BaseIO) -> "Agent":
173:    def with_planning(
189:    def with_reasoning(
206:    def _get_default_llm_resource(self):
210:    def _create_llm(self, llm: dict | str | LLMResource, name: str) -> LLMResource:
221:    def _initialize(self) -> "Agent":
236:    async def cleanup(self) -> None:
242:    async def initialize(self) -> "Agent":
256:    async def async_run(self, plan: Plan, context: RuntimeContext | None = None) -> AgentResponse:
262:    def run(self, plan: Plan) -> AgentResponse:
265:        async def _run_async():
270:    def ask(self, question: str) -> AgentResponse:
275:    def runtime_context(self) -> RuntimeContext:
280:    async def set_variable(self, name: str, value: Any) -> BaseResponse:
285:    async def query(self, request: BaseRequest) -> BaseResponse:
289:    def has_capability(self, capability: BaseCapability | str) -> bool:
303:    def add_capability(self, name: str, capability: BaseCapability) -> None:
312:    def remove_capability(self, name: str) -> None:
57:    async def create(cls, name: str, agent: "Agent", description: str) -> "AgentResource":
73:    async def query(self, request: BaseRequest | None = None) -> BaseResponse:
99:    async def initialize(self) -> None:
111:    async def cleanup(self) -> None:
98:    def expertise(self) -> DomainExpertise | None:
103:    def confidence_threshold(self) -> float:
108:    def system_prompt(self) -> str | None:
113:    def llm_config(self) -> dict[str, Any]:
117:    async def initialize(self) -> None:
123:    async def query(self, request: BaseRequest | None = None) -> BaseResponse:
143:    async def cleanup(self) -> None:
148:    def can_handle(self, request: dict[str, Any]) -> bool:
16:    def create_resource(cls, resource_type: str, config: dict[str, Any]) -> BaseResource:
25:    def create_llm_resource(cls, config: dict[str, Any]) -> LLMResource:
16:def main():
28:def parse_dana_input_args(input_strs: list[str] | tuple[str, ...]) -> dict[str, str]:
72:    def resolve_at_file(value: str, is_file: bool) -> str:
46:    def mcp_tool_decorator(self, func_name: str) -> Any:
49:        def wrapper(**kwargs) -> Any:
78:    async def initialize(self) -> None:
83:    async def _discover_tools(self) -> None:
94:    def _list_tools(self, format_converter: OpenAIToolFormat) -> list[Any]:
105:    async def call_tool(self, tool_name: str, arguments: dict[str, Any]) -> Any:
123:    async def query(self, request: BaseRequest) -> BaseResponse:
145:    def can_handle(self, request: BaseRequest) -> bool:
159:    async def main():
12:    def parse_init_params(cls, *args, **kwargs) -> ParsedArgKwargsResults:
86:    def _validate_transport(cls, *args, **kwargs) -> BaseTransport:
96:    async def _try_client_with_valid_transport(cls, transport: BaseTransport) -> bool:
6:def extract_text_from_response(response: Message) -> str:
34:    def select_agent(self, task: any, strategy: str = "llm", included_resources: list[str | Any] | None = None) -> Any:
52:    def _select_by_llm(self, task: any, included_resources: list[str | Any] | None = None) -> Any:
126:    def _get_agent_skills(self, agent: Any) -> list[str]:
139:    def _format_agent_cards(self, cards: dict[str, dict]) -> str:
168:    def update_performance_metrics(self, agent_name: str, metrics: dict[str, float]) -> None:
82:    def get_base_path(cls) -> Path:
91:    def get_config_path(
163:    def from_dict(cls, data: dict[str, Any]) -> "Configurable":
183:    def _load_config(self, config_path: str | Path | None = None) -> dict[str, Any]:
218:    def _apply_overrides(self, overrides: dict[str, Any]) -> None:
232:    def _validate_required(self, key: str, error_msg: str | None = None) -> None:
256:    def _validate_type(self, key: str, expected_type: type[T], error_msg: str | None = None) -> None:
282:    def _validate_enum(self, key: str, valid_values: list[Any], error_msg: str | None = None) -> None:
308:    def _validate_path(self, key: str, must_exist: bool = True, error_msg: str | None = None) -> None:
334:    def _validate_config(self) -> None:
350:    def get(self, key: str, default: Any = None) -> Any:
362:    def set(self, key: str, value: Any) -> None:
375:    def update(self, config: dict[str, Any]) -> None:
387:    def to_dict(self) -> dict[str, Any]:
395:    def save(self, path: str | Path) -> None:
418:    def get_yaml_path(cls, path: str | None = None) -> Path:
474:    def get_prompt(cls, config_path: str | None = None, prompt_ref: str | None = None, custom_prompts: dict[str, str] | None = None) -> str:
521:    def load_config(cls, path: str | None = None) -> dict[str, Any]:
29:def configure_asyncio_threshold():
66:    def load_yaml_config(path: str | Path) -> dict[str, Any]:
90:    def _resolve_yaml_path(path: Path) -> Path:
105:    def get_class_by_name(class_path: str) -> type[Any]:
116:    def get_base_path(for_class: type[Any]) -> Path:
121:    def get_config_path(
174:    def safe_asyncio_run(func: Callable[..., Any], *args: Any, **kwargs: Any) -> Any:
206:    def _run_in_existing_loop(func: Callable[..., Any], *args: Any, **kwargs: Any) -> Any:
216:        def run_in_thread():
225:    def get_field(obj: dict | object, field_name: str, default: Any = None) -> Any:
241:    def has_field(obj: dict | object, field_name: str) -> bool:
248:    def generate_base64_uuid(length: int | None = None) -> str:
278:    def parse_args_kwargs(func, *args, **kwargs) -> ParsedArgKwargsResults:
343:    def get_hash(key: str, length: int | None = None) -> str:
350:    def generate_uuid(length: int | None = None) -> str:
358:    def text_to_dict(text: str) -> dict[str, Any]:
378:    def get_response_content(response: BaseResponse) -> Any:
39:    def build_request_params(
75:    def get_openai_functions(self, resources: dict[str, BaseResource]) -> list[OpenAIFunctionCall]:
89:    async def call_requested_tools(self, tool_calls: list[OpenAIFunctionCall]) -> list[dict[str, Any]]:
189:    async def call_tools_legacy(self, tool_calls: list[dict[str, Any]], available_resources: list[BaseResource]) -> list[BaseResponse]:
218:    def format_tool_call_message(self, response_message: dict[str, Any], tool_calls: list[OpenAIFunctionCall]) -> dict[str, Any]:
236:    def has_tool_calls(self, response_message: dict[str, Any]) -> bool:
250:    def register_resources(self, available_resources: dict[str, Any]) -> None:
259:    def unregister_resources(self, available_resources: dict[str, Any]) -> None:
38:    async def initialize(self) -> None:
45:    async def query(self, query: str, num_results: int = 10) -> str:
136:    def _validate_decay_parameters(self) -> None:
150:    def decay_rate(self) -> float:
155:    def decay_rate(self, value: float) -> None:
174:    def half_life(self) -> float:
186:    def decay_interval(self) -> int:
191:    def decay_interval(self, value: int) -> None:
209:    def _should_decay(self) -> bool:
221:    async def _maybe_decay(self) -> None:
240:            def run_decay():
247:    async def decay_memories(self, intervals_passed: float = 1.0) -> None:
280:    async def initialize(self) -> None:
287:    async def cleanup(self) -> None:
295:    async def store(
339:    async def retrieve(self, query: str | None = None, limit: int | None = None) -> BaseResponse:
364:    async def update_importance(self, memory_id: int, importance: float) -> BaseResponse:
384:    def get_decay_stats(self) -> dict[str, Any]:
403:    def can_handle(self, request: dict[str, Any]) -> bool:
449:    def can_handle(self, request: dict[str, Any]) -> bool:
495:    def can_handle(self, request: dict[str, Any]) -> bool:
541:    async def _maybe_decay(self) -> None:
545:    async def decay_memories(self, intervals_passed: float = 1.0) -> None:
549:    def get_decay_stats(self) -> dict[str, Any]:
559:    def can_handle(self, request: dict[str, Any]) -> bool:
17:async def configure_poet(config: dict[str, Any]):
50:async def get_poet_domains():
21:async def upload_document(
43:async def create_document(
69:async def get_document(document_id: int, db: Session = Depends(get_db), document_service=Depends(get_document_service)):
85:async def list_documents(
104:async def download_document(document_id: int, db: Session = Depends(get_db), document_service=Depends(get_document_service)):
126:async def update_document(
144:async def delete_document(document_id: int, db: Session = Depends(get_db), document_service=Depends(get_document_service)):
40:async def generate_agent(request: AgentGenerationRequest, agent_service=Depends(get_agent_service)):
117:async def refine_agent_description(request: AgentDescriptionRequest, db: Session = Depends(get_db)):
196:async def generate_agent_code(request: AgentCodeGenerationRequest, agent_service=Depends(get_agent_service)):
234:async def deploy_agent(request: AgentDeployRequest, db: Session = Depends(get_db)):
284:async def check_dana_syntax(request: DanaSyntaxCheckRequest):
307:async def validate_code(request: CodeValidationRequest):
330:async def fix_code(request: CodeFixRequest):
358:async def process_agent_documents(request: ProcessAgentDocumentsRequest, agent_service=Depends(get_agent_service)):
394:async def list_agents(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
418:async def get_agent(agent_id: int, db: Session = Depends(get_db)):
444:async def create_agent(agent: AgentCreate, db: Session = Depends(get_db)):
470:async def update_agent(agent_id: int, agent: AgentCreate, db: Session = Depends(get_db)):
503:async def delete_agent(agent_id: int, db: Session = Depends(get_db)):
525:async def generate_agent_from_prompt(
560:async def update_agent_description(agent_id: int, request: AgentDescriptionRequest, agent_service=Depends(get_agent_service)):
585:async def validate_agent_code(request: CodeValidationRequest):
599:async def fix_agent_code(request: CodeFixRequest):
613:async def upload_knowledge_file(
668:async def open_file(file_path: str):
681:def _extract_agent_info_from_code(dana_code: str) -> tuple[str | None, str | None]:
19:async def send_chat_message(request: ChatRequest, db: Session = Depends(get_db), chat_service=Depends(get_chat_service)):
19:async def create_topic(request: TopicCreate, db: Session = Depends(get_db), topic_service=Depends(get_topic_service)):
33:async def get_topic(topic_id: int, db: Session = Depends(get_db), topic_service=Depends(get_topic_service)):
49:async def list_topics(
63:async def update_topic(topic_id: int, topic_data: TopicCreate, db: Session = Depends(get_db), topic_service=Depends(get_topic_service)):
81:async def delete_topic(topic_id: int, db: Session = Depends(get_db), topic_service=Depends(get_topic_service)):
19:async def create_conversation(
33:async def get_conversation(
54:async def list_conversations(
72:async def update_conversation(
90:async def delete_conversation(conversation_id: int, db: Session = Depends(get_db), conversation_service=Depends(get_conversation_service)):
107:async def create_message(
121:async def list_messages(
139:async def get_message(
157:async def update_message(
179:async def delete_message(
16:def get_db():
49:async def generate_agent_na(request: AgentGeneratorNARequest):
148:def health():
26:def run_na_file(request: RunNAFileRequest):
31:async def write_multi_file_project(project: MultiFileProject):
77:async def write_multi_file_project_temp(project: MultiFileProject):
124:async def validate_multi_file_project(project: MultiFileProject):
174:            if "agent" in file_info.content.lower() and "def solve" not in file_info.content:
186:        def has_circular_deps(filename, visited=None, path=None):
228:async def open_agent_folder(request: dict):
263:async def get_task_status(task_id: str):
288:async def deep_train_agent(request: dict):
38:async def _llm_fallback(agent_name: str, agent_description: str, message: str) -> str:
109:async def test_agent(request: AgentTestRequest):
10:def health():
15:def get_root_info():
34:def serve_react_index():
12:def run_na_file_service(request: RunNAFileRequest):
23:async def lifespan(app: FastAPI):
31:def create_app():
86:    async def serve_spa(full_path: str):
119:    def startup(self) -> None:
137:    def shutdown(self) -> None:
155:    def get_client(self) -> APIClient:
163:    def local_mode(self) -> bool:
169:    def _load_config(self) -> None:
198:    def _normalize_service_uri(self) -> None:
221:    def _init_api_client(self) -> None:
229:    def _start_local_server(self) -> None:
284:    def _is_server_running(self, port: int) -> bool:
294:    def _find_free_port(self) -> int:
300:    def _wait_for_server_ready(self, port: int, timeout: int = 30) -> None:
319:    def _validate_remote_connection(self) -> None:
343:    def check_health(self) -> bool:
362:    def get_service_uri(self) -> str:
366:    def get_api_key(self) -> str:
9:def main() -> None:
6:def get_multi_file_agent_generation_prompt(intentions: str, current_code: str = "", has_docs_folder: bool = False) -> str:
42:def solve(self : RetrievalExpertAgent, query: str) -> str:
65:def search_document(package: RetrievalPackage) -> RetrievalPackage:
72:def refine_query(package: RetrievalPackage) -> RetrievalPackage:
77:def should_use_rag(package: RetrievalPackage) -> RetrievalPackage:
81:def get_answer(package: RetrievalPackage) -> str:
6:def generate_mock_agent_code(messages, current_code=""):
34:def solve(weather_agent : WeatherAgent, problem : str):
46:def solve(assistant_agent : AssistantAgent, problem : str):
62:def solve(data_agent : DataAgent, problem : str):
78:def solve(document_agent : DocumentAgent, problem : str):
94:def solve(email_agent : EmailAgent, problem : str):
110:def solve(knowledge_agent : KnowledgeAgent, problem : str):
122:def solve(custom_agent : CustomAgent, problem : str):
42:    def startup(self) -> None:
63:    def shutdown(self) -> None:
75:    def _ensure_started(self) -> None:
80:    def post(self, endpoint: str, data: dict[str, Any]) -> dict[str, Any]:
118:    def get(self, endpoint: str, params: dict[str, Any] | None = None) -> dict[str, Any]:
153:    def health_check(self) -> bool:
178:    def close(self):
193:def create_client(base_uri: str, api_key: str | None = None) -> APIClient:
24:    async def process_chat_message(self, chat_request: ChatRequest, db_session) -> ChatResponse:
81:    async def _get_or_create_conversation(self, chat_request: ChatRequest, db_session) -> Conversation:
102:    async def _save_message(self, conversation_id: int, sender: str, content: str, db_session) -> Message:
113:    async def _generate_agent_response(self, chat_request: ChatRequest, conversation: Conversation, db_session) -> str:
124:def get_chat_service() -> ChatService:
24:    async def create_conversation(self, conversation_data: ConversationCreate, db_session) -> ConversationRead:
54:    async def get_conversation(
110:    async def list_conversations(
144:    async def update_conversation_title(self, conversation_id: int, new_title: str, db_session) -> ConversationRead | None:
178:    async def update_conversation(self, conversation_id: int, conversation_data: ConversationCreate, db_session) -> ConversationRead | None:
213:    async def create_message(self, conversation_id: int, message_data: MessageCreate, db_session) -> MessageRead:
245:    async def list_messages(self, conversation_id: int, limit: int = 100, offset: int = 0, db_session=None) -> list[MessageRead]:
284:    async def get_message(self, conversation_id: int, message_id: int, db_session) -> MessageRead | None:
315:    async def update_message(self, conversation_id: int, message_id: int, message_data: MessageCreate, db_session) -> MessageRead | None:
352:    async def delete_message(self, conversation_id: int, message_id: int, db_session) -> bool:
378:    async def delete_conversation(self, conversation_id: int, db_session) -> bool:
408:    async def add_message(self, conversation_id: int, message_data: MessageCreate, db_session) -> MessageRead:
440:    async def get_conversation_messages(
486:def get_conversation_service() -> ConversationService:
34:    async def upload_document(
99:    async def get_document(self, document_id: int, db_session) -> DocumentRead | None:
131:    async def update_document(self, document_id: int, document_data: DocumentUpdate, db_session) -> DocumentRead | None:
178:    async def delete_document(self, document_id: int, db_session) -> bool:
210:    async def list_documents(
255:    async def get_file_path(self, document_id: int, db_session) -> str | None:
277:    def _get_mime_type(self, filename: str) -> str:
311:def get_document_service() -> DocumentService:
26:    async def create_topic(self, topic_data: TopicCreate, db_session) -> TopicRead:
58:    async def get_topic(self, topic_id: int, db_session) -> TopicRead | None:
83:    async def get_topic_by_name(self, name: str, db_session) -> TopicRead | None:
108:    async def list_topics(self, limit: int = 100, offset: int = 0, search: str | None = None, db_session=None) -> list[TopicRead]:
140:    async def update_topic(self, topic_id: int, topic_data: TopicCreate, db_session) -> TopicRead | None:
182:    async def delete_topic(self, topic_id: int, db_session) -> bool:
216:    async def get_topic_statistics(self, topic_id: int, db_session) -> dict[str, Any]:
255:def get_topic_service() -> TopicService:
13:    def clean_generated_code(code: str) -> str:
79:    def parse_multi_file_response(response: str) -> dict:
209:                if line.startswith("def "):
218:                    stub_lines.append(f"def {tool}(query: str) -> str:")
232:    def ensure_all_files_present(project: dict) -> dict:
258:    def get_file_template(filename: str) -> str:
268:def solve(self : Georgia, query: str) -> str:
282:def process_request(package: AgentPackage) -> AgentPackage:
287:def generate_response(package: AgentPackage) -> str:
316:    def determine_file_type(filename: str) -> str:
332:    def get_file_description(filename: str) -> str:
344:    def extract_dependencies(content: str) -> list[str]:
360:    def get_fallback_template() -> str:
369:def solve(basic_agent : BasicAgent, problem : str):
45:    async def initialize(self):
59:    async def generate_agent_code(
156:    async def generate_agent_files_from_prompt(
242:    async def analyze_agent_capabilities(
320:    async def analyze_conversation_completeness(self, messages: list[dict[str, Any]]) -> dict[str, Any]:
393:    async def cleanup(self):
400:    async def _extract_user_intentions(self, messages: list[dict[str, Any]], current_code: str = "") -> str:
442:    def _extract_requirements(self, messages: list[dict[str, Any]]) -> str:
452:    def _create_generation_prompt(self, intentions: str, current_code: str = "", multi_file: bool = False) -> str:
480:    def _create_phase_2_prompt(self, prompt: str, messages: list[dict[str, Any]], agent_summary: dict[str, Any], multi_file: bool) -> str:
505:    def _create_capabilities_analysis_prompt(self, conversation_text: str, all_code_content: str) -> str:
519:    def _extract_response_content(self, result) -> str:
533:    def _extract_summary_from_code_and_conversation(self, dana_code: str, conversation_text: str) -> str:
555:    def _extract_knowledge_domains_from_code(self, dana_code: str, conversation_text: str) -> list[str]:
562:    def _extract_workflow_steps_from_code(self, dana_code: str, conversation_text: str) -> list[str]:
571:    def _extract_agent_tools_from_code(self, dana_code: str) -> list[str]:
583:async def get_agent_service() -> AgentService:
599:def get_multi_file_agent_generation_prompt(intentions: str, current_code: str = "", has_docs_folder: bool = False) -> str:
635:def solve(self : RetrievalExpertAgent, query: str) -> str:
658:def search_document(package: RetrievalPackage) -> RetrievalPackage:
665:def refine_query(package: RetrievalPackage) -> RetrievalPackage:
670:def should_use_rag(package: RetrievalPackage) -> RetrievalPackage:
674:def get_answer(package: RetrievalPackage) -> str:
806:def generate_mock_agent_code(messages, current_code=""):
834:def solve(weather_agent : WeatherAgent, problem : str):
846:def solve(assistant_agent : AssistantAgent, problem : str):
862:def solve(data_agent : DataAgent, problem : str):
878:def solve(document_agent : DocumentAgent, problem : str):
894:def solve(email_agent : EmailAgent, problem : str):
910:def solve(knowledge_agent : KnowledgeAgent, problem : str):
922:def solve(custom_agent : CustomAgent, problem : str):
45:    async def initialize(self):
59:    async def generate_agent_code(
159:    async def _extract_user_intentions(self, messages: list[dict[str, Any]], current_code: str = "") -> str:
224:    def _extract_requirements(self, messages: list[dict[str, Any]]) -> str:
245:    def _create_generation_prompt(self, intentions: str, current_code: str = "", multi_file: bool = False) -> str:
293:def solve([agent_name] : [AgentName], problem : str):
341:def solve([agent_name] : [AgentName], problem : str):
362:    async def cleanup(self):
373:async def get_agent_generator() -> AgentGenerator:
391:async def generate_agent_code_from_messages(
416:async def generate_agent_code_na(messages: list[dict[str, Any]], current_code: str = "") -> tuple[str, str | None]:
492:def _create_agent_generator_na_code(messages: list[dict[str, Any]], current_code: str) -> str:
519:def extract_intentions(messages: list) -> str:
551:def generate_agent_code(messages: list, current_code: str) -> str:
574:- Function parameters must be unquoted: def solve(agent_name : AgentName, problem : str)
576:- **All function definitions (like def solve(...)) must be outside the agent block. The agent block should only contain attribute assignments.**
589:def solve([agent_name] : [AgentName], problem : str):
625:def _test_generated_code(code: str) -> Any:
665:async def _fix_generated_code_with_agent(code: str, error: str, messages: list[dict[str, Any]]) -> str:
722:def _create_code_fixer_na_code(code: str, error: str, messages: list[dict[str, Any]]) -> str:
754:def solve(code_fixer : CodeFixerAgent, problem : str):
776:- Function parameters must be unquoted: def solve(agent_name : AgentName, problem : str)
778:- **All function definitions (like def solve(...)) must be outside the agent block. The agent block should only contain attribute assignments.**
791:def solve([agent_name] : [AgentName], problem : str):
814:def _generate_simple_fallback_agent(messages: list[dict[str, Any]]) -> str:
883:def solve({agent_name.lower()} : {agent_name}, problem : str):
891:async def analyze_conversation_completeness(messages: list[dict[str, Any]]) -> dict[str, Any]:
988:async def analyze_agent_capabilities(
1119:def _extract_summary_from_code_and_conversation(dana_code: str, conversation_text: str) -> str:
1232:def _extract_knowledge_domains_from_code(dana_code: str, conversation_text: str) -> list[str]:
1292:def _extract_workflow_steps_from_code(dana_code: str, conversation_text: str) -> list[str]:
1361:def _extract_agent_tools_from_code(dana_code: str) -> list[str]:
1407:        if line.strip().startswith("def ") and "solve(" not in line:
1408:            func_name = line.strip().split("(")[0].replace("def ", "")
1482:def _extract_solve_function_content(dana_code: str) -> str:
1489:        if "def solve(" in line:
1501:def _extract_agent_name_from_code(dana_code: str) -> str:
1510:def _extract_agent_description_from_code(dana_code: str) -> str:
1519:def _get_fallback_template() -> str:
1534:def solve(basic_agent : BasicAgent, problem : str):
1543:async def generate_agent_files_from_prompt(
1658:def _create_phase_2_prompt(prompt: str, messages: list[dict[str, Any]], agent_summary: dict[str, Any], multi_file: bool) -> str:
1715:def solve(self : {agent_class}, query: str) -> str:
1729:def search_document(package: RetrievalPackage) -> RetrievalPackage:
1736:def refine_query(package: RetrievalPackage) -> RetrievalPackage:
1741:def should_use_rag(package: RetrievalPackage) -> RetrievalPackage:
1745:def get_answer(package: RetrievalPackage) -> str:
1940:def get_multi_file_agent_generation_prompt(intentions: str, current_code: str = "", has_docs_folder: bool = False) -> str:
1976:def solve(self : RetrievalExpertAgent, query: str) -> str:
1999:def search_document(package: RetrievalPackage) -> RetrievalPackage:
2006:def refine_query(package: RetrievalPackage) -> RetrievalPackage:
2011:def should_use_rag(package: RetrievalPackage) -> RetrievalPackage:
2015:def get_answer(package: RetrievalPackage) -> str:
2147:def generate_mock_agent_code(messages, current_code=""):
2175:def solve(weather_agent : WeatherAgent, problem : str):
2187:def solve(assistant_agent : AssistantAgent, problem : str):
2203:def solve(data_agent : DataAgent, problem : str):
2219:def solve(document_agent : DocumentAgent, problem : str):
2235:def solve(email_agent : EmailAgent, problem : str):
2251:def solve(knowledge_agent : KnowledgeAgent, problem : str):
2263:def solve(custom_agent : CustomAgent, problem : str):
42:    async def create_agent_description(
121:    async def generate_agent_code(self, agent_metadata: dict[str, Any], messages: list[dict[str, Any]], prompt: str = "") -> dict[str, Any]:
184:    async def upload_knowledge_file(
284:    async def update_agent_description(self, agent_metadata: dict[str, Any], messages: list[dict[str, Any]]) -> dict[str, Any]:
304:    def get_agent_folder(self, agent_id: int) -> Path | None:
319:    def _create_agent_folder(self, agent_id: int, agent_name: str) -> Path:
327:    async def _extract_agent_requirements(self, messages: list[dict[str, Any]]) -> dict[str, Any]:
472:    def _merge_agent_requirements(self, new_requirements: dict[str, Any], existing_data: dict[str, Any]) -> dict[str, Any]:
501:    async def _generate_intelligent_response(
512:    def _is_ready_for_code_generation(self, agent_requirements: dict[str, Any], conversation_analysis: dict[str, Any]) -> bool:
523:    async def _analyze_capabilities_for_description(self, messages: list[dict[str, Any]]) -> AgentCapabilities | None:
537:    async def _store_multi_file_project(
556:    def _create_multi_file_project_object(self, multi_file_project: dict[str, Any]) -> MultiFileProject:
577:    async def _update_tools_with_rag(self, agent_folder: Path):
598:    async def _clear_rag_cache(self, agent_folder: Path):
605:    async def _regenerate_agent_with_knowledge(
710:    async def _generate_consistent_summary_with_knowledge(
821:    async def _generate_llm_summary_with_knowledge(
985:    def _format_conversation_context(self, conversation_context: list[dict[str, Any]]) -> str:
994:    def _format_existing_capabilities(self, existing_capabilities: dict[str, Any]) -> str:
1024:    def _fallback_summary_enhancement(
1046:    def _merge_capabilities_with_knowledge(self, existing_capabilities: dict[str, Any], uploaded_filename: str) -> dict[str, Any]:
1112:    def _enhance_description_with_knowledge(self, existing_description: str, filename: str, requirements: dict[str, Any]) -> str:
1129:    def _enhance_capabilities_with_knowledge(self, existing_capabilities: Any, filename: str) -> dict[str, Any]:
1133:    def _generate_knowledge_follow_up(self, filename: str, requirements: dict[str, Any]) -> str:
1138:    async def _check_ready_for_code_generation(self, conversation_context: list[dict[str, Any]], agent_metadata: dict[str, Any]) -> bool:
1154:    async def _generate_upload_response(
1198:def get_agent_manager() -> AgentManager:
62:    def generate_enhanced_function(self, func_info: FunctionInfo) -> str:
83:    def generate_perceive(self, func_info: FunctionInfo) -> CodeBlock:
94:    def generate_operate(self, func_info: FunctionInfo) -> CodeBlock:
105:    def generate_enforce(self, func_info: FunctionInfo) -> CodeBlock:
116:    def generate_train(self, func_info: FunctionInfo) -> CodeBlock | None:
133:    def _generate_perceive(self, func_info: FunctionInfo) -> CodeBlock:
138:    def _generate_operate(self, func_info: FunctionInfo) -> CodeBlock:
143:    def _generate_enforce(self, func_info: FunctionInfo) -> CodeBlock:
147:    def _generate_train(self, func_info: FunctionInfo) -> CodeBlock | None:
151:    def _merge_code_blocks(self, parent: CodeBlock | None, child: CodeBlock | None, phase: str) -> CodeBlock:
184:    def _generate_orchestrator(
216:def enhanced_{func_info.name}{signature}:
295:    def _indent_code(self, code: str, spaces: int) -> str:
300:    def _extract_parameter_names(self, signature: str) -> list[str]:
329:    def _generate_perceive(self, func_info: FunctionInfo) -> CodeBlock:
341:    def _generate_operate(self, func_info: FunctionInfo) -> CodeBlock:
370:    def _generate_enforce(self, func_info: FunctionInfo) -> CodeBlock:
14:def poet(
37:        def diagnose(symptoms: list) -> dict:
49:        def assess_credit_risk(score: int) -> str:
86:    def dana_decorator(original_func: Any) -> Any:
92:        def poet_enhanced_function(*args, **kwargs):
249:def extract_poet_metadata(func: Any) -> dict[str, Any]:
31:    def dict(self) -> dict[str, Any]:
49:    def from_dict(cls, data: builtins.dict[str, Any]) -> "POETConfig":
63:    def from_response(cls, response_data: dict[str, Any]) -> "TranspiledFunction":
92:    def poet(self) -> dict[str, Any]:
197:    def unwrap(self) -> Any:
201:    def raw(self) -> Any:
21:def create_workflow_metadata(
42:        def ingest_document(file_path):
47:        def perform_ocr(document):
61:def create_pipeline_metadata(
104:def with_workflow_metadata(workflow_id: str | None = None, description: str | None = None, version: str = "1.0.0") -> Callable:
119:        def document_processing_workflow(input_data):
127:    def decorator(pipeline_func: Callable) -> Callable:
139:def auto_workflow_metadata(func: Callable) -> Callable:
156:        def ingest_document(file_path):
174:def build_workflow_metadata(*args, **kwargs) -> dict[str, Any]:
35:    def to_dict(self) -> dict[str, Any]:
66:    def extract_function_metadata(self, func: Callable) -> FunctionMetadata:
97:    def _extract_description_from_docstring(self, func: Callable) -> str:
123:    def _extract_poet_config(self, func: Callable) -> dict[str, Any]:
151:    def _extract_additional_params(self, poet_config: dict[str, Any]) -> dict[str, Any]:
185:def extract_workflow_metadata(
219:def extract_pipeline_metadata(pipeline_func: Callable) -> dict[str, Any]:
244:def _extract_functions_from_pipeline(pipeline_func: Callable) -> list[Callable]:
280:def with_metadata(func: Callable, **metadata) -> Callable:
295:def workflow_step(
312:    def decorator(func: Callable) -> Callable:
329:def _extract_first_line_docstring(func: Callable) -> str:
19:    def generate_dana_wrapper(self, function_name: str, config: POETConfig) -> str:
36:def poet_wrapper_{function_name}(*args, **kwargs):
85:    def enhance_function_definition(self, original_function_code: str, config: POETConfig) -> str:
29:    def enforce(self, output: Any, context: dict[str, Any], expected_type: type | None = None) -> Any:
55:    def _validate_output(self, output: Any, expected_type: type | None = None) -> None:
66:    def _enforce_domain_rules(self, output: Any, context: dict[str, Any]) -> None:
11:def financial_services(**kwargs) -> dict[str, Any]:
59:def healthcare(**kwargs) -> dict[str, Any]:
106:def retail_ecommerce(**kwargs) -> dict[str, Any]:
153:def data_processing(**kwargs) -> dict[str, Any]:
200:def security(**kwargs) -> dict[str, Any]:
248:def quick_setup(domain: str, **kwargs) -> dict[str, Any]:
274:def poet_for_domain(domain: str, **kwargs):
41:    def debug_perceive(self, *args, **kwargs) -> dict[str, Any]:
70:    def debug_operate(self, *args, **kwargs) -> dict[str, Any]:
106:    def debug_enforce(self, operation_result: Any) -> dict[str, Any]:
138:    def debug_train(self, operation_result: Any) -> dict[str, Any]:
165:    def debug_full_execution(self, *args, **kwargs) -> dict[str, Any]:
197:def debug_poet_function(func: Callable, config: POETConfig, *args, **kwargs) -> dict[str, Any]:
214:def test_poet_function(func: Callable, test_cases: list[dict[str, Any]], config: POETConfig | None = None) -> dict[str, Any]:
263:def performance_benchmark(func: Callable, iterations: int = 100, *args, **kwargs) -> dict[str, Any]:
30:    def operate(self, func: Callable, args: tuple[Any, ...], kwargs: dict[str, Any], context: dict[str, Any]) -> Any:
29:    def perceive(self, args: tuple[Any, ...], kwargs: dict[str, Any]) -> tuple[tuple[Any, ...], dict[str, Any], dict[str, Any]]:
60:    def _validate_inputs(self, args: tuple[Any, ...], kwargs: dict[str, Any]) -> None:
72:    def _process_domain_inputs(self, args: tuple[Any, ...], kwargs: dict[str, Any], context: dict[str, Any]) -> None:
29:    def train(
74:    def _track_performance(self, training_data: dict[str, Any], execution_time: float) -> None:
83:    def _domain_learning(
98:    def _basic_pattern_recognition(self, training_data: dict[str, Any], input_args: tuple[Any, ...], output: Any) -> None:
110:    def _financial_learning(self, training_data: dict[str, Any], input_args: tuple[Any, ...], output: Any) -> None:
118:    def _healthcare_learning(self, training_data: dict[str, Any], input_args: tuple[Any, ...], output: Any) -> None:
126:    def _data_processing_learning(self, training_data: dict[str, Any], input_args: tuple[Any, ...], output: Any) -> None:
22:    def register_ko_type(self, name: str, ko_class: type) -> None:
35:    def register_ko_config(self, name: str, config: dict[str, Any]) -> None:
45:    def get_ko_type(self, name: str) -> type:
63:    def get_ko_config(self, name: str) -> dict[str, Any]:
81:    def list_ko_types(self) -> list[str]:
89:    def list_ko_configs(self) -> list[str]:
97:    def create_ko_instance(self, name: str, **kwargs) -> Any:
98:    def load_document(self, source: str) -> Document:
103:    def validate_document(self, document: Document) -> bool:
112:    def process(self, input_data: Any) -> Any:
117:    def validate_input(self, input_data: Any) -> bool:
126:    def extract_knowledge(self, document: Document) -> list[KnowledgePoint]:
131:    def validate_knowledge(self, knowledge: KnowledgePoint) -> ValidationResult:
13:def _get_context_manager() -> ContextManager:
25:def _parse_context_type(context_type_str: str) -> ContextType:
58:def context_set(context_type: str, key: str, value: Any) -> bool:
78:def context_get(context_type: str, key: str, default: Any = None) -> Any:
97:def context_has(context_type: str, key: str) -> bool:
115:def context_remove(context_type: str, key: str) -> bool:
133:def context_clear(context_type: str) -> bool:
151:def context_clear_all() -> bool:
165:def context_sync(source_type: str, target_type: str, keys: list[str] | None = None) -> bool:
186:def context_keys(context_type: str) -> list[str]:
204:def context_size(context_type: str) -> int:
222:def context_info(context_type: str) -> dict[str, Any]:
239:def context_snapshot(context_type: str) -> dict[str, Any]:
256:def context_restore(context_type: str, snapshot: dict[str, Any]) -> bool:
275:def context_types() -> list[str]:
289:def context_metrics() -> dict[str, Any]:
305:def context_merge(source_type: str, target_type: str) -> bool:
318:def context_copy(source_type: str, target_type: str, keys: list[str]) -> bool:
332:def context_exists(context_type: str) -> bool:
350:def context_is_empty(context_type: str) -> bool:
365:def to_context_dict(context_type: str) -> dict[str, Any]:
383:def from_context_dict(context_type: str, data: dict[str, Any]) -> bool:
407:def context_validate_key(key: str) -> bool:
424:def context_validate_value(value: Any) -> bool:
444:def context_configure(settings_dict: dict[str, Any]) -> bool:
462:def context_reset() -> bool:
33:    def get_context(self, context_type: ContextType) -> Context:
51:    def set_context_value(self, context_type: ContextType, key: str, value: Any) -> None:
71:    def get_context_value(self, context_type: ContextType, key: str, default: Any = None) -> Any:
85:    def has_context_value(self, context_type: ContextType, key: str) -> bool:
98:    def remove_context_value(self, context_type: ContextType, key: str) -> bool:
116:    def clear_context(self, context_type: ContextType) -> None:
127:    def clear_all_contexts(self) -> None:
134:    def sync_contexts(self, source_type: ContextType, target_type: ContextType, keys: list[str] | None = None) -> None:
167:    def get_context_snapshot(self, context_type: ContextType) -> dict[str, Any]:
179:    def restore_context_snapshot(self, context_type: ContextType, snapshot: dict[str, Any]) -> None:
201:    def get_all_context_types(self) -> list[ContextType]:
210:    def get_context_info(self, context_type: ContextType) -> dict[str, Any]:
228:    def get_metrics(self) -> dict[str, Any]:
242:    def _validate_key(self, key: str) -> None:
257:    def _validate_value(self, value: Any) -> None:
277:    def _invalidate_cache(self, context_type: ContextType) -> None:
287:    def _cleanup_expired_cache(self) -> None:
48:    def set(self, key: str, value: Any) -> None:
64:    def get(self, key: str, default: Any = None) -> Any:
76:    def has(self, key: str) -> bool:
87:    def remove(self, key: str) -> bool:
102:    def clear(self) -> None:
107:    def keys(self) -> list[str]:
115:    def values(self) -> list[Any]:
123:    def items(self) -> list[tuple[str, Any]]:
131:    def size(self) -> int:
139:    def copy(self) -> "Context":
151:    def merge(self, other: "Context") -> None:
166:    def to_dict(self) -> dict[str, Any]:
180:    def from_dict(cls, data: dict[str, Any]) -> "Context":
25:def create_store(store_type: str, settings: dict[str, Any]) -> None:
56:def store_value(key: str, value: Any, store_type: str) -> None:
77:def retrieve_value(key: str, store_type: str) -> Any | None:
100:def delete_value(key: str, store_type: str) -> None:
120:def query_values(store_type: str, **kwargs) -> list[Any]:
143:def close_stores() -> None:
154:def get_store_types() -> dict[str, str]:
168:def get_active_stores() -> list[str]:
178:def convert_dana_to_python(value: Any) -> Any:
196:def convert_python_to_dana(value: Any) -> Any:
28:    def _create_connection(self) -> psycopg2.extensions.connection:
49:    def _ensure_extension(self) -> None:
62:    def _ensure_table(self) -> None:
82:    def _parse_vector(self, vector_data) -> list[float]:
100:    def _validate_key(self, key: str) -> None:
122:    def store(self, key: str, value: Any) -> None:
164:    def retrieve(self, key: str) -> dict[str, Any] | None:
195:    def delete(self, key: str) -> None:
220:    def query(self, **kwargs) -> list[Any]:
271:    def close(self) -> None:
27:    def _create_connection(self) -> psycopg2.extensions.connection:
48:    def _ensure_extension(self) -> None:
61:    def _ensure_table(self) -> None:
91:    def _validate_key(self, key: str) -> None:
113:    def store(self, key: str, value: Any) -> None:
160:    def retrieve(self, key: str, start_time: str | datetime | None = None, end_time: str | datetime | None = None) -> list[dict[str, Any]]:
209:    def delete(self, key: str) -> None:
234:    def query(self, **kwargs) -> list[Any]:
302:    def close(self) -> None:
25:    def _create_connection(self) -> psycopg2.extensions.connection:
46:    def _ensure_default_tables(self) -> None:
69:    def _ensure_table(self, table_name: str) -> None:
92:    def _validate_key(self, key: str) -> None:
115:    def store(self, key: str, value: Any) -> None:
154:    def retrieve(self, key: str) -> dict[str, Any] | None:
189:    def delete(self, key: str) -> None:
219:    def query(
267:    def close(self) -> None:
28:    def _create_client(self) -> redis.Redis:
52:    def _validate_key(self, key: str) -> None:
74:    def store(self, key: str, value: Any) -> None:
103:    def retrieve(self, key: str) -> Any | None:
131:    def delete(self, key: str) -> None:
156:    def query(self, pattern: str) -> list[Any]:
188:    def close(self) -> None:
12:    def store(self, key: str, value: Any) -> None:
16:    def retrieve(self, key: str) -> Any | None:
20:    def delete(self, key: str) -> None:
24:    def query(self, **kwargs) -> list[Any]:
30:    def process(self, parsed_doc: ParsedDocument) -> str:
69:    def validate_input(self, parsed_doc: ParsedDocument) -> bool:
92:    def _extract_from_text_document(self, parsed_doc: ParsedDocument) -> str:
149:    def _extract_from_json_document(self, parsed_doc: ParsedDocument) -> str:
182:    def _extract_from_csv_document(self, parsed_doc: ParsedDocument) -> str:
229:    def _extract_generic_text(self, parsed_doc: ParsedDocument) -> str:
253:    def _json_to_text(self, data: Any, indent: int = 0) -> list[str]:
285:    def _clean_text(self, text: str) -> str:
305:    def _format_metadata(self, metadata: dict[str, Any]) -> str:
22:    def process(self, document: Document) -> ParsedDocument:
63:    def validate_input(self, document: Document) -> bool:
86:    def _parse_text_document(self, document: Document) -> dict[str, Any]:
134:    def _parse_json_document(self, document: Document) -> dict[str, Any]:
164:    def _parse_csv_document(self, document: Document) -> dict[str, Any]:
197:    def _parse_generic_document(self, document: Document) -> dict[str, Any]:
221:    def _analyze_json_schema(self, data: Any, path: str = "") -> dict[str, Any]:
31:    def load_document(self, source: str) -> Document:
81:    def load_documents(self, sources: list[str]) -> list[Document]:
108:    def validate_document(self, document: Document) -> bool:
143:    def _load_content(self, source: str, format_ext: str) -> str:
164:    def _load_text_file(self, source: str) -> str:
169:    def _load_json_file(self, source: str) -> str:
175:    def _load_csv_file(self, source: str) -> str:
180:    def _load_pdf_file(self, source: str) -> str:
239:    def _generate_document_id(self, source: str) -> str:
68:    def process(self, knowledge_points: list[KnowledgePoint]) -> dict[str, Any]:
118:    def validate_input(self, knowledge_points: list[KnowledgePoint]) -> bool:
142:    def search_similar(self, query_point: KnowledgePoint, candidate_points: list[KnowledgePoint] | None = None) -> SimilarityResult:
195:    def _build_knowledge_index(self, knowledge_points: list[KnowledgePoint]) -> None:
204:    def _generate_content_vectors(self, knowledge_points: list[KnowledgePoint]) -> None:
216:    def _generate_content_vector(self, content: str) -> np.ndarray:
272:    def _calculate_vector_similarity(self, vector1: np.ndarray, vector2: np.ndarray) -> float:
300:    def _identify_matching_features(self, kp1: KnowledgePoint, kp2: KnowledgePoint) -> list[str]:
340:    def _find_similarities(self, knowledge_points: list[KnowledgePoint]) -> list[dict[str, Any]]:
378:    def _create_semantic_matches(self, similarity_mappings: list[dict[str, Any]]) -> list[SemanticMatch]:
406:    def _determine_match_type(self, matching_features: list[str]) -> str:
429:    def _generate_similarity_clusters(self, semantic_matches: list[SemanticMatch]) -> list[dict[str, Any]]:
465:    def _find_connected_points(self, start_id: str, semantic_matches: list[SemanticMatch]) -> set:
491:    def _calculate_cluster_similarity(self, cluster_ids: list[str], semantic_matches: list[SemanticMatch]) -> float:
508:    def _get_dominant_match_type(self, cluster_ids: list[str], semantic_matches: list[SemanticMatch]) -> str:
531:    def _calculate_search_confidence(self, similarities: list[dict[str, Any]]) -> float:
552:    def _get_vector_dimensions(self) -> int:
150:    def process(self, knowledge_points: list[KnowledgePoint]) -> dict[str, Any]:
204:    def validate_input(self, knowledge_points: list[KnowledgePoint]) -> bool:
228:    def expand_context(self, knowledge_point: KnowledgePoint) -> list[ContextExpansion]:
271:    def validate_context(self, knowledge_point: KnowledgePoint) -> ContextValidation:
310:    def _parse_expansion_response(self, response: BaseResponse, source_id: str) -> list[ContextExpansion]:
363:    def _parse_validation_response(self, response: BaseResponse, context_id: str) -> ContextValidation:
434:    def _rule_based_expansion(self, knowledge_point: KnowledgePoint) -> list[ContextExpansion]:
501:    def _rule_based_validation(self, knowledge_point: KnowledgePoint) -> ContextValidation:
562:    def _assess_response_quality(self, expansion_data: dict[str, Any]) -> float:
593:    def _create_context_relationships(
641:    def _generate_context_summary(self, expansions: list[ContextExpansion], validations: list[ContextValidation]) -> dict[str, Any]:
675:    def _calculate_average_confidence(self, expansions: list[ContextExpansion]) -> float:
689:    def _calculate_average_validation_score(self, validations: list[ContextValidation]) -> float:
703:    def _calculate_validation_pass_rate(self, validations: list[ContextValidation]) -> float:
718:    def _get_common_issues(self, validations: list[ContextValidation]) -> list[str]:
41:    def process(self, document: Document) -> list[KnowledgePoint]:
77:    def validate_input(self, document: Document) -> bool:
99:    def _extract_with_llm(self, document: Document) -> list[KnowledgePoint]:
146:    def _build_extraction_prompt(self, document: Document) -> str:
191:    def _extract_response_text(self, response_content: Any) -> str:
258:    def _parse_llm_response(self, response: str, document: Document) -> list[KnowledgePoint]:
310:    def _create_knowledge_point(self, data: dict[str, Any], document: Document) -> KnowledgePoint | None:
357:    def _fallback_extraction(self, document: Document) -> list[KnowledgePoint]:
400:    def _is_potentially_important(self, sentence: str) -> bool:
442:    def _generate_knowledge_point_id(self) -> str:
450:    def _get_timestamp(self) -> str:
108:    def process(self, knowledge_points: list[KnowledgePoint]) -> dict[str, Any]:
166:    def validate_input(self, knowledge_points: list[KnowledgePoint]) -> bool:
190:    def _categorize_knowledge_point(self, knowledge_point: KnowledgePoint) -> list[dict[str, Any]]:
245:    def _calculate_keyword_similarity(self, text: str, keywords: list[str]) -> float:
272:    def _determine_relationship_type(self, similarity_score: float) -> str:
288:    def _map_knowledge_point_relationships(self, knowledge_points: list[KnowledgePoint]) -> list[dict[str, Any]]:
329:    def _calculate_content_similarity(self, content1: str, content2: str) -> float:
351:    def _have_contextual_relationship(self, kp1: KnowledgePoint, kp2: KnowledgePoint) -> bool:
378:    def _find_shared_context(self, kp1: KnowledgePoint, kp2: KnowledgePoint) -> dict[str, Any]:
398:    def _build_category_hierarchy(self) -> dict[str, Any]:
422:    def _generate_categorization_summary(
15:    def extract_text(self, content: str) -> str:
19:    def extract_metadata(self, content: str) -> dict[str, Any]:
15:    def parse(self, content: str) -> dict[str, Any]:
19:    def parse_batch(self, contents: list[str]) -> list[dict[str, Any]]:
15:    def load(self, source: str) -> str:
20:    def load_batch(self, sources: list[str]) -> list[str]:
91:    def execute(self, input_data: Any, context: Any = None) -> Any:
131:    def _create_step_context(self, input_data: Any, context: Any = None) -> StepExecutionContext:
156:    def _validate_pre_conditions(self, input_data: Any, context: StepExecutionContext) -> None:
166:    def _validate_post_conditions(self, result: Any, context: StepExecutionContext) -> None:
176:    def _execute_function(self, input_data: Any, context: StepExecutionContext) -> Any:
180:        def _timeout_handler(signum, frame):
217:        def composed_function(input_data: Any) -> Any:
232:    def clone(self, **overrides) -> "WorkflowStep":
255:    def from_function(
279:        def decorator(func: Callable) -> "WorkflowStep":
39:    def add_context(self, key: str, value: Any) -> None:
43:    def get_context(self, key: str, default: Any = None) -> Any:
72:    def execute(
132:    def _validate_workflow(self, workflow: Any) -> None:
140:    def _execute_step_list(self, steps: list[WorkflowStep], input_data: Any, context: WorkflowExecutionContext) -> Any:
177:    def _execute_composed_function(self, composed_func: Callable, input_data: Any, context: WorkflowExecutionContext) -> Any:
189:    def _post_execution_processing(self, context: WorkflowExecutionContext, result: Any) -> None:
201:    def _handle_execution_error(self, context: WorkflowExecutionContext, error: Exception) -> None:
220:    def create_workflow_step(
65:    def validate_workflow(self, workflow: Any, context: Any = None) -> SafetyResult:
103:    def validate_step(self, step: Any, context: Any = None) -> SafetyResult:
169:    def add_validation_rule(self, name: str, rule: Callable) -> None:
180:    def remove_validation_rule(self, name: str) -> bool:
196:    def _register_default_rules(self) -> None:
203:    def _validate_step_list(self, steps: list, context: Any = None) -> SafetyResult:
249:    def _validate_composed_function(self, func: Callable, context: Any = None) -> SafetyResult:
285:    def _validate_function(self, func: Callable, name: str) -> SafetyResult:
316:    def _check_dangerous_operations(self, func: Callable, name: str) -> SafetyResult:
355:    def _is_workflow_list(self, workflow: Any) -> bool:
359:    def _rule_basic_structure(self, workflow: Any, context: Any = None) -> SafetyResult:
368:    def _rule_no_infinite_recursion(self, workflow: Any, context: Any = None) -> SafetyResult:
382:    def _rule_reasonable_complexity(self, workflow: Any, context: Any = None) -> SafetyResult:
400:    def get_validation_summary(self) -> dict[str, Any]:
72:    def add_knowledge(self, content: str, source: str, tags: list[str] | None = None, metadata: dict[str, Any] | None = None) -> str:
106:    def get_knowledge(self, knowledge_id: str) -> KnowledgePoint | None:
118:    def find_by_tag(self, tag: str) -> list[KnowledgePoint]:
131:    def search_knowledge(
166:    def create_context_snapshot(self, metadata: dict[str, Any] | None = None) -> str:
186:    def get_context_snapshot(self, snapshot_id: str) -> ContextSnapshot | None:
198:    def clear_knowledge(self, source: str | None = None) -> int:
231:    def get_stats(self) -> dict[str, Any]:
250:    def _enforce_limit(self) -> None:
264:    def export_knowledge(self, source: str | None = None) -> dict[str, Any]:
291:    def import_knowledge(self, data: dict[str, Any]) -> int:
40:    def search(self, query: str, candidates: list[str]) -> SimilarityResult:
50:    def validate_input(self, knowledge_points: list[Any]) -> bool:
36:    def expand(self, context: dict[str, Any], knowledge_base: list[Any]) -> ContextExpansion:
41:    def validate(self, context: dict[str, Any]) -> ContextValidation:
15:    def extract(self, content: str) -> dict[str, Any]:
20:    def extract_batch(self, contents: list[str]) -> list[dict[str, Any]]:
34:    def categorize(self, content: str) -> list[KnowledgeCategory]:
39:    def find_relationships(self, categories: list[KnowledgeCategory]) -> list[CategoryRelationship]:
15:    def search(self, query: str, candidates: list[str]) -> list[str]:
20:    def rank(self, query: str, candidates: list[str]) -> list[tuple[str, float]]:
34:    def expand(self, context: str, knowledge_base: list[str]) -> list[str]:
