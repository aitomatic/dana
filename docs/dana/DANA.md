<p align="center">
  <img src="https://cdn.prod.website-files.com/62a10970901ba826988ed5aa/62d942adcae82825089dabdb_aitomatic-logo-black.png" alt="Aitomatic Logo" width="400" style="border: 2px solid #666; border-radius: 10px; padding: 20px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);"/>
</p>

# DANA (Domain-Aware NeuroSymbolic Architecture)

## 🧭 Vision

DANA is a universal program format and execution runtime that enables intelligent agents — human or machine — to reason, act, and collaborate through structured, interpretable programs.

It serves as the missing link between natural language objectives and tool-assisted, stateful action. DANA programs are concise, auditable, explainable, and can be authored by LLMs, domain experts, or both.

---

## 💡 Motivation & Problem

Modern AI systems struggle with:

* ✖️ **Prompt chains are fragile** — hard to debug, hard to maintain
* ✖️ **Plans are opaque** — impossible to inspect or explain mid-flight
* ✖️ **Tool use is scattered** — logic is buried in code, not declarative programs
* ✖️ **State is implicit** — no shared memory model or traceable updates

Symbolic systems offer structure but lack adaptability. LLMs offer creativity but lack transparency. DANA bridges the two.

---

## ✅ Solution

DANA introduces a lightweight domain-aware program language and runtime. It allows:

* 🧠 **Programs as first-class reasoning artifacts**
* 📦 **Shared state containers** (`agent`, `world`, `temp`, `execution`)
* 🧩 **Reusable logic units** via a structured Knowledge Base (KB)
* 🧾 **Declarative goals**, **imperative execution**
* 📜 **Bidirectional mapping to/from natural language**

DANA can:

* Be generated by a planning agent (like GMA)
* Be executed line-by-line by a runtime
* Interact with tools, LLMs, and memory
* Be stored, versioned, tested, and explained

---

## 🔄 Architecture Overview

### Emitters and Interpreters of DANA

| Actor             | Type               | Role(s) in DANA            | Description                                                        |
| ----------------- | ------------------ | -------------------------- | ------------------------------------------------------------------ |
| **User (Human)**  | Person             | 🖋 Emitter                 | Writes DANA directly to define goals, logic, or KB entries         |
| **GMA**           | Agent              | 🖋 Emitter                 | General planner that emits DANA plans from objectives              |
| **DXA**           | Domain Agent       | 🖋 Emitter                 | Emits specialized domain logic/workflows, often tied to KB content |
| **KB Maintainer** | Person or Agent    | 🖋 Emitter                 | Curates reusable DANA programs as structured knowledge             |
| **Tool Resource** | System Component   | ✅ Interpreter              | Executes atomic tool-backed actions referenced in DANA             |
| **Local Runtime** | System Component   | ✅ Interpreter              | Executes DANA deterministically except for `reason(...)`           |
| **DANA_LLM**      | LLM Wrapper Module | 🖋 Emitter + ✅ Interpreter | Emits code and executes reasoning operations                       |
| **AgentRuntime**  | System Component   | 🔁 Coordinator             | Orchestrates execution and manages delegation across all actors    |

### State Model

DANA programs operate over a shared `RuntimeContext`, which is composed of multiple memory scopes (state containers). These include:

| Scope        | Description                                |
| ------------ | ------------------------------------------ |
| `agent:`     | Long-term agent state (identity, traits)   |
| `world:`     | External observations and sensed data      |
| `temp:`      | Ephemeral memory — scoped to a single step |
| `stmem:`     | Short-term memory — scoped to a session    |
| `ltmem:`     | Long-term memory — persisted over time     |
| `execution:` | Execution trace, status, and control flags |
| `private:`   | Local scope variables                      |
| `system:`    | Runtime configuration (log levels, ID)     |
| *custom:*    | User-defined namespaces for workflows      |

### Security Design

**The `dana.runtime` module is the primary enforcer of security during the execution of a DANA program.** It manages the `RuntimeContext` for the duration of the execution and enforces access policies based on the defined scopes and program logic.

| Security Concern            | Enforced By              | Mechanism                                      |
| --------------------------- | ------------------------ | ---------------------------------------------- |
| Scope restrictions          | `dana.runtime`           | Limits visible/writable scopes during execution |
| State mutation permissions  | `dana.runtime`           | Controlled state updates via instructions      |
| Tool/API usage validation   | `dana.runtime`           | Ensures `use` targets are valid/allowed        |
| LLM output handling         | `dana.runtime`           | Manages `reason` call results and potential errors |
| Execution logging           | `dana.runtime`           | Tracks execution steps within the DANA context |
| Resource constraints        | `dana.runtime`           | (Optional) Limits execution steps, time, memory |

---

## 💡 Example Use Cases

### 1. Multi-Step Risk Assessment

**With DANA:**
```python
temp.supplier = {}
temp.supplier.summary = reason("Summarize this supplier's profile", context=temp.supplier)
temp.supplier.financial_risk = reason("Assess financial risk", context=temp.supplier)
temp.supplier.legal_risk = reason("Assess legal risk", context=temp.supplier)
temp.final_decision = reason("Would you approve this supplier?", context=temp.supplier)
agent.supplier_approval = temp.final_decision
```

### 2. Predictive Maintenance

**With DANA:**
```python
if world.pump.vibration_level > 80:
    execution.alerts.append("Anomaly detected")
    use("kb.notify.maintenance_team")
    temp.severity = reason("Does this require immediate escalation?")
    if temp.severity == "yes":
        use("kb.escalate.critical_check")
```

### 3. Eligibility Evaluation

**With DANA:**
```python
if world.customer.credit_score < 600:
    temp.eligibility = reason("Does this score disqualify the applicant?", context=world.customer)
else:
    temp.eligibility = "likely"

if temp.eligibility == "yes":
    agent.decision = "deny"
else:
    agent.decision = "approve"
```

---

## 🤝 Relationship to OpenDXA

* DANA is embedded within OpenDXA as the **reasoning and execution layer**
* Agents emit or receive DANA programs to carry out goals
* Tool calls and reasoning steps all route through DANA
* The KB provides reusable domain logic to DXAs and GMAs

---

## 🛠 Status

DANA is under active development and currently embedded inside `OpenDXA` as a module. Refactoring and extraction to an independent package is supported by clean modular structure.

> Future direction includes formal spec, test suite, and runtime service for multi-agent environments.

---

## 📣 Contribute

Want to help shape how intelligent agents reason and act? Reach out or contribute to the `dana/` module inside the OpenDXA repository.

---
<p align="center">
Copyright © 2025 Aitomatic, Inc. Licensed under the <a href="../LICENSE.md">MIT License</a>.
<br/>
<a href="https://aitomatic.com">https://aitomatic.com</a>
</p>
