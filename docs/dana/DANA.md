<p align="center">
  <img src="https://cdn.prod.website-files.com/62a10970901ba826988ed5aa/62d942adcae82825089dabdb_aitomatic-logo-black.png" alt="Aitomatic Logo" width="400" style="border: 2px solid #666; border-radius: 10px; padding: 20px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);"/>
</p>

# DANA (Domain-Aware NeuroSymbolic Architecture)

## üß≠ Vision

DANA is a universal program format and execution runtime that enables intelligent agents ‚Äî human or machine ‚Äî to reason, act, and collaborate through structured, interpretable programs.

It serves as the missing link between natural language objectives and tool-assisted, stateful action. DANA programs are concise, auditable, explainable, and can be authored by LLMs, domain experts, or both.

---

## üí° Motivation & Problem

Modern AI systems struggle with:

* ‚úñÔ∏è **Prompt chains are fragile** ‚Äî hard to debug, hard to maintain
* ‚úñÔ∏è **Plans are opaque** ‚Äî impossible to inspect or explain mid-flight
* ‚úñÔ∏è **Tool use is scattered** ‚Äî logic is buried in code, not declarative programs
* ‚úñÔ∏è **State is implicit** ‚Äî no shared memory model or traceable updates

Symbolic systems offer structure but lack adaptability. LLMs offer creativity but lack transparency. DANA bridges the two.

---

## ‚úÖ Solution

DANA introduces a lightweight domain-aware program language and runtime. It allows:

* üß† **Programs as first-class reasoning artifacts**
* üì¶ **Shared state containers** (`agent`, `world`, `temp`, `execution`)
* üß© **Reusable logic units** via a structured Knowledge Base (KB)
* üßæ **Declarative goals**, **imperative execution**
* üìú **Bidirectional mapping to/from natural language**

DANA can:

* Be generated by a planning agent (like GMA)
* Be executed line-by-line by a runtime
* Interact with tools, LLMs, and memory
* Be stored, versioned, tested, and explained

---

## üîÑ Architecture Overview

### Emitters and Interpreters of DANA

| Actor             | Type               | Role(s) in DANA            | Description                                                        |
| ----------------- | ------------------ | -------------------------- | ------------------------------------------------------------------ |
| **User (Human)**  | Person             | üñã Emitter                 | Writes DANA directly to define goals, logic, or KB entries         |
| **GMA**           | Agent              | üñã Emitter                 | General planner that emits DANA plans from objectives              |
| **DXA**           | Domain Agent       | üñã Emitter                 | Emits specialized domain logic/workflows, often tied to KB content |
| **KB Maintainer** | Person or Agent    | üñã Emitter                 | Curates reusable DANA programs as structured knowledge             |
| **Tool Resource** | System Component   | ‚úÖ Interpreter              | Executes atomic tool-backed actions referenced in DANA             |
| **Local Runtime** | System Component   | ‚úÖ Interpreter              | Executes DANA deterministically except for `reason(...)`           |
| **DANA\_LLM**     | LLM Wrapper Module | üñã Emitter + ‚úÖ Interpreter | Emits code and executes reasoning operations                       |
| **AgentRuntime**  | System Component   | üîÅ Coordinator             | Orchestrates execution and manages delegation across all actors    |

### State Access

DANA programs operate over a shared `RuntimeContext`, which is composed of multiple memory scopes (state containers). These include:

| Scope        | Description                                |
| ------------ | ------------------------------------------ |
| `agent:`     | Long-term agent state (identity, traits)   |
| `world:`     | External observations and sensed data      |
| `temp:`      | Ephemeral memory ‚Äî scoped to a single step |
| `stmem:`     | Short-term memory ‚Äî scoped to a session    |
| `ltmem:`     | Long-term memory ‚Äî persisted over time     |
| `execution:` | Execution trace, status, and control flags |
| *custom:*    | User-defined namespaces for workflows      |

All components act on this shared context, with `AgentRuntime` controlling access and mutation privileges.

| Actor / Component | Access Type                       | Notes                                 |
| ----------------- | --------------------------------- | ------------------------------------- |
| **AgentRuntime**  | üîß Read/Write (Full)              | Owner and coordinator                 |
| **LocalRuntime**  | üß≠ Read/Write (Scoped)            | Executes DANA line-by-line safely     |
| **DANA\_LLM**     | üîç Read + Returns Deltas          | Receives snapshot, returns updates    |
| **Tools / DXAs**  | üîç Read + Write (Scoped)          | Modify state via specific APIs only   |
| **GMA / Planner** | üîç Read + Write (temp, execution) | Used for reasoning and planning       |
| **User (Human)**  | üßæ Read / Input                   | May initialize or query state         |
| **KB Entries**    | üì¶ Read/Write via Program         | Executed in context like a subroutine |

All components act on a shared mutable `RuntimeContext` that AgentRuntime owns and mediates.

### Security Design

**The `dana.runtime` module is the primary enforcer of security during the execution of a DANA program.** It manages the `RuntimeContext` for the duration of the execution and enforces access policies based on the defined scopes and program logic. While external components like `AgentRuntime` handle broader agent orchestration and security, the `dana.runtime` ensures safe state manipulation *within* a DANA execution context.

| Security Concern            | Enforced By              | Mechanism                                      |
| --------------------------- | ------------------------ | ---------------------------------------------- |
| Scope restrictions          | `dana.runtime`           | Limits visible/writable scopes during execution |
| State mutation permissions  | `dana.runtime`           | Controlled state updates via instructions      |
| Tool/API usage validation   | `dana.runtime`           | Ensures `use` targets are valid/allowed      |
| LLM output handling         | `dana.runtime`           | Manages `reason` call results and potential errors |
| Execution logging           | `dana.runtime`           | Tracks execution steps within the DANA context |
| Resource constraints        | `dana.runtime`           | (Optional) Limits execution steps, time, memory |

This ensures that DANA programs execute within defined boundaries, preventing unintended side effects and maintaining state integrity during their run.

---

## üí° Motivating Examples

### ‚úÖ Scenario: Multi-Step Risk Assessment via Prompt Chaining

**Today (Prompt-Chained Implementation):**

```python
# Step 1: Get supplier profile summary
step1 = llm(f"Summarize this supplier's profile:
{supplier_data}")

# Step 2: Check financial stability
step2 = llm(f"Based on this summary, assess financial risk:
{step1}")

# Step 3: Evaluate legal exposure
step3 = llm(f"Given this financial assessment, assess legal risk:
{step2}")

# Step 4: Final judgment
final_decision = llm(f"Considering all prior information, would you approve this supplier?")
```

* ‚úñÔ∏è Fragile logic and prompt phrasing
* ‚úñÔ∏è No explicit state or shared memory
* ‚úñÔ∏è Difficult to test, debug, or reuse

**With DANA:**

```python
temp.supplier = {}
temp.supplier.summary = reason("Summarize this supplier's profile", context=temp.supplier)
temp.supplier.financial_risk = reason("Assess financial risk", context=temp.supplier)
temp.supplier.legal_risk = reason("Assess legal risk", context=temp.supplier)

temp.final_decision = reason("Would you approve this supplier?", context=temp.supplier)
agent.supplier_approval = temp.final_decision
```

* ‚úÖ Structured, auditable state
* ‚úÖ Prompts tied to declarative reasoning steps
* ‚úÖ All context preserved and reusable

---

### ‚úÖ Example Workflow: Predictive Maintenance for Industrial Pump

**User Objective:** Detect anomalies and escalate for review if vibration levels exceed safe thresholds.

**Today (Typical Implementation):**

```python
if get_sensor("vibration") > 80:
    log("Anomaly detected")
    notify_team("Maintenance alert")
    if model.predict_failure():
        escalate("Pump requires urgent check")
```

* ‚úñÔ∏è Direct API calls are hardcoded
* ‚úñÔ∏è No structured state or reasoning log
* ‚úñÔ∏è Business logic is not reusable or inspectable

**With DANA:**

```python
if world.pump.vibration_level > 80:
    execution.alerts.append("Anomaly detected")
    use("kb.notify.maintenance_team")
    temp.severity = reason("Does this require immediate escalation?")
    if temp.severity == "yes":
        use("kb.escalate.critical_check")
```

* ‚úÖ Structured shared memory and alert tracking
* ‚úÖ Declarative use of reusable KB workflows
* ‚úÖ Domain-specific judgment via `reason(...)`

DANA simplifies common patterns found across industrial systems. Below, each example starts with how this is typically done today (often in a fragile or opaque way), followed by how the same scenario is clearer and safer using DANA.

---

### ‚úÖ Scenario 1: Eligibility Evaluation with LLM Reasoning

**Today (Typical Implementation):**

```python
prompt = f"User credit score is {score}. Should we deny?"
result = llm(prompt)
if 'yes' in result:
    decision = "deny"
else:
    decision = "approve"
```

* ‚úñÔ∏è Logic is entangled in prompt templates
* ‚úñÔ∏è No clear state tracking or modularity

**With DANA:**

```python
if world.customer.credit_score < 600:
    temp.eligibility = reason("Does this score disqualify the applicant?", context=world.customer)
else:
    temp.eligibility = "likely"

if temp.eligibility == "yes":
    agent.decision = "deny"
else:
    agent.decision = "approve"
```

* ‚úÖ Uses shared memory and LLM only where needed
* ‚úÖ Structured, inspectable, and reusable

---

### ‚úÖ Scenario 2: Tool Escalation from Failure Detection

**Today (Typical Implementation):**

```python
if detect_failure(sensor):
    log("dispatching alert")
    call_dispatch_service(machine_id)
```

* ‚úñÔ∏è Hardcoded logic and tool use
* ‚úñÔ∏è Not easily testable or explainable

**With DANA:**

```python
if "sensor_fail" in world.machine.flags:
    execution.alerts.append("Failure detected")
    use("kb.maintenance.workflow.dispatch")
```

* ‚úÖ Declarative condition + modular tool logic
* ‚úÖ All traceable in shared execution state

---

### ‚úÖ Scenario 3: Session-Based Memory for Behavioral Risk

**Today (Typical Implementation):**

```python
if redis.get("login_attempts") > 3:
    flag = llm("Is this suspicious?")
    if 'yes' in flag:
        db.set("fraud_flag", True)
```

* ‚úñÔ∏è Memory scattered across storage layers
* ‚úñÔ∏è LLM logic lacks context

**With DANA:**

```python
if stmem.login_attempts > 3:
    temp.review = reason("Is this suspicious behavior?", context=stmem)
    if temp.review == "yes":
        ltmem.flags.fraud_alert = true
```

* ‚úÖ Reasoning is scoped and contextual
* ‚úÖ Long/short-term memory is structured and unified

---

## ü§ù Relationship to OpenDXA

* DANA is embedded within OpenDXA as the **reasoning and execution layer**
* Agents emit or receive DANA programs to carry out goals
* Tool calls and reasoning steps all route through DANA
* The KB provides reusable domain logic to DXAs and GMAs

---

## üì£ Contribute

Want to help shape how intelligent agents reason and act? Reach out or contribute to the `dana/` module inside the OpenDXA repository.

<p align="center">
Copyright ¬© 2025 Aitomatic, Inc. Licensed under the <a href="../LICENSE.md">MIT License</a>.
<br/>
<a href="https://aitomatic.com">https://aitomatic.com</a>
</p>
