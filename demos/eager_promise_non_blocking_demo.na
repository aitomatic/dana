# Demo: EagerPromise Transparent Concurrency
# 
# This demo shows the blocking-on-access design where:
# 1. EagerPromise creation never blocks (returns immediately)
# 2. EagerPromise auto-resolves in background thread
# 3. Accessing an unresolved promise blocks until ready
# 4. return statements create EagerPromise
# 5. deliver statements execute inline

import time

# Track execution to show timing
execution_tracker = [0]

def expensive_operation():
    execution_tracker[0] = execution_tracker[0] + 1
    print(f"üîÑ Executing expensive operation #{execution_tracker[0]}...")
    # Simulate expensive computation
    time.sleep(0.1)  # 100ms delay
    result = f"result_{execution_tracker[0]}"
    print(f"‚úÖ Expensive operation #{execution_tracker[0]} completed!")
    return result

# Function using return (creates EagerPromise)
def return_function():
    print("üìù Creating return function...")
    return expensive_operation()

# Function using deliver (executes inline)
def deliver_function():
    print("‚ö° Creating deliver function...")
    deliver expensive_operation()

print("=== NON-BLOCKING EAGERPROMISE DEMO ===")

print("\n1. RETURN FUNCTION (creates EagerPromise)")
print("Creating return function...")
execution_tracker[0] = 0
start_time = time.time()

# This should return immediately with EagerPromise
result = return_function()
creation_time = time.time() - start_time

print(f"Function returned in {creation_time:.3f}s! Execution count: {execution_tracker[0]}")
print(f"Result type: {type(result)}")
print(f"Result string: {str(result)}")

# Try to access the result (will block until ready)
print("\nAccessing the result (this will block until ready)...")
access_start = time.time()
value = result
access_time = time.time() - start_time
block_duration = time.time() - access_start
print(f"Successfully accessed in {access_time:.3f}s! Value: {value}")
print(f"Blocked for {block_duration:.3f}s waiting for result")

# Access again (should be immediate now)
print("\nAccessing again (should be immediate now)...")
access_start = time.time()
value2 = result
final_time = time.time() - start_time
instant_duration = time.time() - access_start
print(f"Accessed again in {final_time:.3f}s! Value: {value2}")
print(f"Second access took {instant_duration:.3f}s (should be ~0)")

print("\n2. DELIVER FUNCTION (executes inline)")
print("Creating deliver function...")
execution_tracker[0] = 0
start_time = time.time()

# This should execute immediately and block until complete
result = deliver_function()
execution_time = time.time() - start_time

print(f"Function executed in {execution_time:.3f}s! Execution count: {execution_tracker[0]}")
print(f"Result type: {type(result)}")
print(f"Result value: {result}")

print("\n3. MULTIPLE RETURN FUNCTIONS (parallel execution)")
print("Creating multiple return functions...")
execution_tracker[0] = 0
start_time = time.time()

# Create multiple EagerPromises
a = return_function()
b = return_function()
c = return_function()

creation_time = time.time() - start_time
print(f"Created 3 EagerPromises in {creation_time:.3f}s! Execution count: {execution_tracker[0]}")

# Access all promises (will block until each is ready)
print("\nAccessing all promises (will block for each if needed)...")
access_start = time.time()
combined = f"{a} | {b} | {c}"
final_time = time.time() - start_time
total_block = time.time() - access_start
print(f"All accessed in {final_time:.3f}s! Combined: {combined}")
print(f"Total blocking time: {total_block:.3f}s")

print("\n=== KEY INSIGHTS ===")
print("‚úÖ EagerPromise creation never blocks (returns immediately)")
print("‚úÖ Background execution starts immediately in thread pool")
print("‚úÖ Accessing an unresolved promise blocks until ready (transparent concurrency)")
print("‚úÖ Subsequent accesses return immediately (cached result)")
print("‚úÖ deliver executes inline and blocks until complete")
print("‚úÖ Multiple EagerPromises can resolve in parallel")
print("‚úÖ Use await_result() for async-safe access in async contexts") 