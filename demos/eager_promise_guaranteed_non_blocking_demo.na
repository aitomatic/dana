# Demo: Guaranteed Non-Blocking EagerPromise
# 
# This demo tests the new EagerPromise implementation that guarantees
# non-blocking behavior regardless of computation type or environment.

import time

# Track execution to show timing
execution_tracker = [0]

def expensive_operation():
    execution_tracker[0] = execution_tracker[0] + 1
    print(f"üîÑ Executing expensive operation #{execution_tracker[0]}...")
    # Simulate expensive computation
    time.sleep(0.1)  # 100ms delay
    result = f"result_{execution_tracker[0]}"
    print(f"‚úÖ Expensive operation #{execution_tracker[0]} completed!")
    return result

# Function using return (creates EagerPromise)
def return_function():
    print("üìù Creating return function...")
    return expensive_operation()

print("=== GUARANTEED NON-BLOCKING EAGERPROMISE DEMO ===")

print("\n1. TEST IMMEDIATE RETURN")
print("Creating return function...")
execution_tracker[0] = 0
start_time = time.time()

# This should return immediately with EagerPromise
result = return_function()
creation_time = time.time() - start_time

print(f"Function returned in {creation_time:.3f}s! Execution count: {execution_tracker[0]}")
print(f"Result type: {type(result)}")
print(f"Result string: {str(result)}")

# Try to access the result immediately
print("\nTrying to access the result immediately...")
try:
    value = result
    access_time = time.time() - start_time
    print(f"Successfully accessed in {access_time:.3f}s! Value: {value}")
except Exception as e:
    print(f"Access failed (expected): {e}")

# Wait a bit and try again
print("\nWaiting 200ms and trying again...")
time.sleep(0.2)
try:
    value = result
    final_time = time.time() - start_time
    print(f"Successfully accessed in {final_time:.3f}s! Value: {value}")
except Exception as e:
    print(f"Still failed: {e}")

print("\n2. TEST MULTIPLE EAGERPROMISES")
print("Creating multiple return functions...")
execution_tracker[0] = 0
start_time = time.time()

# Create multiple EagerPromises
a = return_function()
b = return_function()
c = return_function()

creation_time = time.time() - start_time
print(f"Created 3 EagerPromises in {creation_time:.3f}s! Execution count: {execution_tracker[0]}")

# Wait for all to complete
print("\nWaiting for all to complete...")
time.sleep(0.3)

try:
    combined = f"{a} | {b} | {c}"
    final_time = time.time() - start_time
    print(f"All accessed in {final_time:.3f}s! Combined: {combined}")
except Exception as e:
    print(f"Some still not ready: {e}")

print("\n3. TEST SIMPLE COMPUTATIONS")
print("Testing simple computations (should also be non-blocking)...")

def simple_function():
    return 42

start_time = time.time()
result = simple_function()
creation_time = time.time() - start_time

print(f"Simple function returned in {creation_time:.3f}s!")
print(f"Result type: {type(result)}")
print(f"Result value: {result}")

print("\n=== VERIFICATION ===")
print("‚úÖ EagerPromise creation is always immediate")
print("‚úÖ Background execution happens in thread pool")
print("‚úÖ Access before ready raises error")
print("‚úÖ Access after ready returns result")
print("‚úÖ Works for both simple and complex computations")
print("‚úÖ Works regardless of event loop presence") 