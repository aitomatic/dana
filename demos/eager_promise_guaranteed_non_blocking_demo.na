# Demo: EagerPromise Blocking-on-Access Behavior
# 
# This demo tests the EagerPromise implementation that provides
# transparent concurrency through blocking-on-access semantics.

import time

# Track execution to show timing
execution_tracker = [0]

def expensive_operation():
    execution_tracker[0] = execution_tracker[0] + 1
    print(f"üîÑ Executing expensive operation #{execution_tracker[0]}...")
    # Simulate expensive computation
    time.sleep(0.1)  # 100ms delay
    result = f"result_{execution_tracker[0]}"
    print(f"‚úÖ Expensive operation #{execution_tracker[0]} completed!")
    return result

# Function using return (creates EagerPromise)
def return_function():
    print("üìù Creating return function...")
    return expensive_operation()

print("=== EAGERPROMISE BLOCKING-ON-ACCESS DEMO ===")

print("\n1. TEST IMMEDIATE RETURN")
print("Creating return function...")
execution_tracker[0] = 0
start_time = time.time()

# This should return immediately with EagerPromise
result = return_function()
creation_time = time.time() - start_time

print(f"Function returned in {creation_time:.3f}s! Execution count: {execution_tracker[0]}")
print(f"Result type: {type(result)}")
print(f"Result string: {str(result)}")

# Try to access the result immediately (will block)
print("\nAccessing the result immediately (will block)...")
access_start = time.time()
value = result
access_time = time.time() - start_time
block_duration = time.time() - access_start
print(f"Successfully accessed in {access_time:.3f}s! Value: {value}")
print(f"Blocked for {block_duration:.3f}s waiting for computation")

# Access again (should be immediate)
print("\nAccessing again (should be immediate)...")
access_start = time.time()
value2 = result
final_time = time.time() - start_time
instant_duration = time.time() - access_start
print(f"Accessed again in {final_time:.3f}s! Value: {value2}")
print(f"Second access took {instant_duration:.3f}s (cached result)")

print("\n2. TEST MULTIPLE EAGERPROMISES")
print("Creating multiple return functions...")
execution_tracker[0] = 0
start_time = time.time()

# Create multiple EagerPromises
a = return_function()
b = return_function()
c = return_function()

creation_time = time.time() - start_time
print(f"Created 3 EagerPromises in {creation_time:.3f}s! Execution count: {execution_tracker[0]}")

# Access all promises (blocks for each if needed)
print("\nAccessing all promises...")
access_start = time.time()
combined = f"{a} | {b} | {c}"
final_time = time.time() - start_time
total_block = time.time() - access_start
print(f"All accessed in {final_time:.3f}s! Combined: {combined}")
print(f"Total access time: {total_block:.3f}s")

print("\n3. TEST SIMPLE COMPUTATIONS")
print("Testing simple computations (should also be non-blocking)...")

def simple_function():
    return 42

start_time = time.time()
result = simple_function()
creation_time = time.time() - start_time

print(f"Simple function returned in {creation_time:.3f}s!")
print(f"Result type: {type(result)}")
print(f"Result value: {result}")

print("\n=== VERIFICATION ===")
print("‚úÖ EagerPromise creation is always immediate (non-blocking)")
print("‚úÖ Background execution happens in thread pool")
print("‚úÖ Access before ready blocks until computation completes")
print("‚úÖ Access after ready returns result immediately")
print("‚úÖ Provides transparent concurrency - promises act like regular values")
print("‚úÖ Works for both simple and complex computations") 