# Corrected Return vs Deliver Demo - Shows Actual Promise[T] Behavior

# Track execution timing to demonstrate when operations actually run
execution_tracker = [0]

def expensive_operation():
    execution_tracker[0] = execution_tracker[0] + 1
    print(f"üîÑ Executing expensive operation #{execution_tracker[0]}...")
    # Simulate expensive computation
    result = 0
    for i in range(100000):
        result = result + i
    print(f"‚úÖ Expensive operation #{execution_tracker[0]} completed!")
    return f"result_{execution_tracker[0]}_{result}"

# Lazy function - returns Promise[T] immediately
def lazy_function():
    print("üìù Creating lazy function reference...")
    return expensive_operation()

# Eager function - executes immediately
def eager_function():
    print("‚ö° Creating eager function reference...")
    deliver expensive_operation()

print("=== CORRECTED RETURN vs DELIVER DEMO ===")

print("\n1. LAZY EXECUTION (return)")
print("Creating lazy function...")
execution_tracker[0] = 0
lazy_result = lazy_function()
print(f"Function returned immediately! Execution count: {execution_tracker[0]}")
print(f"Result type: {type(lazy_result)}")
print("Lazy result created, but expensive operation NOT executed yet!")

print("\nNow accessing the lazy result...")
actual_result = lazy_result
print(f"After accessing, execution count: {execution_tracker[0]}")
print(f"Final result: {actual_result}")

print("\n2. EAGER EXECUTION (deliver)")
print("Creating eager function...")
execution_tracker[0] = 0
eager_result = eager_function()
print(f"Function executed immediately! Execution count: {execution_tracker[0]}")
print(f"Result type: {type(eager_result)}")
print("Eager result created AND expensive operation already executed!")

print("\nAccessing the eager result...")
actual_result = eager_result
print(f"After accessing, execution count: {execution_tracker[0]} (no change)")
print(f"Final result: {actual_result}")

print("\n3. MULTIPLE LAZY OPERATIONS (Parallel Potential)")
print("Creating multiple lazy operations...")
execution_tracker[0] = 0

def lazy_a():
    return expensive_operation()

def lazy_b():
    return expensive_operation()

def lazy_c():
    return expensive_operation()

# Create three lazy promises
a = lazy_a()
b = lazy_b()
c = lazy_c()

print(f"Created 3 lazy promises! Execution count: {execution_tracker[0]} (no executions yet)")

print("\nNow accessing all three promises together...")
combined_result = a + " | " + b + " | " + c
print(f"After accessing all, execution count: {execution_tracker[0]} (all executed)")
print(f"Combined result: {combined_result}")

print("\n4. CONDITIONAL EXECUTION")
print("Creating conditional lazy operations...")
execution_tracker[0] = 0

def conditional_lazy(should_execute):
    if should_execute:
        return expensive_operation()
    else:
        return "skipped"

# Create conditional promises
needed_result = conditional_lazy(true)
unneeded_result = conditional_lazy(false)

print(f"Created conditional promises! Execution count: {execution_tracker[0]} (no executions yet)")

print("\nAccessing only the needed result...")
result = needed_result
print(f"After accessing needed result, execution count: {execution_tracker[0]} (only needed executed)")

print("\nNot accessing the unneeded result...")
print(f"Final execution count: {execution_tracker[0]} (unneeded never executed)")

print("\n=== KEY INSIGHTS ===")
print("‚úÖ Lazy (return): Fast creation, deferred execution")
print("‚úÖ Eager (deliver): Immediate execution, instant access")
print("‚úÖ Multiple lazy operations can be parallelized")
print("‚úÖ Conditional lazy operations only execute if accessed")
print("‚úÖ Promise[T] appears as T in all operations (transparent typing)")
print("‚úÖ No explicit async/await needed - automatic concurrency!") 