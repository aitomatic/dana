"""
Comprehension Expression Handler

Handles list, set, and dict comprehensions with shared logic.
This reduces code duplication from the main expression executor.
"""

from typing import Any

from dana.common.exceptions import SandboxError
from dana.core.lang.ast import DictComprehension, ListComprehension, SetComprehension
from dana.core.lang.sandbox_context import SandboxContext


class ComprehensionHandler:
    """Specialized handler for comprehension expressions."""

    def __init__(self, parent_executor):
        """Initialize the comprehension handler.

        Args:
            parent_executor: The parent expression executor
        """
        self.parent_executor = parent_executor

    def execute_list_comprehension(self, node: ListComprehension, context: SandboxContext) -> list:
        """Execute a list comprehension expression.

        Args:
            node: The list comprehension to execute
            context: The execution context

        Returns:
            A list containing the results of the comprehension
        """
        items = self._execute_comprehension_items(node, context)
        return list(items)

    def execute_set_comprehension(self, node: SetComprehension, context: SandboxContext) -> set:
        """Execute a set comprehension expression.

        Args:
            node: The set comprehension to execute
            context: The execution context

        Returns:
            A set containing the results of the comprehension
        """
        items = self._execute_comprehension_items(node, context)
        return set(items)

    def execute_dict_comprehension(self, node: DictComprehension, context: SandboxContext) -> dict:
        """Execute a dictionary comprehension expression.

        Args:
            node: The dict comprehension to execute
            context: The execution context

        Returns:
            A dict containing the results of the comprehension
        """
        # Execute the iterable to get the sequence to iterate over
        iterable = self.parent_executor.parent.execute(node.iterable, context)

        if not hasattr(iterable, "__iter__"):
            raise SandboxError(f"Cannot iterate over non-iterable object: {type(iterable).__name__}")

        result = {}

        # Iterate over each item in the iterable
        for item in iterable:
            # Create a new scope for this iteration
            iteration_context = context.copy()

            # Bind the target variable(s) to the current item
            self._bind_iteration_variable(node.target, item, iteration_context)

            # Check condition if present
            if node.condition is not None:
                condition_result = self.parent_executor.parent.execute(node.condition, iteration_context)
                if not condition_result:
                    continue  # Skip this item if condition is False

            # Execute the key and value expressions for this item
            key_result = self.parent_executor.parent.execute(node.key_expr, iteration_context)
            value_result = self.parent_executor.parent.execute(node.value_expr, iteration_context)
            result[key_result] = value_result

        return result

    def _execute_comprehension_items(self, node: ListComprehension | SetComprehension, context: SandboxContext) -> list:
        """Execute comprehension logic common to both list and set comprehensions.

        Args:
            node: The comprehension node (list or set)
            context: The execution context

        Returns:
            List of items generated by the comprehension
        """
        # Execute the iterable to get the sequence to iterate over
        iterable = self.parent_executor.parent.execute(node.iterable, context)

        if not hasattr(iterable, "__iter__"):
            raise SandboxError(f"Cannot iterate over non-iterable object: {type(iterable).__name__}")

        result = []

        # Iterate over each item in the iterable
        for item in iterable:
            # Create a new scope for this iteration
            iteration_context = context.copy()

            # Bind the target variable(s) to the current item
            self._bind_iteration_variable(node.target, item, iteration_context)

            # Check condition if present
            if node.condition is not None:
                condition_result = self.parent_executor.parent.execute(node.condition, iteration_context)
                if not condition_result:
                    continue  # Skip this item if condition is False

            # Execute the expression for this item
            expression_result = self.parent_executor.parent.execute(node.expression, iteration_context)
            result.append(expression_result)

        return result

    def _bind_iteration_variable(self, target: str, item: Any, context: SandboxContext) -> None:
        """Bind iteration variable(s) to the current item.

        Args:
            target: The target variable name(s) (may include tuple unpacking)
            item: The current iteration item
            context: The iteration context to bind variables in
        """
        # Bind the target variable(s) to the current item
        if "," in target:
            # Tuple unpacking: split target names and assign corresponding values
            target_names = [name.strip() for name in target.split(",")]
            if isinstance(item, list | tuple) and len(item) == len(target_names):
                for name, value in zip(target_names, item, strict=False):
                    context.set(name, value)
            else:
                # If item is not a tuple/list or doesn't match, assign the whole item to first target
                context.set(target_names[0], item)
        else:
            # Single variable assignment
            context.set(target, item)
