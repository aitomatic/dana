"""
Eager Promise[T] wrapper system for Dana.

This module implements eager evaluation where Promise[T] starts executing
immediately upon creation, rather than waiting for first access.

Copyright Â© 2025 Aitomatic, Inc.
"""

import asyncio
import inspect
import threading
from collections.abc import Callable, Coroutine
from concurrent.futures import ThreadPoolExecutor
from typing import Any, Union

from dana.core.concurrency.base_promise import BasePromise, PromiseError
from dana.core.lang.sandbox_context import SandboxContext

# Shared thread pool for all EagerPromise instances to prevent deadlocks
_shared_executor = None
_executor_lock = threading.Lock()


def _get_shared_executor() -> ThreadPoolExecutor:
    """Get the shared thread pool executor for EagerPromise instances."""
    global _shared_executor
    if _shared_executor is None:
        with _executor_lock:
            if _shared_executor is None:
                _shared_executor = ThreadPoolExecutor(max_workers=4, thread_name_prefix="EagerPromise")
    return _shared_executor


class EagerPromise(BasePromise):
    """
    Eager evaluation promise that starts execution immediately upon creation.

    Unlike the lazy Promise, EagerPromise begins executing its computation
    as soon as it's created, making it suitable for scenarios where you want
    to start async operations immediately.
    """

    def __init__(self, computation: Union[Callable[[], Any], Coroutine], context: SandboxContext, timeout_seconds: float = 10.0):
        """
        Initialize an eager promise that starts execution immediately.

        Args:
            computation: Callable that returns the actual value, or coroutine
            context: Execution context for the computation
            timeout_seconds: Timeout in seconds for async operations (default: 10.0)
        """
        super().__init__(computation, context)
        self._task = None  # Store the asyncio task
        self._future = None  # Store the concurrent.futures.Future for sync execution (legacy)
        self._lock = threading.Lock()
        self._timeout_seconds = timeout_seconds

        self.info(f"ðŸ”µ EagerPromise CREATED at {self._creation_location}")

        # Start execution immediately
        self._start_execution()

    def _start_execution(self):
        """Start executing the computation immediately in background.

        DESIGN OBLIGATION: EagerPromise should NEVER block the caller.
        This method guarantees non-blocking behavior by always using background execution.
        """
        self.info(f"ðŸ”µ EagerPromise STARTING EXECUTION at {self._creation_location}")

        # ALWAYS use background execution to fulfill non-blocking obligation
        self._start_background_execution()

    def _start_background_execution(self):
        """Start execution in background thread to guarantee non-blocking behavior."""
        import concurrent.futures

        def background_runner():
            """Run the computation in background thread."""
            self.info("ðŸ”µ EagerPromise: Background execution started")
            try:
                if inspect.iscoroutine(self._computation):
                    # Async computation - create new event loop in thread
                    self.info("ðŸ”µ EagerPromise: Background async execution")
                    result = asyncio.run(self._computation)
                else:
                    # Sync computation - run directly in thread
                    self.info("ðŸ”µ EagerPromise: Background sync execution")
                    result = self._computation()

                with self._lock:
                    self._result = result
                    self._resolved = True
                    self.info(f"ðŸ”µ EagerPromise: Background execution COMPLETED, result: {type(result)}")

            except Exception as e:
                with self._lock:
                    self._error = PromiseError(e, self._creation_location, self._get_resolution_location())
                    self._resolved = True
                    self.info(f"ðŸ”µ EagerPromise: Background execution FAILED: {e}")

        # Start background execution immediately
        with concurrent.futures.ThreadPoolExecutor() as executor:
            self._future = executor.submit(background_runner)
            self.info("ðŸ”µ EagerPromise: Background task submitted to thread pool")

    def _is_potential_async_deadlock(self, loop) -> bool:
        """Check if creating an async task might cause a deadlock."""
        # This method is no longer needed with background execution
        return False

    def _execute_async_immediately(self):
        """Execute async computation immediately to avoid deadlocks."""
        # This method is no longer needed - all execution is background
        raise RuntimeError("_execute_async_immediately() is deprecated - use background execution")

    async def _execute_async(self):
        """Execute the async computation."""
        # This method is no longer needed - all execution is background
        raise RuntimeError("_execute_async() is deprecated - use background execution")

    def _execute_sync(self):
        """Execute the sync computation."""
        # This method is no longer needed - all execution is background
        raise RuntimeError("_execute_sync() is deprecated - use background execution")

    def _ensure_resolved(self):
        """
        Ensure the promise is resolved before accessing the result.

        DESIGN GOAL: EagerPromise should NEVER block the caller.
        - If already resolved: return result immediately
        - If not resolved: raise error indicating not ready
        - Background thread handles resolution automatically
        """
        self.info(f"ðŸ”µ EagerPromise _ensure_resolved() called at {self._get_resolution_location()}")

        with self._lock:
            if self._resolved:
                if self._error:
                    self.info(f"ðŸ”µ EagerPromise: Already resolved with ERROR: {self._error.original_error}")
                    raise self._error.original_error
                self.info(f"ðŸ”µ EagerPromise: Already resolved with SUCCESS: {type(self._result)}")
                return self._result

        # Not resolved yet - don't block, just indicate not ready
        self.info("ðŸ”µ EagerPromise: NOT READY - raising error")
        error_msg = (
            f"EagerPromise not ready yet. Background resolution in progress.\n"
            f"Creation location: {self._creation_location}\n"
            f"SOLUTION: Wait a moment and try again, or use async await_result() if in async context."
        )
        self.debug(f"EagerPromise not ready: {error_msg}")
        raise RuntimeError(error_msg)

    def is_ready(self) -> bool:
        """
        Check if the EagerPromise is ready without blocking.

        Returns:
            True if the promise is resolved (success or error), False otherwise
        """
        with self._lock:
            ready = self._resolved
            self.info(f"ðŸ”µ EagerPromise is_ready() called: {ready}")
            return ready

    def get_result_if_ready(self):
        """
        Get the result if the promise is ready, otherwise raise error.

        This is equivalent to _ensure_resolved() but with a clearer name.

        Returns:
            The resolved value if ready

        Raises:
            RuntimeError: If promise is not ready yet
            Original error: If promise failed
        """
        self.info("ðŸ”µ EagerPromise get_result_if_ready() called")
        return self._ensure_resolved()

    async def await_result(self):
        """
        Safely await the EagerPromise result in async contexts.

        This is the PRIMARY method for accessing EagerPromise results.
        It waits for the background resolution to complete.

        Returns:
            The resolved value of the promise

        Raises:
            The original error if the promise failed
        """
        self.info("ðŸ”µ EagerPromise await_result() called")

        # If already resolved, return immediately
        with self._lock:
            if self._resolved:
                if self._error:
                    self.info("ðŸ”µ EagerPromise await_result: Already resolved with ERROR")
                    raise self._error.original_error
                self.info("ðŸ”µ EagerPromise await_result: Already resolved with SUCCESS")
                return self._result

        # Wait for the background task to complete
        if self._future:
            self.info("ðŸ”µ EagerPromise await_result: Waiting for background task")
            try:
                # Use run_in_executor to wait for future without blocking event loop
                loop = asyncio.get_running_loop()
                result = await loop.run_in_executor(None, self._future.result)
                self.info("ðŸ”µ EagerPromise await_result: Background task completed")
                return result
            except Exception as e:
                # Task failed - check if error was recorded
                self.info(f"ðŸ”µ EagerPromise await_result: Background task FAILED: {e}")
                with self._lock:
                    if self._error:
                        raise self._error.original_error
                    else:
                        # Task failed but no error recorded - this shouldn't happen
                        raise RuntimeError(f"EagerPromise task failed: {e}")

        # Check again after waiting
        with self._lock:
            if self._resolved:
                if self._error:
                    self.info("ðŸ”µ EagerPromise await_result: Resolved with ERROR after waiting")
                    raise self._error.original_error
                self.info("ðŸ”µ EagerPromise await_result: Resolved with SUCCESS after waiting")
                return self._result
            else:
                # This shouldn't happen if task completed successfully
                self.info("ðŸ”µ EagerPromise await_result: Task completed but not resolved - ERROR")
                raise RuntimeError("EagerPromise task completed but promise not resolved")

    # Override __str__ to show execution status for eager promises
    def __str__(self):
        """String representation showing EagerPromise status."""
        # Don't call _ensure_resolved() to avoid blocking
        with self._lock:
            if self._resolved:
                if self._error:
                    return f"EagerPromise[Error: {self._error.original_error}]"
                else:
                    return f"EagerPromise[{repr(self._result)}]"
            elif self._future:
                return "EagerPromise[<resolving>]"
            else:
                return "EagerPromise[<pending>]"

    def __repr__(self):
        """Transparent representation."""
        if self._resolved:
            if self._error:
                return f"EagerPromise[Error: {self._error.original_error}]"
            return f"EagerPromise[{repr(self._result)}]"
        return "EagerPromise[<executing>]"

    @classmethod
    def create(
        cls, computation: Union[Callable[[], Any], Coroutine], context: SandboxContext, timeout_seconds: float = 10.0
    ) -> "EagerPromise":
        """
        Factory method to create a new EagerPromise[T].

        Args:
            computation: Callable that returns the actual value or coroutine
            context: Execution context
            timeout_seconds: Timeout in seconds for async operations (default: 10.0)

        Returns:
            EagerPromise[T] that executes immediately and blocks on access
        """
        return cls(computation, context, timeout_seconds)


def is_eager_promise(obj: Any) -> bool:
    """Check if an object is an EagerPromise."""
    return isinstance(obj, EagerPromise)
