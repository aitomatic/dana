# Data structures for objective-driven agent state machine

# Core data types for semiconductor manufacturing
struct ProcessData:
    """Raw process data from manufacturing equipment"""
    timestamp: str
    equipment_id: str
    parameters: dict[str, float]
    measurements: dict[str, float]
    quality_metrics: dict[str, float]

struct AnalysisResult:
    """Results from process data analysis"""
    patterns: list[Pattern]
    anomalies: list[Anomaly]
    trends: list[Trend]
    confidence: float

struct Pattern:
    """Identified pattern in process data"""
    pattern_type: str  # "cyclic", "trending", "seasonal", "random"
    parameters: dict[str, float]
    confidence: float
    description: str

struct Anomaly:
    """Detected anomaly in process data"""
    anomaly_type: str  # "spike", "drift", "outlier", "shift"
    severity: str  # "low", "medium", "high", "critical"
    affected_parameters: list[str]
    timestamp: str
    description: str

struct Trend:
    """Trend analysis result"""
    trend_direction: str  # "increasing", "decreasing", "stable"
    slope: float
    confidence: float
    affected_metrics: list[str]

struct DiagnosisResult:
    """Root cause diagnosis results"""
    root_causes: list[RootCause]
    severity: str  # "low", "medium", "high", "critical"
    recommendations: list[str]

struct RootCause:
    """Identified root cause"""
    cause_type: str  # "equipment", "process", "material", "environmental"
    description: str
    confidence: float
    affected_components: list[str]
    suggested_actions: list[str]

struct OptimizationResult:
    """Process optimization results"""
    current_parameters: dict[str, float]
    optimized_parameters: dict[str, float]
    expected_improvement: dict[str, float]

struct ValidationResult:
    """Validation results for optimization"""
    is_safe: bool
    is_effective: bool
    risks: list[str]
    benefits: list[str]

struct Report:
    """Comprehensive execution report"""
    summary: str
    details: dict[str, any]
    recommendations: list[str]
    next_steps: list[str]

struct ExecutionResult:
    """Complete state machine execution result"""
    success: bool
    results: dict[str, any]
    final_state: str
    execution_time: float

struct ManufacturingProblem:
    """Input problem description"""
    problem_type: str
    description: str
    affected_equipment: list[str]
    urgency: str  # "low", "medium", "high", "critical"
    constraints: dict[str, any]

struct Solution:
    """Final solution output"""
    status: str  # "resolved", "requires_manual_intervention", "failed"
    recommendations: list[str]
    expected_improvements: dict[str, float]
    risks: list[str] = []

# Helper functions for the state machine

@poet(domain="semiconductor", objective="detect_patterns", optimize_for="pattern_accuracy")
def detect_patterns(data: ProcessData) -> list[Pattern]:
    """Detect patterns in process data using statistical analysis"""
    patterns = []
    
    # Analyze each parameter for patterns
    for param_name, values in data.parameters.items():
        # Statistical pattern detection
        if is_cyclic(values):
            patterns.append(Pattern(
                pattern_type="cyclic",
                parameters={"frequency": calculate_frequency(values)},
                confidence=calculate_confidence(values),
                description=f"Cyclic pattern detected in {param_name}"
            ))
        elif is_trending(values):
            patterns.append(Pattern(
                pattern_type="trending", 
                parameters={"slope": calculate_slope(values)},
                confidence=calculate_confidence(values),
                description=f"Trending pattern detected in {param_name}"
            ))
    
    return patterns

@poet(domain="semiconductor", objective="identify_anomalies", optimize_for="anomaly_detection")
def identify_anomalies(data: ProcessData) -> list[Anomaly]:
    """Identify anomalies in process data"""
    anomalies = []
    
    # Statistical anomaly detection
    for metric_name, values in data.quality_metrics.items():
        mean_val = calculate_mean(values)
        std_val = calculate_std(values)
        
        # Detect outliers
        for i, value in enumerate(values):
            if abs(value - mean_val) > 3 * std_val:  # 3-sigma rule
                anomalies.append(Anomaly(
                    anomaly_type="outlier",
                    severity="high",
                    affected_parameters=[metric_name],
                    timestamp=data.timestamp,
                    description=f"Outlier detected in {metric_name}: {value}"
                ))
    
    return anomalies

@poet(domain="semiconductor", objective="calculate_trends", optimize_for="trend_accuracy")
def calculate_trends(data: ProcessData) -> list[Trend]:
    """Calculate trends in process data"""
    trends = []
    
    for metric_name, values in data.quality_metrics.items():
        slope = calculate_slope(values)
        direction = "increasing" if slope > 0 else "decreasing" if slope < 0 else "stable"
        
        trends.append(Trend(
            trend_direction=direction,
            slope=slope,
            confidence=calculate_trend_confidence(values),
            affected_metrics=[metric_name]
        ))
    
    return trends

@poet(domain="semiconductor", objective="trace_cause", optimize_for="cause_accuracy")
def trace_cause(anomaly: Anomaly, patterns: list[Pattern]) -> RootCause:
    """Trace the root cause of an anomaly"""
    
    # Analyze patterns to identify potential causes
    if anomaly.anomaly_type == "outlier":
        # Check for equipment-related causes
        if has_equipment_pattern(patterns, anomaly.affected_parameters):
            return RootCause(
                cause_type="equipment",
                description=f"Equipment malfunction causing {anomaly.anomaly_type}",
                confidence=0.8,
                affected_components=anomaly.affected_parameters,
                suggested_actions=["Check equipment calibration", "Inspect for wear"]
            )
        elif has_process_pattern(patterns, anomaly.affected_parameters):
            return RootCause(
                cause_type="process",
                description=f"Process parameter drift causing {anomaly.anomaly_type}",
                confidence=0.7,
                affected_components=anomaly.affected_parameters,
                suggested_actions=["Adjust process parameters", "Review SOP"]
            )
    
    # Default cause
    return RootCause(
        cause_type="unknown",
        description=f"Unknown cause for {anomaly.anomaly_type}",
        confidence=0.3,
        affected_components=anomaly.affected_parameters,
        suggested_actions=["Investigate further", "Monitor closely"]
    )

@poet(domain="semiconductor", objective="optimize_parameters", optimize_for="optimization_effectiveness")
def optimize_parameters(current_params: dict[str, float], diagnosis: DiagnosisResult) -> dict[str, float]:
    """Optimize process parameters based on diagnosis"""
    optimized_params = current_params.copy()
    
    # Apply optimization based on root causes
    for cause in diagnosis.root_causes:
        if cause.cause_type == "process":
            # Adjust process parameters
            for param in cause.affected_components:
                if param in optimized_params:
                    # Apply domain-specific optimization
                    optimized_params[param] = apply_process_optimization(
                        optimized_params[param], 
                        cause.description
                    )
    
    return optimized_params

@poet(domain="semiconductor", objective="validate_safety", optimize_for="safety_assurance")
def validate_safety(parameters: dict[str, float]) -> dict[str, any]:
    """Validate that parameters are within safe operating ranges"""
    
    safety_checks = {
        "temperature": lambda x: 0 <= x <= 1000,  # Celsius
        "pressure": lambda x: 0 <= x <= 100,      # Bar
        "flow_rate": lambda x: 0 <= x <= 1000,    # L/min
        "power": lambda x: 0 <= x <= 10000        # Watts
    }
    
    passed = true
    risks = []
    
    for param, value in parameters.items():
        if param in safety_checks:
            if not safety_checks[param](value):
                passed = false
                risks.append(f"{param} value {value} outside safe range")
    
    return {"passed": passed, "risks": risks}

@poet(domain="semiconductor", objective="validate_performance", optimize_for="performance_assurance")
def validate_performance(parameters: dict[str, float]) -> dict[str, any]:
    """Validate that parameters will improve performance"""
    
    # Simulate expected performance with new parameters
    expected_quality = simulate_quality(parameters)
    expected_yield = simulate_yield(parameters)
    expected_cost = simulate_cost(parameters)
    
    passed = expected_quality >= 0.95 and expected_yield >= 0.90
    benefits = [
        f"Expected quality improvement: {expected_quality:.2%}",
        f"Expected yield improvement: {expected_yield:.2%}",
        f"Expected cost reduction: {expected_cost:.2%}"
    ]
    
    return {"passed": passed, "benefits": benefits}

# Utility functions for statistical analysis
def calculate_mean(values: list[float]) -> float:
    """Calculate arithmetic mean"""
    return sum(values) / len(values)

def calculate_std(values: list[float]) -> float:
    """Calculate standard deviation"""
    mean = calculate_mean(values)
    variance = sum((x - mean) ** 2 for x in values) / len(values)
    return sqrt(variance)

def calculate_slope(values: list[float]) -> float:
    """Calculate linear trend slope"""
    n = len(values)
    if n < 2:
        return 0.0
    
    x_sum = sum(range(n))
    y_sum = sum(values)
    xy_sum = sum(i * values[i] for i in range(n))
    x2_sum = sum(i * i for i in range(n))
    
    slope = (n * xy_sum - x_sum * y_sum) / (n * x2_sum - x_sum * x_sum)
    return slope

def is_cyclic(values: list[float]) -> bool:
    """Detect if values follow a cyclic pattern"""
    # Simplified cyclic detection
    if len(values) < 4:
        return false
    
    # Check for repeating patterns
    for period in range(2, len(values) // 2):
        if check_cyclic_period(values, period):
            return true
    
    return false

def is_trending(values: list[float]) -> bool:
    """Detect if values follow a trending pattern"""
    slope = calculate_slope(values)
    return abs(slope) > 0.1  # Significant trend threshold

def calculate_confidence(values: list[float]) -> float:
    """Calculate confidence level for analysis results"""
    # Simplified confidence calculation
    if len(values) < 10:
        return 0.5
    elif len(values) < 50:
        return 0.7
    else:
        return 0.9

def calculate_trend_confidence(values: list[float]) -> float:
    """Calculate confidence for trend analysis"""
    slope = calculate_slope(values)
    r_squared = calculate_r_squared(values, slope)
    return min(r_squared, 0.95)  # Cap at 95%

def calculate_r_squared(values: list[float], slope: float) -> float:
    """Calculate R-squared for trend fit"""
    mean = calculate_mean(values)
    n = len(values)
    
    ss_res = sum((values[i] - (slope * i + mean)) ** 2 for i in range(n))
    ss_tot = sum((values[i] - mean) ** 2 for i in range(n))
    
    return 1 - (ss_res / ss_tot) if ss_tot > 0 else 0.0

def check_cyclic_period(values: list[float], period: int) -> bool:
    """Check if values repeat with given period"""
    if len(values) < 2 * period:
        return false
    
    # Compare first period with second period
    for i in range(period):
        if abs(values[i] - values[i + period]) > 0.1:
            return false
    
    return true

def has_equipment_pattern(patterns: list[Pattern], parameters: list[str]) -> bool:
    """Check if patterns suggest equipment-related issues"""
    for pattern in patterns:
        if pattern.pattern_type == "cyclic" and any("temp" in p or "power" in p for p in parameters):
            return true
    return false

def has_process_pattern(patterns: list[Pattern], parameters: list[str]) -> bool:
    """Check if patterns suggest process-related issues"""
    for pattern in patterns:
        if pattern.pattern_type == "trending" and any("flow" in p or "pressure" in p for p in parameters):
            return true
    return false

def apply_process_optimization(current_value: float, cause_description: str) -> float:
    """Apply domain-specific process optimization"""
    # Simplified optimization logic
    if "temperature" in cause_description.lower():
        return current_value * 0.95  # Reduce temperature by 5%
    elif "pressure" in cause_description.lower():
        return current_value * 1.05  # Increase pressure by 5%
    elif "flow" in cause_description.lower():
        return current_value * 1.02  # Increase flow by 2%
    else:
        return current_value

def simulate_quality(parameters: dict[str, float]) -> float:
    """Simulate expected quality with given parameters"""
    # Simplified quality simulation
    base_quality = 0.92
    temp_factor = 1.0
    pressure_factor = 1.0
    
    if "temperature" in parameters:
        temp_factor = 1.0 - abs(parameters["temperature"] - 500) / 1000
    
    if "pressure" in parameters:
        pressure_factor = 1.0 - abs(parameters["pressure"] - 50) / 100
    
    return base_quality * temp_factor * pressure_factor

def simulate_yield(parameters: dict[str, float]) -> float:
    """Simulate expected yield with given parameters"""
    # Simplified yield simulation
    base_yield = 0.88
    quality = simulate_quality(parameters)
    return base_yield * quality

def simulate_cost(parameters: dict[str, float]) -> float:
    """Simulate expected cost with given parameters"""
    # Simplified cost simulation
    base_cost = 100.0
    
    if "temperature" in parameters:
        base_cost *= (1.0 + parameters["temperature"] / 1000)
    
    if "pressure" in parameters:
        base_cost *= (1.0 + parameters["pressure"] / 100)
    
    return base_cost

def convert_problem_to_data(problem: ManufacturingProblem) -> ProcessData:
    """Convert manufacturing problem to process data"""
    return ProcessData(
        timestamp=current_timestamp(),
        equipment_id=problem.affected_equipment[0] if problem.affected_equipment else "unknown",
        parameters={},  # Would be populated from actual equipment data
        measurements={},  # Would be populated from actual measurements
        quality_metrics={}  # Would be populated from actual quality data
    )

def calculate_execution_time() -> float:
    """Calculate execution time for the state machine"""
    # This would be implemented with actual timing
    return 0.0

def current_timestamp() -> str:
    """Get current timestamp string"""
    # This would be implemented with actual timestamp
    return "2024-01-22T10:00:00Z"

def create_executive_summary(results: dict[str, any]) -> str:
    """Create executive summary of results"""
    return f"Process analysis completed with {len(results)} phases. " + \
           f"Success: {results.get('validation', {}).get('is_safe', false)}"

def create_detailed_analysis(results: dict[str, any]) -> dict[str, any]:
    """Create detailed analysis of results"""
    return {
        "analysis_phase": results.get("analysis", {}),
        "diagnosis_phase": results.get("diagnosis", {}),
        "optimization_phase": results.get("optimization", {}),
        "validation_phase": results.get("validation", {})
    }

def create_actionable_recommendations(results: dict[str, any]) -> list[str]:
    """Create actionable recommendations from results"""
    recommendations = []
    
    if "diagnosis" in results:
        for cause in results["diagnosis"].get("root_causes", []):
            recommendations.extend(cause.get("suggested_actions", []))
    
    return recommendations

def determine_next_steps(results: dict[str, any]) -> list[str]:
    """Determine next steps based on results"""
    next_steps = []
    
    if results.get("validation", {}).get("is_safe", false):
        next_steps.append("Implement optimized parameters")
        next_steps.append("Monitor performance for 24 hours")
    else:
        next_steps.append("Review optimization recommendations")
        next_steps.append("Consult with process engineers")
    
    return next_steps 