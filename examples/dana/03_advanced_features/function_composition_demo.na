# Function Composition Demo in Dana
#
# This demonstrates the new function composition feature using declarative function definitions.
# Function composition allows creating reusable function pipelines with clear signatures.
#
# Copyright Â© 2025 Aitomatic, Inc.
# MIT License

print("ðŸ”§ Dana Function Composition Demo")
print("=" * 50)


# Define some utility functions for demonstration
def add_ten(x):
    return x + 10


def double(x):
    return x * 2


def stringify(x):
    return "Result: " + str(x)


def create_person(name):
    return {"name": name, "age": 0, "skills": []}


def set_age_25(person):
    person_copy = person.copy()
    person_copy["age"] = 25
    return person_copy


def add_coding_skills(person):
    person_copy = person.copy()
    person_copy["skills"] = person["skills"] + ["Python", "Dana"]
    return person_copy


print("\n1. Basic Function Composition")
print("-" * 30)

# Create a simple composition using declarative syntax
def math_pipeline(x: int) -> str = add_ten | double | stringify

# Test the composed function
result = math_pipeline(5)
print("math_pipeline(5) = " + str(result))
print("  â†’ add_ten(5) = 15")
print("  â†’ double(15) = 30")
print("  â†’ stringify(30) = 'Result: 30'")

print("\n2. Data Pipeline vs Function Composition")
print("-" * 40)

# Data pipeline: immediate execution (using the declarative function)
immediate_result = math_pipeline(7)
print("math_pipeline(7) = " + str(immediate_result))

# Or create another declarative function for direct composition
def direct_pipeline(x: int) -> str = add_ten | double | stringify
direct_result = direct_pipeline(3)
print("direct_pipeline(3) = " + str(direct_result))

print("\n3. Complex Data Processing Pipeline")
print("-" * 38)

# Create a person processing pipeline using declarative syntax
def person_builder(name: str) -> dict = create_person | set_age_25 | add_coding_skills

# Test the person builder
alice = person_builder("Alice")
print("person_builder('Alice') = " + str(alice))

bob = person_builder("Bob")
print("person_builder('Bob') = " + str(bob))

print("\n4. Chained Function Composition")
print("-" * 35)

# Create multiple levels of composition using declarative syntax
def step1(x: int) -> int = add_ten | double
def step2(x: int) -> str = step1 | stringify
def final_pipeline(x: int) -> str = step2

# Test the chained composition
chained_result = final_pipeline(1)
print("final_pipeline(1) = " + str(chained_result))
print("  â†’ step1(1) = add_ten(double(1)) = add_ten(2) = 12")
print("  â†’ Wait, that's wrong... let me trace this correctly:")
print("  â†’ add_ten(1) = 11, double(11) = 22, stringify(22) = 'Result: 22'")

print("\n5. Function Composition with Different Data Types")
print("-" * 50)


def square(x):
    return x * x


def to_list(x):
    return [x]


def append_message(lst):
    return lst + ["processed"]


# Create a mixed-type pipeline using declarative syntax
def mixed_pipeline(x: int) -> list = square | to_list | append_message

mixed_result = mixed_pipeline(4)
print("mixed_pipeline(4) = " + str(mixed_result))
print("  â†’ square(4) = 16")
print("  â†’ to_list(16) = [16]")
print("  â†’ append_message([16]) = [16, 'processed']")

print("\nâœ… Function Composition Demo Complete!")
print("\nKey Features Demonstrated:")
print("â€¢ Declarative function composition with clear signatures")
print("â€¢ Function composition with | operator")
print("â€¢ Left-associative evaluation")
print("â€¢ Complex data structure processing")
print("â€¢ Reusable composition with type annotations")
print("â€¢ Multiple data types flowing through pipelines")
print("â€¢ Better IDE support and debugging")
