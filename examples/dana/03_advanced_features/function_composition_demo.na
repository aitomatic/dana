# Function Composition Demo in Dana
#
# This demonstrates the new function composition feature using declarative function definitions.
# Function composition allows creating reusable function pipelines with clear signatures.
#
# Copyright Â© 2025 Aitomatic, Inc.
# MIT License

print("ðŸ”§ Dana Function Composition Demo")
print("=" * 50)


# Define some utility functions for demonstration
def add_ten(x):
    return x + 10


def double(x):
    return x * 2


def stringify(x):
    return "Result: " + str(x)


def create_person(name):
    return {"name": name, "age": 0, "skills": []}


def set_age_25(person):
    person_copy = person.copy()
    person_copy["age"] = 25
    return person_copy


def add_coding_skills(person):
    person_copy = person.copy()
    person_copy["skills"] = person["skills"] + ["Python", "Dana"]
    return person_copy


print("\n1. Basic Function Composition")
print("-" * 30)

# Create a simple composition using declarative syntax
def math_pipeline(x: int) -> str = add_ten | double | stringify

# Test the composed function
result = math_pipeline(5)
print("math_pipeline(5) = " + str(result))
print("  â†’ add_ten(5) = 15")
print("  â†’ double(15) = 30")
print("  â†’ stringify(30) = 'Result: 30'")

print("\n2. Parameter Passing in Pipelines")
print("-" * 35)

# Define functions that take additional parameters
def add_prefix(text: str, prefix: str = "Prefix: ") -> str:
    return f"{prefix}{text}"

def to_uppercase(text: str) -> str:
    return text.upper()

def add_suffix(text: str, suffix: str = "!!!") -> str:
    return f"{text}{suffix}"

def format_message(prefix: str, text: str, suffix: str) -> str:
    return f"{prefix}{text}{suffix}"

def multiply_text(text: str, multiplier: int) -> str:
    return text * multiplier

def surround_with(text: str, left: str, right: str) -> str:
    return f"{left}{text}{right}"

print("\n2a. Implicit First-Argument Mode (Default)")
print("-" * 40)

# Pipeline automatically passes the value as first argument
def basic_pipeline(text: str) = add_prefix("Data: ") | to_uppercase | add_suffix("?")
result = basic_pipeline("hello")
print("basic_pipeline('hello') = " + str(result))
print("  â†’ add_prefix('hello', 'Data: ') = 'Data: hello'")
print("  â†’ to_uppercase('Data: hello') = 'DATA: HELLO'")
print("  â†’ add_suffix('DATA: HELLO', '?') = 'DATA: HELLO?'")

# With default arguments
def default_pipeline(text: str) = add_prefix | to_uppercase
result = default_pipeline("world")
print("default_pipeline('world') = " + str(result))
print("  â†’ add_prefix('world') = 'Prefix: world'")
print("  â†’ to_uppercase('Prefix: world') = 'PREFIX: WORLD'")

print("\n2b. Explicit Placeholder Mode")
print("-" * 35)

# Placeholder in middle position
def middle_placeholder_pipeline(text: str) = format_message("Start: ", $$, " :End")
result = middle_placeholder_pipeline("hello")
print("middle_placeholder_pipeline('hello') = " + str(result))
print("  â†’ format_message('Start: ', 'hello', ' :End') = 'Start: hello :End'")

# Placeholder in first position
def first_placeholder_pipeline(text: str) = format_message($$, "MIDDLE", "!!!")
result = first_placeholder_pipeline("world")
print("first_placeholder_pipeline('world') = " + str(result))
print("  â†’ format_message('world', 'MIDDLE', '!!!') = 'worldMIDDLE!!!'")

# Placeholder in last position
def last_placeholder_pipeline(text: str) = format_message("START", "MIDDLE", $$)
result = last_placeholder_pipeline("end")
print("last_placeholder_pipeline('end') = " + str(result))
print("  â†’ format_message('START', 'MIDDLE', 'end') = 'STARTMIDDLEend'")

# Multiple placeholders
def multi_placeholder_func(a: str, b: str, c: str, d: str) -> str:
    return f"{a}-{b}-{c}-{d}"

def multi_placeholder_pipeline(text: str) = multi_placeholder_func("start", $$, "middle", $$)
result = multi_placeholder_pipeline("value")
print("multi_placeholder_pipeline('value') = " + str(result))
print("  â†’ multi_placeholder_func('start', 'value', 'middle', 'value') = 'start-value-middle-value'")

print("\n2c. Mixed Mode")
print("-" * 15)

# Mix implicit and explicit modes
def format_with_prefix(text: str, prefix: str) -> str:
    return f"{prefix}{text}"

def wrap_with_brackets(text: str, left: str, right: str) -> str:
    return f"{left}{text}{right}"

def complex_mixed_pipeline(text: str) = format_with_prefix("INFO: ") | wrap_with_brackets("[", $$, "]")
result = complex_mixed_pipeline("data")
print("complex_mixed_pipeline('data') = " + str(result))
print("  â†’ format_with_prefix('data', 'INFO: ') = 'INFO: data'")
print("  â†’ wrap_with_brackets('[', 'INFO: data', ']') = '[INFO: data]'")

print("\n2d. Numeric Parameter Passing")
print("-" * 30)

def add_numbers(a: int, b: int) -> int:
    return a + b

def multiply_by(a: int, multiplier: int = 2) -> int:
    return a * multiplier

# Numeric pipeline with fixed parameters
def numeric_pipeline(x: int) = add_numbers(10) | add_numbers(3)
result = numeric_pipeline(5)
print("numeric_pipeline(5) = " + str(result))
print("  â†’ add_numbers(5, 10) = 15")
print("  â†’ add_numbers(15, 3) = 18")

# Numeric pipeline with default parameters
def multiply_pipeline(x: int) = multiply_by(3)
result = multiply_pipeline(7)
print("multiply_pipeline(7) = " + str(result))
print("  â†’ multiply_by(7, 3) = 21")

print("\n3. Data Pipeline vs Function Composition")
print("-" * 40)

# Data pipeline: immediate execution (using the declarative function)
immediate_result = math_pipeline(7)
print("math_pipeline(7) = " + str(immediate_result))

# Or create another declarative function for direct composition
def direct_pipeline(x: int) -> str = add_ten | double | stringify
direct_result = direct_pipeline(3)
print("direct_pipeline(3) = " + str(direct_result))

print("\n4. Complex Data Processing Pipeline")
print("-" * 38)

# Create a person processing pipeline using declarative syntax
def person_builder(name: str) -> dict = create_person | set_age_25 | add_coding_skills

# Test the person builder
alice = person_builder("Alice")
print("person_builder('Alice') = " + str(alice))

bob = person_builder("Bob")
print("person_builder('Bob') = " + str(bob))

print("\n5. Chained Function Composition")
print("-" * 35)

# Create multiple levels of composition using declarative syntax
def step1(x: int) -> int = add_ten | double
def step2(x: int) -> str = step1 | stringify
def final_pipeline(x: int) -> str = step2

# Test the chained composition
chained_result = final_pipeline(1)
print("final_pipeline(1) = " + str(chained_result))
print("  â†’ step1(1) = add_ten(double(1)) = add_ten(2) = 12")
print("  â†’ Wait, that's wrong... let me trace this correctly:")
print("  â†’ add_ten(1) = 11, double(11) = 22, stringify(22) = 'Result: 22'")

print("\n6. Function Composition with Different Data Types")
print("-" * 50)


def square(x):
    return x * x


def to_list(x):
    return [x]


def append_message(lst):
    return lst + ["processed"]


# Create a mixed-type pipeline using declarative syntax
def mixed_pipeline(x: int) -> list = square | to_list | append_message

mixed_result = mixed_pipeline(4)
print("mixed_pipeline(4) = " + str(mixed_result))
print("  â†’ square(4) = 16")
print("  â†’ to_list(16) = [16]")
print("  â†’ append_message([16]) = [16, 'processed']")

print("\n7. List Processing with Parameters")
print("-" * 35)

def process_list(items: list, prefix: str = "item:") -> list:
    result = []
    for item in items:
        result.append(prefix + " " + str(item))
    return result

def add_to_list(lst: list, item: any) -> list:
    return lst + [item]

def filter_even(lst: list) -> list:
    result = []
    for x in lst:
        if x % 2 == 0:
            result.append(x)
    return result

# List processing pipeline with parameters
def list_processing_pipeline(data: list) = data | process_list("num:") | add_to_list(5) | filter_even
result = list_processing_pipeline([1, 2, 3, 4])
print("list_processing_pipeline([1, 2, 3, 4]) = " + str(result))
print("  â†’ process_list([1, 2, 3, 4], 'num:') = ['num: 1', 'num: 2', 'num: 3', 'num: 4']")
print("  â†’ add_to_list(['num: 1', 'num: 2', 'num: 3', 'num: 4'], 5) = ['num: 1', 'num: 2', 'num: 3', 'num: 4', 5]")
print("  â†’ filter_even(['num: 1', 'num: 2', 'num: 3', 'num: 4', 5]) = [5] (only numeric values are filtered)")

print("\n8. Named Parameter Capture Mode")
print("-" * 35)

def add_values(a: int, b: int) -> int:
    return a + b

# Simple named capture
def simple_named_pipeline(x: int) = add_ten as base | multiply_by(base, 2)
result = simple_named_pipeline(5)
print("simple_named_pipeline(5) = " + str(result))
print("  â†’ add_ten(5) = 15 (saved as 'base')")
print("  â†’ multiply_by(15, 2) = 30")

# Multiple named captures
def multi_named_pipeline(x: int) = add_ten as step1 | multiply_by(2) as step2 | add_values(step1, step2)
result = multi_named_pipeline(5)
print("multi_named_pipeline(5) = " + str(result))
print("  â†’ add_ten(5) = 15 (saved as 'step1')")
print("  â†’ multiply_by(15, 2) = 30 (saved as 'step2')")
print("  â†’ add_values(15, 30) = 45")

# Named capture with placeholder
def mixed_named_pipeline(x: int) = add_ten as base | multiply_by($$, 3) as tripled | add_values(base, tripled)
result = mixed_named_pipeline(5)
print("mixed_named_pipeline(5) = " + str(result))
print("  â†’ add_ten(5) = 15 (saved as 'base')")
print("  â†’ multiply_by(15, 3) = 45 (saved as 'tripled')")
print("  â†’ add_values(15, 45) = 60")

# Complex named capture with multiple reuses
def complex_named_pipeline(x: int) = add_ten as original | multiply_by(2) as doubled | multiply_by(3) as tripled | add_values(original, doubled) as sum1 | add_values(sum1, tripled) as final
result = complex_named_pipeline(5)
print("complex_named_pipeline(5) = " + str(result))
print("  â†’ add_ten(5) = 15 (saved as 'original')")
print("  â†’ multiply_by(15, 2) = 30 (saved as 'doubled')")
print("  â†’ multiply_by(30, 3) = 90 (saved as 'tripled')")
print("  â†’ add_values(15, 30) = 45 (saved as 'sum1')")
print("  â†’ add_values(45, 90) = 135 (saved as 'final')")

print("\nâœ… Function Composition Demo Complete!")
print("\nKey Features Demonstrated:")
print("â€¢ Declarative function composition with clear signatures")
print("â€¢ Function composition with | operator")
print("â€¢ Left-associative evaluation")
print("â€¢ Complex data structure processing")
print("â€¢ Reusable composition with type annotations")
print("â€¢ Multiple data types flowing through pipelines")
print("â€¢ Better IDE support and debugging")
print("â€¢ Parameter passing in implicit first-argument mode")
print("â€¢ Parameter passing with explicit $$ placeholders")
print("â€¢ Named parameter capture with 'as name' syntax")
print("â€¢ Mixed mode parameter passing (implicit + explicit + named)")
print("â€¢ Numeric and list processing with parameters")
