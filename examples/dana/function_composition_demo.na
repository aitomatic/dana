# Function Composition Demo in Dana
#
# This demonstrates the new function composition feature using the pipe operator (|).
# Function composition allows creating reusable function pipelines.
#
# Copyright Â© 2025 Aitomatic, Inc.
# MIT License

print("ðŸ”§ Dana Function Composition Demo")
print("=" * 50)


# Define some utility functions for demonstration
def add_ten(x):
    return x + 10


def double(x):
    return x * 2


def stringify(x):
    return "Result: " + str(x)


def create_person(name):
    return {"name": name, "age": 0, "skills": []}


def set_age_25(person):
    person_copy = person.copy()
    person_copy["age"] = 25
    return person_copy


def add_coding_skills(person):
    person_copy = person.copy()
    person_copy["skills"] = person["skills"] + ["Python", "Dana"]
    return person_copy


print("\n1. Basic Function Composition")
print("-" * 30)

# Create a simple composition: f = add_ten | double | stringify
math_pipeline = add_ten | double | stringify

# Test the composed function
result = math_pipeline(5)
print("math_pipeline(5) = " + str(result))
print("  â†’ add_ten(5) = 15")
print("  â†’ double(15) = 30")
print("  â†’ stringify(30) = 'Result: 30'")

print("\n2. Data Pipeline vs Function Composition")
print("-" * 40)

# Data pipeline: immediate execution
immediate_result = 7 | math_pipeline
print("7 | math_pipeline = " + str(immediate_result))

# Or even more direct:
direct_result = 3 | add_ten | double | stringify
print("3 | add_ten | double | stringify = " + str(direct_result))

print("\n3. Complex Data Processing Pipeline")
print("-" * 38)

# Create a person processing pipeline
person_builder = create_person | set_age_25 | add_coding_skills

# Test the person builder
alice = person_builder("Alice")
print("person_builder('Alice') = " + str(alice))

bob = person_builder("Bob")
print("person_builder('Bob') = " + str(bob))

print("\n4. Chained Function Composition")
print("-" * 35)

# Create multiple levels of composition
step1 = add_ten | double
step2 = step1 | stringify
final_pipeline = step2

# Test the chained composition
chained_result = final_pipeline(1)
print("final_pipeline(1) = " + str(chained_result))
print("  â†’ step1(1) = add_ten(double(1)) = add_ten(2) = 12")
print("  â†’ Wait, that's wrong... let me trace this correctly:")
print("  â†’ add_ten(1) = 11, double(11) = 22, stringify(22) = 'Result: 22'")

print("\n5. Function Composition with Different Data Types")
print("-" * 50)


def square(x):
    return x * x


def to_list(x):
    return [x]


def append_message(lst):
    return lst + ["processed"]


# Create a mixed-type pipeline
mixed_pipeline = square | to_list | append_message

mixed_result = mixed_pipeline(4)
print("mixed_pipeline(4) = " + str(mixed_result))
print("  â†’ square(4) = 16")
print("  â†’ to_list(16) = [16]")
print("  â†’ append_message([16]) = [16, 'processed']")

print("\nâœ… Function Composition Demo Complete!")
print("\nKey Features Demonstrated:")
print("â€¢ Function composition with | operator")
print("â€¢ Left-associative evaluation")
print("â€¢ Mixed data pipeline and function composition")
print("â€¢ Complex data structure processing")
print("â€¢ Immediate execution vs reusable composition")
print("â€¢ Multiple data types flowing through pipelines")
