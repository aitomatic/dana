# Dana Agent Keyword - Type Hint Adaptation Example
# This example demonstrates how agents adapt responses based on type hints

log("ğŸš€ Dana Agent Keyword - Type Hint Adaptation Example")
log("=" * 50)

# ============================================================================
# 1. AGENT DEFINITION
# ============================================================================

log("\nğŸ“‹ 1. Agent Definition")
log("-" * 30)

# Define an agent with built-in intelligence
agent DataAnalyst:
    domain: str = "manufacturing"
    expertise_level: str = "senior"
    analysis_type: str = "statistical"
    visualization_preference: str = "charts"

log("âœ… Agent type 'DataAnalyst' defined")

# ============================================================================
# 2. DEFAULT RESPONSE BEHAVIOR
# ============================================================================

log("\nğŸ”„ 2. Default Response Behavior")
log("-" * 30)

# Create agent instance
analyst = DataAnalyst(
    domain="semiconductor",
    expertise_level="expert",
    analysis_type="predictive",
    visualization_preference="dashboards"
)

log(f"âœ… Created analyst: {analyst}")

# Default plan() behavior (returns list)
log("\nğŸ“‹ Testing default plan() behavior:")
default_plan = analyst.plan(
    "Analyze production yield data for Q1 2024",
    context={
        "data_source": "production_database",
        "time_period": "Q1_2024",
        "metrics": ["yield_rate", "defect_rate", "throughput"],
        "complexity": "high"
    }
)

log(f"ğŸ“ Default Plan Result: {default_plan}")
log(f"ğŸ“Š Default Plan Type: {type(default_plan)}")

# Default solve() behavior (returns dict)
log("\nğŸ” Testing default solve() behavior:")
default_solve = analyst.solve(
    "Declining yield trend in etching process",
    context={
        "trend_period": "3_months",
        "affected_products": ["wafer_A", "wafer_B"],
        "severity": "moderate"
    }
)

log(f"ğŸ’¡ Default Solve Result: {default_solve}")
log(f"ğŸ“Š Default Solve Type: {type(default_solve)}")

# ============================================================================
# 3. EXPLICIT TYPE HINTS - LIST RESPONSES
# ============================================================================

log("\nğŸ“‹ 3. Explicit Type Hints - List Responses")
log("-" * 30)

# Explicit list type hint for plan()
log("\nğŸ“‹ Testing plan() with explicit list type hint:")
plan_steps: list = analyst.plan(
    "Optimize manufacturing process parameters",
    context={
        "process_type": "plasma_etching",
        "optimization_goal": "reduce_defects",
        "constraints": ["cost", "time", "quality"]
    }
)

log(f"ğŸ“ List Plan Result: {plan_steps}")
log(f"ğŸ“Š List Plan Type: {type(plan_steps)}")

# Explicit list type hint for solve()
log("\nğŸ” Testing solve() with explicit list type hint:")
solve_steps: list = analyst.solve(
    "Root cause analysis for equipment failures",
    context={
        "failure_pattern": "intermittent",
        "affected_equipment": ["ETCH-001", "ETCH-002"],
        "timeframe": "last_30_days"
    }
)

log(f"ğŸ’¡ List Solve Result: {solve_steps}")
log(f"ğŸ“Š List Solve Type: {type(solve_steps)}")

# ============================================================================
# 4. EXPLICIT TYPE HINTS - DICT RESPONSES
# ============================================================================

log("\nğŸ“Š 4. Explicit Type Hints - Dict Responses")
log("-" * 30)

# Explicit dict type hint for plan()
log("\nğŸ“‹ Testing plan() with explicit dict type hint:")
plan_dict: dict = analyst.plan(
    "Comprehensive data analysis workflow",
    context={
        "analysis_scope": "full_production_line",
        "data_volume": "large",
        "reporting_requirements": ["executive_summary", "technical_details", "recommendations"]
    }
)

log(f"ğŸ“ Dict Plan Result: {plan_dict}")
log(f"ğŸ“Š Dict Plan Type: {type(plan_dict)}")

# Explicit dict type hint for solve()
log("\nğŸ” Testing solve() with explicit dict type hint:")
solve_dict: dict = analyst.solve(
    "Statistical process control implementation",
    context={
        "control_charts": ["xbar_r", "p_chart", "c_chart"],
        "sample_size": 30,
        "confidence_level": 0.95
    }
)

log(f"ğŸ’¡ Dict Solve Result: {solve_dict}")
log(f"ğŸ“Š Dict Solve Type: {type(solve_dict)}")

# ============================================================================
# 5. COMPLEX TYPE HINTS - NESTED STRUCTURES
# ============================================================================

log("\nğŸ—ï¸ 5. Complex Type Hints - Nested Structures")
log("-" * 30)

# Complex type hint with nested structure
log("\nğŸ“‹ Testing plan() with complex type hint:")
complex_plan: dict[str, list[str]] = analyst.plan(
    "Multi-phase analysis project",
    context={
        "phases": ["data_collection", "analysis", "reporting"],
        "stakeholders": ["engineering", "management", "quality"],
        "timeline": "6_weeks"
    }
)

log(f"ğŸ“ Complex Plan Result: {complex_plan}")
log(f"ğŸ“Š Complex Plan Type: {type(complex_plan)}")

# List of dicts type hint
log("\nğŸ” Testing solve() with list of dicts type hint:")
detailed_solutions: list[dict] = analyst.solve(
    "Multi-factor optimization problem",
    context={
        "factors": ["temperature", "pressure", "time", "concentration"],
        "objectives": ["maximize_yield", "minimize_cost", "maintain_quality"],
        "constraints": ["equipment_limits", "safety_requirements"]
    }
)

log(f"ğŸ’¡ Detailed Solutions Result: {detailed_solutions}")
log(f"ğŸ“Š Detailed Solutions Type: {type(detailed_solutions)}")

# ============================================================================
# 6. TYPE HINT DETECTION AND ADAPTATION
# ============================================================================

log("\nğŸ¯ 6. Type Hint Detection and Adaptation")
log("-" * 30)

# Test different variable assignments to see type adaptation
log("\nğŸ”„ Testing type adaptation through assignment:")

# Assignment to list variable
log("\nğŸ“‹ Assignment to list variable:")
list_result = analyst.plan("Simple analysis task")
log(f"ğŸ“ List Assignment Result: {list_result}")
log(f"ğŸ“Š List Assignment Type: {type(list_result)}")

# Assignment to dict variable
log("\nğŸ“‹ Assignment to dict variable:")
dict_result = analyst.plan("Detailed analysis task")
log(f"ğŸ“ Dict Assignment Result: {dict_result}")
log(f"ğŸ“Š Dict Assignment Type: {type(dict_result)}")

# Assignment to mixed variable
log("\nğŸ“‹ Assignment to mixed variable:")
mixed_result = analyst.solve("Complex problem")
log(f"ğŸ“ Mixed Assignment Result: {mixed_result}")
log(f"ğŸ“Š Mixed Assignment Type: {type(mixed_result)}")

# ============================================================================
# 7. CONTEXT-AWARE TYPE ADAPTATION
# ============================================================================

log("\nğŸ§  7. Context-Aware Type Adaptation")
log("-" * 30)

# Test how context influences response format
log("\nğŸ“‹ Testing context-aware adaptation:")

# Simple context - should return list
simple_context = {
    "complexity": "low",
    "detail_level": "basic"
}

simple_result = analyst.plan("Basic task", context=simple_context)
log(f"ğŸ“ Simple Context Result: {simple_result}")
log(f"ğŸ“Š Simple Context Type: {type(simple_result)}")

# Complex context - should return dict
complex_context = {
    "complexity": "high",
    "detail_level": "comprehensive",
    "stakeholders": ["executive", "technical", "operational"],
    "reporting_requirements": ["summary", "details", "recommendations", "action_items"]
}

complex_result = analyst.plan("Complex task", context=complex_context)
log(f"ğŸ“ Complex Context Result: {complex_result}")
log(f"ğŸ“Š Complex Context Type: {type(complex_result)}")

# ============================================================================
# 8. TYPE HINT BEST PRACTICES
# ============================================================================

log("\nğŸ’¡ 8. Type Hint Best Practices")
log("-" * 30)

log("""
âœ… Best Practices for Type Hints with Agents:

1. **Explicit Type Hints**: Use when you need specific format
   âœ… plan_steps: list = agent.plan("task")
   âœ… analysis: dict = agent.solve("problem")

2. **Context-Driven Adaptation**: Let context determine format
   âœ… result = agent.plan("task", context={"detail_level": "high"})

3. **Consistent Naming**: Use descriptive variable names
   âœ… plan_steps: list = agent.plan("task")
   âœ… plan_details: dict = agent.plan("task")

4. **Type Safety**: Leverage Dana's type system
   âœ… detailed_analysis: dict[str, list[str]] = agent.plan("task")

5. **Adaptive Responses**: Use when format doesn't matter
   âœ… result = agent.plan("task")  # Agent chooses best format

6. **Performance Considerations**: 
   - List responses: Faster, simpler
   - Dict responses: More detailed, structured
   - Choose based on your needs
""")

# ============================================================================
# 9. REAL-WORLD TYPE ADAPTATION SCENARIOS
# ============================================================================

log("\nğŸŒ 9. Real-World Type Adaptation Scenarios")
log("-" * 30)

# Scenario 1: Executive reporting (dict format)
log("\nğŸ“Š Scenario 1: Executive Reporting (Dict Format)")
executive_plan: dict = analyst.plan(
    "Q1 2024 Manufacturing Performance Review",
    context={
        "audience": "executive",
        "format": "executive_summary",
        "key_metrics": ["revenue_impact", "cost_savings", "efficiency_gains"],
        "presentation_style": "high_level"
    }
)

log(f"ğŸ“ Executive Plan: {executive_plan}")

# Scenario 2: Technical implementation (list format)
log("\nğŸ“‹ Scenario 2: Technical Implementation (List Format)")
technical_steps: list = analyst.plan(
    "Implement Statistical Process Control System",
    context={
        "audience": "technical",
        "format": "step_by_step",
        "implementation_level": "detailed",
        "include_code": true
    }
)

log(f"ğŸ“ Technical Steps: {technical_steps}")

# Scenario 3: Operational workflow (mixed format)
log("\nğŸ”„ Scenario 3: Operational Workflow (Mixed Format)")
workflow_solution = analyst.solve(
    "Production Line Bottleneck Analysis",
    context={
        "audience": "operational",
        "format": "actionable",
        "urgency": "high",
        "resource_constraints": ["time", "budget", "personnel"]
    }
)

log(f"ğŸ’¡ Workflow Solution: {workflow_solution}")

# ============================================================================
# 10. SUMMARY AND NEXT STEPS
# ============================================================================

log("\nğŸ¯ 10. Summary and Next Steps")
log("-" * 30)

log("""
âœ… What we've learned:
- Default response behavior (list for plan, dict for solve)
- Explicit type hint adaptation
- Context-aware response formatting
- Complex type hint patterns
- Real-world adaptation scenarios

ğŸš€ Key Benefits:
- Flexible response formats based on needs
- Type safety with Dana's type system
- Context-aware intelligence
- Consistent API with adaptive behavior

ğŸš€ Next steps:
- Learn advanced memory systems (04_memory_systems.na)
- Real-world applications (05_real_world_manufacturing.na)
- Advanced integration patterns (06_advanced_integration.na)
""")

log("\nğŸ‰ Type Hint Adaptation Example Complete!")
log("Agents now adapt their responses based on your type hints and context!") 