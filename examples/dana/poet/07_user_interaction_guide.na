# POET User Interaction Guide
# How humans interact with each of the four use cases

log("=== POET User Interaction Guide ===")
log("Learn how to use all four POET use cases effectively\n")

# ============================================================================
# USE CASE A: Simple Math Functions (POE)
# Domain: mathematical_operations
# Purpose: Automatic validation and reliability for mathematical operations
# ============================================================================

log("üìê USE CASE A: Mathematical Operations (POE)")
log("Purpose: Make math functions bulletproof without extra code")
log("")

# Step 1: User writes a simple function with @poet decorator
@poet(domain="mathematical_operations", retries=2)
def calculate_roi(investment: float, returns: float) -> float:
    """Calculate return on investment percentage."""
    return ((returns - investment) / investment) * 100

# Step 2: User calls function normally - POET handles all edge cases
log("Example A1: Normal calculation")
roi = calculate_roi(1000.0, 1500.0)
log(f"  ROI: {roi}% (50% profit)")

log("\nExample A2: Division by zero protection")
try:
    roi = calculate_roi(0.0, 100.0)  # Investment of 0
except ValueError as e:
    log(f"  Caught: {e}")
    log("  üí° User gets clear error instead of cryptic ZeroDivisionError")

log("\nWhat users love about Use Case A:")
log("- Write math like normal, get enterprise reliability")
log("- No manual validation code needed")  
log("- Clear error messages for edge cases")
log("- Automatic retry on transient errors\n")

# ============================================================================
# USE CASE B: LLM Enhancement (POE)
# Domain: llm_optimization
# Purpose: Reliable LLM interactions with prompt optimization
# ============================================================================

log("ü§ñ USE CASE B: LLM Optimization (POE)")
log("Purpose: Make LLM calls reliable and efficient")
log("")

# Step 1: User writes LLM function with @poet decorator
@poet(domain="llm_optimization", retries=3, timeout=30)
def generate_summary(text: str, max_words: int = 100) -> str:
    """Generate a concise summary of the given text."""
    # In real usage, this would call an LLM
    # POET handles retries, timeouts, validation automatically
    import os
    if os.getenv('OPENDXA_MOCK_LLM', 'true') == 'true':
        # Mock response for demo
        words = text.split()[:max_words]
        return f"Summary: {' '.join(words[:10])}... (mock summary)"
    else:
        # Real LLM call would go here
        return llm.generate(f"Summarize in {max_words} words: {text}")

# Step 2: User calls function - POET ensures quality
log("Example B1: Generate summary")
summary = generate_summary("AI is transforming how we work. Machine learning enables computers to learn from data. Deep learning uses neural networks.", 20)
log(f"  Result: {summary}")

log("\nExample B2: Empty input handling")
try:
    summary = generate_summary("")  # Empty text
except ValueError as e:
    log(f"  Caught: {e}")
    log("  üí° POET validates inputs before expensive LLM calls")

log("\nWhat users love about Use Case B:")
log("- Automatic retry with exponential backoff")
log("- Token usage monitoring")
log("- Response quality validation")
log("- Handles rate limits gracefully\n")

# ============================================================================
# USE CASE C: Prompt Optimization (POET with Learning)
# Domain: prompt_optimization
# Purpose: Prompts that get better over time through A/B testing
# ============================================================================

log("üéØ USE CASE C: Prompt Optimization (POET)")
log("Purpose: Self-improving prompts through A/B testing and feedback")
log("")

# Step 1: User writes function with optimize_for parameter
@poet(domain="prompt_optimization", optimize_for="clarity")
def explain_concept(concept: str, audience: str = "general") -> str:
    """Explain a concept clearly to the target audience."""
    # POET automatically:
    # 1. Tests different prompt variations
    # 2. Tracks which ones work best
    # 3. Learns from user feedback
    prompt = f"Explain {concept} to a {audience} audience"
    
    # In production, this calls LLM with the optimized prompt
    return f"Explanation of {concept} for {audience} (using optimized prompt variant)"

# Step 2: User calls function - POET tests variants automatically
log("Example C1: First explanation")
result1 = explain_concept("quantum computing", "high school student")
log(f"  Result: {result1}")

log("\nExample C2: Second call might use different prompt variant")
result2 = explain_concept("machine learning", "business executive")  
log(f"  Result: {result2}")

# Step 3: User provides feedback to improve prompts
log("\nExample C3: User feedback improves future results")
# In real usage:
# feedback(result1._poet.execution_id, "too technical")
# feedback(result2._poet.execution_id, "perfect level of detail")
log("  User feedback: 'too technical' for first result")
log("  User feedback: 'perfect' for second result")
log("  üí° POET learns which prompt styles work best")

log("\nWhat users love about Use Case C:")
log("- Prompts improve automatically based on feedback")
log("- A/B testing happens transparently")
log("- Best performing variants rise to the top")
log("- No manual prompt engineering needed\n")

# ============================================================================  
# USE CASE D: ML Monitoring (POET with Adaptive Learning)
# Domain: ml_monitoring
# Purpose: Self-adjusting ML monitoring that adapts to your data
# ============================================================================

log("üìä USE CASE D: ML Monitoring (POET)")
log("Purpose: Adaptive ML monitoring that learns normal patterns")
log("")

# Step 1: User writes ML inference function with @poet decorator
@poet(domain="ml_monitoring", optimize_for="accuracy")
def predict_customer_churn(customer_features: list[float]) -> float:
    """Predict probability of customer churn."""
    # POET automatically:
    # 1. Monitors input data distribution
    # 2. Detects drift from training data
    # 3. Adapts thresholds based on performance
    # 4. Alerts when retraining needed
    
    # Simulate ML model prediction
    import random
    base_score = sum(customer_features) / len(customer_features)
    return min(1.0, max(0.0, base_score + random.uniform(-0.1, 0.1)))

# Step 2: User makes predictions - POET monitors everything
log("Example D1: Normal prediction")
features1 = [0.7, 0.8, 0.6, 0.9, 0.7]  # Normal customer
churn_prob1 = predict_customer_churn(features1)
log(f"  Churn probability: {churn_prob1:.2%}")

log("\nExample D2: Unusual data detected") 
features2 = [0.1, 0.1, 0.2, 0.1, 0.1]  # Very different from usual
churn_prob2 = predict_customer_churn(features2)
log(f"  Churn probability: {churn_prob2:.2%}")
log("  ‚ö†Ô∏è POET detects this data is unusual (drift detected)")

log("\nExample D3: After many predictions, thresholds adapt")
# Simulate multiple predictions
for i in range(5):
    features = [0.5 + i*0.1, 0.6, 0.7, 0.8, 0.5]
    prob = predict_customer_churn(features)
    log(f"  Customer {i+1}: {prob:.2%} churn probability")

log("\nüí° Behind the scenes, POET is:")
log("  - Learning normal data patterns")
log("  - Adjusting drift detection sensitivity")
log("  - Tracking model performance over time")
log("  - Recommending when to retrain")

log("\nWhat users love about Use Case D:")
log("- No manual threshold setting")
log("- Drift detection that improves over time")
log("- Automatic performance tracking")
log("- Clear retraining recommendations\n")

# ============================================================================
# SUMMARY: How Users Interact with POET
# ============================================================================

log("=== Summary: POET Interaction Patterns ===\n")

log("1Ô∏è‚É£ SIMPLE DECORATION")
log("   Just add @poet(domain='...') to any function")
log("   No code changes needed inside the function\n")

log("2Ô∏è‚É£ NORMAL FUNCTION CALLS")  
log("   Call enhanced functions exactly like regular ones")
log("   POET magic happens transparently\n")

log("3Ô∏è‚É£ BETTER ERROR HANDLING")
log("   Get clear, actionable error messages")
log("   Not cryptic stack traces\n")

log("4Ô∏è‚É£ OPTIONAL FEEDBACK (Use Cases C & D)")
log("   Provide feedback to improve the system:")
log("   feedback(result._poet.execution_id, 'great')")
log("   System learns and adapts automatically\n")

log("5Ô∏è‚É£ ZERO CONFIGURATION")
log("   Sensible defaults for everything")
log("   Override only what you need\n")

log("‚ú® The POET Promise:")
log("Write simple code, get production-ready systems!")
log("From prototype to production in one decorator!")