# POET Transpiler Demonstration
# Shows how POET transforms simple functions into production-ready code

log("=== POET Transpiler Demonstration ===")
log("Transforming simple functions into robust, production-ready code")
log("")

# Original function (what you write)
log("BEFORE - Simple function:")
log("""
@poet(domain="mathematical_operations", retries=2)
def safe_divide(a: float, b: float) -> float:
    '''Safely divide two numbers.'''
    return a / b
""")

log("\nAFTER - POET-enhanced function includes:")
log("")

log("1. PERCEIVE PHASE - Input Validation:")
log("   ✓ Type checking: isinstance(a, (int, float, complex))")
log("   ✓ NaN detection: math.isnan(a)")
log("   ✓ Infinity check: math.isinf(a)")
log("   ✓ Range validation: abs(a) > 1e100")
log("   ✓ Division by zero: if param_value == 0 and 'b' == param_name")
log("")

log("2. OPERATE PHASE - Reliable Execution:")
log("   ✓ Retry logic with exponential backoff")
log("   ✓ Numerical stability monitoring")
log("   ✓ Underflow/overflow detection")
log("   ✓ Operation metadata tracking")
log("")

log("3. ENFORCE PHASE - Output Validation:")
log("   ✓ Result validation: not None, not NaN, not Inf")
log("   ✓ Business rules: magnitude checks")
log("   ✓ Domain-specific constraints")
log("   ✓ Final validation metadata")
log("")

# Demonstrate the key benefit
log("=== Key Benefit ===")
log("Division by zero is caught BEFORE execution:")
log("")

# Define the actual enhanced function
@poet(domain="mathematical_operations", retries=2)
def safe_divide(a: float, b: float) -> float:
    """Safely divide two numbers."""
    return a / b

# Test cases showing the enhancement
test_cases = [
    ("Normal division", 10.0, 2.0),
    ("Division by zero", 10.0, 0.0),
    ("Very large numbers", 1e99, 1e-99),
]

for test_name, a, b in test_cases:
    log(f"Test: {test_name}")
    log(f"  Input: safe_divide({a}, {b})")
    try:
        result = safe_divide(a, b)
        log(f"  Result: {result}")
    except ValueError as e:
        log(f"  ✓ Validation Error: {e}")
    except RuntimeError as e:
        log(f"  ✓ Runtime Error: {e}")
    log("")

# Show other mathematical operations
log("=== Other Mathematical Operations ===")

@poet(domain="mathematical_operations")
def calculate_compound_interest(principal: float, rate: float, time: float) -> float:
    """Calculate compound interest with automatic validation."""
    # POET will validate:
    # - All inputs are numeric and valid
    # - Rate is reasonable (not negative, not too large)
    # - Time is positive
    # - Result doesn't overflow
    return principal * ((1 + rate/100) ** time)

log("Compound Interest Example:")
try:
    result = calculate_compound_interest(1000.0, 5.0, 10.0)
    log(f"  $1000 at 5% for 10 years = ${result:.2f}")
except ValueError as e:
    log(f"  Error: {e}")

# Example with negative rate (should work but warn)
try:
    result = calculate_compound_interest(1000.0, -2.0, 5.0)
    log(f"  $1000 at -2% for 5 years = ${result:.2f}")
except ValueError as e:
    log(f"  Error: {e}")

log("\n=== Transpiler Benefits ===")
log("1. Write simple, clean functions")
log("2. Get enterprise-grade reliability automatically")
log("3. No boilerplate validation code needed")
log("4. Domain-specific intelligence built-in")
log("5. Consistent error handling across all functions")
log("6. Performance monitoring and retry logic included")
log("7. Ready for production use immediately!")

log("\n✨ POET: From prototype to production in one decorator!")