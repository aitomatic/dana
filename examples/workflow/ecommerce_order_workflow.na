# E-commerce Order Processing - Enterprise Workflow Example
#
# This example demonstrates a sophisticated e-commerce order processing system
# with fraud detection, inventory management, and customer communication.
#
# Features demonstrated:
# - Complex business logic workflows
# - Multiple validation gates
# - Error handling with recovery
# - Real-time inventory updates
# - Customer notification system

import dana.builtin_types.workflow_system.workflow_engine as workflow_engine
import dana.builtin_types.workflow_system.workflow_step as workflow_step
import dana.builtin_types.workflow_system.context_engine as context_engine
import dana.builtin_types.workflow_system.safety_validator as safety_validator

# Initialize workflow components
log("üõí Initializing E-commerce Order Processing Pipeline...")

context = context_engine.ContextEngine(max_knowledge_points=10000)
safety = safety_validator.SafetyValidator(strict_mode=True)
engine = workflow_engine.WorkflowEngine(context_engine=context, safety_validator=safety)

# Mock order database and inventory system
order_db = {}
inventory_db = {
    "laptop_001": {"stock": 50, "price": 999.99},
    "mouse_002": {"stock": 200, "price": 29.99},
    "keyboard_003": {"stock": 100, "price": 79.99}
}

# Step 1: Order Validation
log("üîç Step 1: Order Validation")

def validate_order(order_data: dict) -> dict:
    """Validate incoming order data and customer information."""
    log(f"üîç Validating order for customer: {order_data.get('customer_id', 'unknown')}")
    
    required_fields = ["customer_id", "items", "shipping_address", "payment_method"]
    missing_fields = [field for field in required_fields if field not in order_data]
    
    if missing_fields:
        raise ValueError(f"Missing required fields: {missing_fields}")
    
    # Validate items structure
    for item in order_data["items"]:
        if "product_id" not in item or "quantity" not in item:
            raise ValueError("Invalid item structure")
        if item["quantity"] <= 0:
            raise ValueError("Invalid quantity")
    
    # Store validation knowledge
    context.add_knowledge(
        content=f"Order validation passed for customer {order_data['customer_id']}",
        source="order_validator",
        tags=["order_validation", "customer", order_data['customer_id']]
    )
    
    return {
        **order_data,
        "validation_status": "passed",
        "validation_timestamp": "2025-07-17T11:00:00Z"
    }

# Step 2: Inventory Check
log("üì¶ Step 2: Inventory Check")

def check_inventory(validated_order: dict) -> dict:
    """Check inventory availability for all items in order."""
    log("üì¶ Checking inventory availability...")
    
    inventory_status = []
    insufficient_items = []
    
    for item in validated_order["items"]:
        product_id = item["product_id"]
        requested_qty = item["quantity"]
        
        if product_id not in inventory_db:
            insufficient_items.append({"product_id": product_id, "reason": "not_found"})
            continue
            
        available_qty = inventory_db[product_id]["stock"]
        if requested_qty > available_qty:
            insufficient_items.append({
                "product_id": product_id,
                "requested": requested_qty,
                "available": available_qty,
                "reason": "insufficient_stock"
            })
        else:
            inventory_status.append({
                "product_id": product_id,
                "available": available_qty,
                "requested": requested_qty,
                "price": inventory_db[product_id]["price"]
            })
    
    if insufficient_items:
        raise RuntimeError(f"Inventory issues: {insufficient_items}")
    
    # Calculate order total
    order_total = sum(item["price"] * item["requested"] for item in inventory_status)
    
    # Store inventory knowledge
    for status in inventory_status:
        context.add_knowledge(
            content=f"Inventory reserved: {status['product_id']} x{status['requested']}",
            source="inventory_manager",
            tags=["inventory", "reservation", status["product_id"]]
        )
    
    return {
        **validated_order,
        "inventory_status": inventory_status,
        "order_total": order_total,
        "inventory_check_passed": True
    }

# Step 3: Fraud Detection
log("üõ°Ô∏è Step 3: Fraud Detection")

def detect_fraud(order_with_inventory: dict) -> dict:
    """Run fraud detection algorithms on the order."""
    log("üõ°Ô∏è Running fraud detection...")
    
    # Simulate fraud detection logic
    fraud_indicators = []
    
    # Check for suspicious patterns
    if order_with_inventory["order_total"] > 2000:  # High value order
        fraud_indicators.append("high_value_order")
    
    if len(order_with_inventory["items"]) > 10:  # Large item count
        fraud_indicators.append("large_item_count")
    
    # Simulate risk scoring
    risk_score = len(fraud_indicators) * 25  # Simple scoring
    is_fraudulent = risk_score > 50
    
    if is_fraudulent:
        context.add_knowledge(
            content=f"Fraud detected for order {order_with_inventory['customer_id']} - risk score: {risk_score}",
            source="fraud_detector",
            tags=["fraud_detection", "blocked", "high_risk"]
        )
        raise RuntimeError(f"Order flagged as fraudulent - risk score: {risk_score}")
    
    # Store fraud check knowledge
    context.add_knowledge(
        content=f"Fraud check passed for {order_with_inventory['customer_id']} - risk score: {risk_score}",
        source="fraud_detector",
        tags=["fraud_detection", "passed", "low_risk"]
    )
    
    return {
        **order_with_inventory,
        "fraud_check": {
            "risk_score": risk_score,
            "indicators": fraud_indicators,
            "status": "passed"
        }
    }

# Step 4: Payment Processing
log("üí≥ Step 4: Payment Processing")

def process_payment(order_with_fraud_check: dict) -> dict:
    """Process payment for the order."""
    log(f"üí≥ Processing payment of ${order_with_fraud_check['order_total']}...")
    
    # Simulate payment processing
    payment_result = {
        "transaction_id": f"txn_{hash(str(order_with_fraud_check)) % 1000000}",
        "payment_method": order_with_fraud_check["payment_method"],
        "amount": order_with_fraud_check["order_total"],
        "status": "completed",
        "timestamp": "2025-07-17T11:05:00Z"
    }
    
    if payment_result["status"] != "completed":
        raise RuntimeError(f"Payment failed: {payment_result.get('error', 'unknown')}")
    
    # Store payment knowledge
    context.add_knowledge(
        content=f"Payment processed: {payment_result['transaction_id']} for ${payment_result['amount']}",
        source="payment_processor",
        tags=["payment", "completed", payment_result["transaction_id"]]
    )
    
    return {
        **order_with_fraud_check,
        "payment_result": payment_result,
        "payment_completed": True
    }

# Step 5: Inventory Update
log("üì¶ Step 5: Inventory Update")

def update_inventory(order_with_payment: dict) -> dict:
    """Update inventory after successful payment."""
    log("üì¶ Updating inventory levels...")
    
    for item in order_with_payment["inventory_status"]:
        product_id = item["product_id"]
        quantity_sold = item["requested"]
        
        # Update inventory
        if product_id in inventory_db:
            inventory_db[product_id]["stock"] -= quantity_sold
            
            # Store inventory update knowledge
            context.add_knowledge(
                content=f"Inventory updated: {product_id} stock reduced by {quantity_sold}",
                source="inventory_manager",
                tags=["inventory", "update", product_id, "sale"]
            )
    
    return {
        **order_with_payment,
        "inventory_updated": True,
        "updated_inventory": {k: v["stock"] for k, v in inventory_db.items()}
    }

# Step 6: Order Confirmation
log("‚úÖ Step 6: Order Confirmation")

def confirm_order(order_with_inventory_update: dict) -> dict:
    """Generate order confirmation and send to customer."""
    log("‚úÖ Generating order confirmation...")
    
    order_id = f"ORD-{hash(str(order_with_inventory_update)) % 1000000}"
    
    confirmation = {
        "order_id": order_id,
        "customer_id": order_with_inventory_update["customer_id"],
        "items": order_with_inventory_update["items"],
        "order_total": order_with_inventory_update["order_total"],
        "transaction_id": order_with_inventory_update["payment_result"]["transaction_id"],
        "estimated_delivery": "2025-07-22",
        "tracking_number": f"TRACK-{order_id}",
        "confirmation_sent": True
    }
    
    # Store final order knowledge
    context.add_knowledge(
        content=f"Order confirmed: {order_id} for customer {confirmation['customer_id']}",
        source="order_manager",
        tags=["order", "confirmed", order_id],
        metadata=confirmation
    )
    
    return confirmation

# Step 7: Customer Notification
log("üìß Step 7: Customer Notification")

def notify_customer(final_order: dict) -> dict:
    """Send notification to customer about order status."""
    log(f"üìß Notifying customer {final_order['customer_id']} about order {final_order['order_id']}")
    
    notification = {
        "type": "order_confirmation",
        "to": final_order["customer_id"],
        "subject": f"Order {final_order['order_id']} Confirmed",
        "message": f"Your order has been confirmed and will be delivered by {final_order['estimated_delivery']}",
        "tracking_url": f"https://tracking.example.com/{final_order['tracking_number']}",
        "notification_sent": True,
        "timestamp": "2025-07-17T11:10:00Z"
    }
    
    # Store notification knowledge
    context.add_knowledge(
        content=f"Customer notified: {notification['to']} about {final_order['order_id']}",
        source="notification_service",
        tags=["notification", "sent", final_order["customer_id"]]
    )
    
    return {**final_order, **notification}

# Create comprehensive workflow steps
log("üõ°Ô∏è Creating e-commerce workflow steps...")

steps = [
    engine.create_workflow_step(
        name="validate_order",
        function=validate_order,
        pre_conditions=[
            lambda data, ctx: isinstance(data, dict),
            lambda data, ctx: "customer_id" in data,
            lambda data, ctx: "items" in data and len(data["items"]) > 0
        ],
        post_conditions=[
            lambda result, ctx: result.get("validation_status") == "passed"
        ],
        error_handler=lambda error, data, ctx: {"validation_error": str(error), "status": "failed"},
        metadata={"description": "Validate incoming order data", "retry_count": 1}
    ),
    engine.create_workflow_step(
        name="check_inventory",
        function=check_inventory,
        pre_conditions=[lambda data, ctx: data.get("validation_status") == "passed"],
        post_conditions=[lambda result, ctx: result.get("inventory_check_passed") is True],
        error_handler=lambda error, data, ctx: {"inventory_error": str(error), "status": "inventory_failed"},
        metadata={"description": "Check inventory availability", "timeout": 10}
    ),
    engine.create_workflow_step(
        name="detect_fraud",
        function=detect_fraud,
        pre_conditions=[lambda data, ctx: data.get("inventory_check_passed") is True],
        post_conditions=[lambda result, ctx: result.get("fraud_check", {}).get("status") == "passed"],
        error_handler=lambda error, data, ctx: {"fraud_error": str(error), "status": "fraud_blocked"},
        metadata={"description": "Run fraud detection", "risk_threshold": 50}
    ),
    engine.create_workflow_step(
        name="process_payment",
        function=process_payment,
        pre_conditions=[lambda data, ctx: data.get("fraud_check", {}).get("status") == "passed"],
        post_conditions=[lambda result, ctx: result.get("payment_completed") is True],
        error_handler=lambda error, data, ctx: {"payment_error": str(error), "status": "payment_failed"},
        metadata={"description": "Process customer payment", "timeout": 30}
    ),
    engine.create_workflow_step(
        name="update_inventory",
        function=update_inventory,
        pre_conditions=[lambda data, ctx: data.get("payment_completed") is True],
        post_conditions=[lambda result, ctx: result.get("inventory_updated") is True],
        error_handler=lambda error, data, ctx: {"inventory_update_error": str(error), "status": "inventory_error"},
        metadata={"description": "Update inventory levels", "atomic": True}
    ),
    engine.create_workflow_step(
        name="confirm_order",
        function=confirm_order,
        pre_conditions=[lambda data, ctx: data.get("inventory_updated") is True],
        post_conditions=[lambda result, ctx: "order_id" in result],
        metadata={"description": "Generate order confirmation"}
    ),
    engine.create_workflow_step(
        name="notify_customer",
        function=notify_customer,
        pre_conditions=[lambda data, ctx: "order_id" in data],
        post_conditions=[lambda result, ctx: result.get("notification_sent") is True],
        metadata={"description": "Send customer notification", "channel": "email"}
    )
]

# Sample order data
sample_order = {
    "customer_id": "CUST-12345",
    "items": [
        {"product_id": "laptop_001", "quantity": 1},
        {"product_id": "mouse_002", "quantity": 2}
    ],
    "shipping_address": {
        "street": "123 Main St",
        "city": "San Francisco",
        "state": "CA",
        "zip": "94105"
    },
    "payment_method": "credit_card"
}

# Execute the complete e-commerce workflow
log("üöÄ Executing E-commerce Order Processing Workflow...")

try:
    result = engine.execute(steps, sample_order, workflow_id="ecommerce_order_001")
    
    log("‚úÖ Order Processing Complete!")
    log(f"üì¶ Order ID: {result['order_id']}")
    log(f"üí≥ Transaction: {result['transaction_id']}")
    log(f"üìß Notification: {result['notification_sent']}")
    
    # Show final inventory status
    log("üì¶ Final Inventory Status:")
    for product_id, stock in result["updated_inventory"].items():
        log(f"  {product_id}: {stock} remaining")
    
    # Show business intelligence
    log("üìä Business Intelligence:")
    fraud_knowledge = context.search_knowledge("fraud_detection", limit=5)
    log(f"Fraud detection events: {len(fraud_knowledge)}")
    
    payment_knowledge = context.search_knowledge("payment", limit=5)
    log(f"Payment processing events: {len(payment_knowledge)}")
    
    # Show workflow statistics
    stats = context.get_stats()
    log(f"üìà Total knowledge points: {stats['total_knowledge_points']}")
    log(f"üìà Unique sources: {len(stats['sources'])}")
    log(f"üìà Topics covered: {len(stats['unique_tags'])}")
    
except Exception as e:
    log(f"‚ùå Workflow failed: {str(e)}")
    # Error would be handled by error_handlers in each step