"""Credit Approval Workflows - Minimal & Efficient"""

from knowledge import fsa_regs, basel_iii, scoring, risk_levels, fraud_patterns
from docs import fsa_rules, basel_requirements, bureau_data
from resources import query_bureaus, verify_docs, check_compliance, store_audit, load_credit_dataset, load_credit_domain_theory, get_dataset_statistics, score_application, detect_fraud_patterns

def process_application(app: dict) -> dict:
    # Step 1: Load historical dataset and domain theory
    dataset = load_credit_dataset()
    domain_theory = load_credit_domain_theory()
    dataset_stats = get_dataset_statistics()
    
    # Step 2: Verify documents using FSA requirements
    doc_verification = verify_docs(app.get('documents', []))
    
    # Step 3: Query credit bureaus for applicant data
    bureau_data_result = query_bureaus(app.get('applicant_id', ''))
    
    # Step 4: Score application using historical patterns
    scoring_result = score_application(app, dataset_stats)
    
    # Step 5: Detect fraud patterns using domain knowledge
    fraud_detection = detect_fraud_patterns(app)
    
    # Step 6: Check compliance with FSA and Basel III requirements
    compliance_check = check_compliance({
        'applicant_data': app,
        'bureau_data': bureau_data_result,
        'scoring_result': scoring_result,
        'fraud_detection': fraud_detection,
        'fsa_regs': fsa_regs,
        'basel_iii': basel_iii
    })
    
    # Step 7: Make credit decision using all available data
    decision = reason(f"""
    Process credit application with the following data:
    
    Applicant: {app.get('applicant_id')}
    Requested Amount: ¥{app.get('amount', 0)}
    Income: ¥{app.get('income', 0)}
    Employment: {app.get('employment', 'unknown')}
    
    Historical Dataset: {dataset_stats['total_instances']} cases ({dataset_stats['positive_class']} approved, {dataset_stats['negative_class']} rejected)
    FSA Regulations: {fsa_regs}
    Basel III Requirements: {basel_iii}
    Scoring Factors: {scoring}
    Risk Levels: {risk_levels}
    Fraud Patterns: {fraud_patterns}
    
    Document Verification: {doc_verification}
    Bureau Data: {bureau_data_result}
    Scoring Result: {scoring_result}
    Fraud Detection: {fraud_detection}
    Compliance Check: {compliance_check}
    
    Make a credit decision considering:
    1. Document completeness per FSA requirements
    2. Credit score and history from bureaus
    3. Historical patterns from {dataset_stats['total_instances']} cases
    4. Debt-to-income ratio (max {fsa_regs.get('max_dti', 10)})
    5. Risk assessment using scoring factors
    6. Fraud detection using domain theory
    7. Basel III capital requirements
    
    Return a decision with approved_amount, interest_rate, and reasoning.
    """, context=app)
    
    # Step 8: Store audit trail
    audit_result = store_audit({
        'applicant_id': app.get('applicant_id'),
        'decision': decision,
        'dataset_used': dataset_stats,
        'timestamp': 'now'
    })
    
    return decision

def batch_process(apps: list) -> list:
    results = []
    for app in apps:
        results.append(process_application(app))
    return results

 