from core.config import SEARCH_CONFIG, get_tabular_index_config
from core.common import standardize_vector_results, dedupe_results, format_results_for_ranking
from core.prompts import get_enhancement_prompt, get_ranking_prompt


# ===== QUERY ENHANCEMENT METHODS =====
struct EnhanceQuery:
    refined_query: str
    most_weighted_keyword: str
    mfr_part_num: str

struct EnhanceQueryResults:
    original_query: str
    enhanced: EnhanceQuery

def enhance_query(query: str) -> EnhanceQueryResults:
    """Extract structured information from user query using LLM"""
    prompt = get_enhancement_prompt(query)
    enhanced: EnhanceQuery = reason(prompt)
    results = EnhanceQueryResults(
        original_query=query,
        enhanced=enhanced
    )

    return results

# ===== PRODUCT SEARCH METHODS =====
def search_products(enhance_query: EnhanceQueryResults, product_data) -> list:
    """Combined search using tabular_index for both part number and vector search"""
    results = []
    enhanced_query: EnhanceQuery = enhance_query.enhanced

    # Part number search (if available)
    if enhanced_query.mfr_part_num and enhanced_query.mfr_part_num != "":
        part_results = search_by_part_number(
            enhanced_query.mfr_part_num,
            product_data,
            SEARCH_CONFIG.part_search_limit
        )
        results.extend(part_results)

    # Vector similarity search
    search_query = build_search_query(enhanced_query)
    vector_results = product_data.retrieve(
        search_query,
        top_k=SEARCH_CONFIG.vector_search_limit
    )
    results.extend(standardize_vector_results(vector_results))

    return dedupe_results(results, SEARCH_CONFIG.max_results)

def search_by_part_number(part_num: str, product_data, limit: int) -> list:
    """Search for exact part number matches using tabular_index filtering"""
    # Use retrieve with the part number as query to find matches
    matches = product_data.retrieve(part_num, top_k=limit)
    return standardize_vector_results(matches)

def build_search_query(enhanced_query: EnhanceQuery) -> str:
    """Build search query from enhanced_query data"""
    refined = enhanced_query.refined_query
    weighted = enhanced_query.most_weighted_keyword

    if SEARCH_CONFIG.use_weighted_terms and weighted != "":
        return f"{refined} {weighted}"
    return refined

# ===== RESULT RANKING METHODS =====
struct Ranking:
    item_index: int
    confidence_score: float
    notes: str

def rank_results(query: str, results: list) -> RankResults:
    """Intelligent ranking using LLM to select best match"""
    if not results:
        return {
            "query": query,
            "best_match": null,
            "total_results": 0,
            "confidence": 0.0,
            "meets_threshold": false,
            "reasoning": "No results found"
        }

    formatted = format_results_for_ranking(results)
    prompt = get_ranking_prompt(query, formatted)

    ranking: Ranking = reason(prompt)

    # Validate confidence against threshold
    confidence = ranking.confidence_score
    meets_threshold = confidence >= SEARCH_CONFIG.confidence_threshold

    best_match = null
    if meets_threshold and ranking.item_index > 0:
        best_match = results[ranking.item_index - 1]

    return {
        "query": query,
        "results": results,
        "best_match": best_match,
        "total_results": len(results),
        "confidence": confidence,
        "meets_threshold": meets_threshold,
        "reasoning": ranking.notes
    }
