# Nested Structs and Composition - Complex Data Modeling
# ======================================================
# PURPOSE: Show how to model complex data relationships using nested structs
# AUDIENCE: Developers familiar with complex object hierarchies
# LEARNING: Struct composition, nested data access, complex business logic
# ======================================================

log("=== Nested Structs and Composition Example ===")

# NESTED STRUCT DEFINITIONS
# =========================
# Model a complex business domain: Company with employees and projects

# Basic building blocks
struct Address:
    street: str
    city: str
    state: str
    zip_code: str
    country: str

struct Contact:
    email: str
    phone: str
    address: Address

struct Employee:
    employee_id: str
    name: str
    title: str
    department: str
    salary: float
    contact: Contact
    skills: list
    active: bool

struct Project:
    project_id: str
    name: str
    description: str
    budget: float
    start_date: str
    end_date: str
    status: str
    assigned_employees: list  # List of employee IDs
    client_contact: Contact

struct Company:
    company_id: str
    name: str
    headquarters: Address
    employees: list       # List of Employee structs
    projects: list        # List of Project structs
    total_revenue: float

# CONSTRUCTOR FUNCTIONS FOR NESTED STRUCTS
# ========================================

def create_address(street: str, city: str, state: str, zip_code: str, country: str = "USA") -> Address:
    """Create an address with validation"""
    return Address(
        street=street,
        city=city,
        state=state,
        zip_code=zip_code,
        country=country
    )

def create_contact(email: str, phone: str, address: Address) -> Contact:
    """Create contact information"""
    return Contact(
        email=email,
        phone=phone,
        address=address
    )

def create_employee(employee_id: str, name: str, title: str, department: str, salary: float, contact: Contact) -> Employee:
    """Create an employee with default values"""
    return Employee(
        employee_id=employee_id,
        name=name,
        title=title,
        department=department,
        salary=salary,
        contact=contact,
        skills=[],
        active=true
    )

def create_project(project_id: str, name: str, description: str, budget: float, start_date: str, client_contact: Contact) -> Project:
    """Create a new project"""
    return Project(
        project_id=project_id,
        name=name,
        description=description,
        budget=budget,
        start_date=start_date,
        end_date="TBD",
        status="Planning",
        assigned_employees=[],
        client_contact=client_contact
    )

def create_company(company_id: str, name: str, headquarters: Address) -> Company:
    """Create a new company"""
    return Company(
        company_id=company_id,
        name=name,
        headquarters=headquarters,
        employees=[],
        projects=[],
        total_revenue=0.0
    )

# FUNCTIONS FOR WORKING WITH NESTED STRUCTURES
# ============================================

def add_employee_to_company(company: Company, employee: Employee) -> Company:
    """Add an employee to the company"""
    company.employees.append(employee)
    log(f"Added employee {employee.name} to {company.name}")
    return company

def add_project_to_company(company: Company, project: Project) -> Company:
    """Add a project to the company"""
    company.projects.append(project)
    log(f"Added project {project.name} to {company.name}")
    return company

def assign_employee_to_project(company: Company, project_id: str, employee_id: str) -> Company:
    """Assign an employee to a project"""
    # Find the project
    for project in company.projects:
        if project.project_id == project_id:
            if employee_id not in project.assigned_employees:
                project.assigned_employees.append(employee_id)
                log(f"Assigned employee {employee_id} to project {project.name}")
            else:
                log(f"Employee {employee_id} already assigned to project {project.name}")
            break
    return company

def get_employee_by_id(company: Company, employee_id: str) -> Employee:
    """Find an employee by ID"""
    for employee in company.employees:
        if employee.employee_id == employee_id:
            return employee
    log(f"Employee {employee_id} not found", "error")
    return null

def get_project_by_id(company: Company, project_id: str) -> Project:
    """Find a project by ID"""
    for project in company.projects:
        if project.project_id == project_id:
            return project
    log(f"Project {project_id} not found", "error")
    return null

def calculate_department_payroll(company: Company, department: str) -> float:
    """Calculate total payroll for a department"""
    total = 0.0
    for employee in company.employees:
        if employee.department == department and employee.active:
            total = total + employee.salary
    return total

def get_project_team_info(company: Company, project_id: str) -> dict:
    """Get detailed information about a project team"""
    project = get_project_by_id(company, project_id)
    if project == null:
        return {"error": "Project not found"}
    
    team_info = {
        "project_name": project.name,
        "budget": project.budget,
        "status": project.status,
        "team_members": [],
        "total_team_salary": 0.0
    }
    
    for employee_id in project.assigned_employees:
        employee = get_employee_by_id(company, employee_id)
        if employee != null:
            member_info = {
                "name": employee.name,
                "title": employee.title,
                "department": employee.department,
                "email": employee.contact.email
            }
            team_info["team_members"].append(member_info)
            team_info["total_team_salary"] = team_info["total_team_salary"] + employee.salary
    
    return team_info

def get_company_summary(company: Company) -> dict:
    """Generate a comprehensive company summary"""
    active_employees = 0
    total_payroll = 0.0
    departments = []
    
    for employee in company.employees:
        if employee.active:
            active_employees = active_employees + 1
            total_payroll = total_payroll + employee.salary
            if employee.department not in departments:
                departments.append(employee.department)
    
    active_projects = 0
    total_project_budget = 0.0
    
    for project in company.projects:
        if project.status != "Completed":
            active_projects = active_projects + 1
            total_project_budget = total_project_budget + project.budget
    
    return {
        "company_name": company.name,
        "headquarters": f"{company.headquarters.city}, {company.headquarters.state}",
        "active_employees": active_employees,
        "departments": departments,
        "total_payroll": total_payroll,
        "active_projects": active_projects,
        "total_project_budget": total_project_budget,
        "total_revenue": company.total_revenue
    }

# USAGE EXAMPLES
# ==============
log("Building a complex company structure...")

# Create company headquarters
hq_address = create_address("123 Tech Street", "San Francisco", "CA", "94105")

# Create the company
tech_corp = create_company("TC001", "TechCorp Industries", hq_address)

# Create employee addresses and contacts
alice_address = create_address("456 Oak Ave", "San Francisco", "CA", "94103")
alice_contact = create_contact("alice@techcorp.com", "+1-555-0123", alice_address)

bob_address = create_address("789 Pine St", "Oakland", "CA", "94607")
bob_contact = create_contact("bob@techcorp.com", "+1-555-0124", bob_address)

charlie_address = create_address("321 Elm Dr", "Berkeley", "CA", "94704")
charlie_contact = create_contact("charlie@techcorp.com", "+1-555-0125", charlie_address)

# Create employees
alice = create_employee("EMP001", "Alice Johnson", "Senior Developer", "Engineering", 120000.0, alice_contact)
bob = create_employee("EMP002", "Bob Smith", "Project Manager", "Management", 110000.0, bob_contact)
charlie = create_employee("EMP003", "Charlie Brown", "UX Designer", "Design", 95000.0, charlie_contact)

# Add employees to company
tech_corp = add_employee_to_company(tech_corp, alice)
tech_corp = add_employee_to_company(tech_corp, bob)
tech_corp = add_employee_to_company(tech_corp, charlie)

# Create client contact for projects
client_address = create_address("999 Business Blvd", "Los Angeles", "CA", "90210")
client_contact = create_contact("client@bigcorp.com", "+1-555-9999", client_address)

# Create projects
mobile_app = create_project("PRJ001", "Mobile App Development", "iOS and Android app for client", 250000.0, "2024-01-15", client_contact)
website = create_project("PRJ002", "Website Redesign", "Complete website overhaul", 150000.0, "2024-03-01", client_contact)

# Add projects to company
tech_corp = add_project_to_company(tech_corp, mobile_app)
tech_corp = add_project_to_company(tech_corp, website)

# Assign employees to projects
tech_corp = assign_employee_to_project(tech_corp, "PRJ001", "EMP001")  # Alice to mobile app
tech_corp = assign_employee_to_project(tech_corp, "PRJ001", "EMP002")  # Bob to mobile app
tech_corp = assign_employee_to_project(tech_corp, "PRJ002", "EMP001")  # Alice to website
tech_corp = assign_employee_to_project(tech_corp, "PRJ002", "EMP003")  # Charlie to website

# DEMONSTRATE NESTED DATA ACCESS
# ==============================
log("\n=== Accessing Nested Data ===")

# Access deeply nested information
alice_emp = get_employee_by_id(tech_corp, "EMP001")
if alice_emp != null:
    log(f"Employee: {alice_emp.name}")
    log(f"Email: {alice_emp.contact.email}")
    log(f"City: {alice_emp.contact.address.city}")
    log(f"Department: {alice_emp.department}")

# COMPLEX BUSINESS LOGIC
# =====================
log("\n=== Complex Business Calculations ===")

# Department payroll
eng_payroll = calculate_department_payroll(tech_corp, "Engineering")
mgmt_payroll = calculate_department_payroll(tech_corp, "Management")
design_payroll = calculate_department_payroll(tech_corp, "Design")

log(f"Engineering payroll: ${eng_payroll}")
log(f"Management payroll: ${mgmt_payroll}")
log(f"Design payroll: ${design_payroll}")

# Project team information
mobile_team = get_project_team_info(tech_corp, "PRJ001")
website_team = get_project_team_info(tech_corp, "PRJ002")

log(f"\nMobile App Project Team:")
log(f"  Budget: ${mobile_team['budget']}")
log(f"  Team Size: {len(mobile_team['team_members'])}")
log(f"  Team Payroll: ${mobile_team['total_team_salary']}")

log(f"\nWebsite Project Team:")
log(f"  Budget: ${website_team['budget']}")
log(f"  Team Size: {len(website_team['team_members'])}")
log(f"  Team Payroll: ${website_team['total_team_salary']}")

# Company-wide summary
summary = get_company_summary(tech_corp)
log(f"\n=== Company Summary ===")
log(f"Company: {summary['company_name']}")
log(f"Location: {summary['headquarters']}")
log(f"Active Employees: {summary['active_employees']}")
log(f"Departments: {summary['departments']}")
log(f"Total Payroll: ${summary['total_payroll']}")
log(f"Active Projects: {summary['active_projects']}")
log(f"Project Budget: ${summary['total_project_budget']}")

# KEY ADVANTAGES OF STRUCT COMPOSITION:
# ====================================
log("\n=== Advantages of Struct Composition ===")
log("✅ Clear data structure: No hidden state or behavior")
log("✅ Composable: Build complex models from simple parts")
log("✅ Flexible: Add new functions without modifying structs")
log("✅ Explicit relationships: No complex inheritance to understand")
log("✅ Testable: Each function can be unit tested independently")
log("✅ Maintainable: Easy to understand and modify business logic")

log("=== Nested Structs Example Complete ===")