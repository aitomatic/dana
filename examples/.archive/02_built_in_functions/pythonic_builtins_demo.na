# Pythonic Built-in Functions Demo
# This example demonstrates the new Pythonic built-in functions available in Dana
# These functions provide familiar Python-like functionality for common operations

log_level("debug")

log("=== Pythonic Built-in Functions Demo ===", "error")

# Sample data for demonstrations
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
scores = [85, 92, 78, 96, 88, 91, 83, 89]
mixed_data = [1, 2.5, 3, 4.7, 5]
text_data = ["apple", "banana", "cherry", "date"]
boolean_data = [true, false, true, true, false]

log("\n--- Collection Functions ---", "error")

# len() - Get length of collections
num_count = len(numbers)
score_count = len(scores)
text_count = len(text_data)
log(f"Numbers count: {num_count}")
log(f"Scores count: {score_count}")
log(f"Text items count: {text_count}")

# sum() - Sum numeric collections
total = sum(numbers)
score_total = sum(scores)
log(f"Sum of numbers 1-10: {total}", "error")
log(f"Total of all scores: {score_total}", "error")

# max() and min() - Find extremes
highest_score = max(scores)
lowest_score = min(scores)
max_number = max(numbers)
min_number = min(numbers)
log(f"Highest score: {highest_score}", "error")
log(f"Lowest score: {lowest_score}", "error")
log(f"Max number: {max_number}", "error")
log(f"Min number: {min_number}", "error")

log("\n--- Mathematical Functions ---", "error")

# abs() - Absolute value
negative_value = -42
positive_value = abs(negative_value)
log(f"Absolute value of {negative_value}: {positive_value}", "error")

# round() - Round numbers
pi_approx = 3.14159
rounded_pi = round(pi_approx)
rounded_pi_2 = round(pi_approx, 2)
log(f"Pi rounded: {rounded_pi}", "error")
log(f"Pi rounded to 2 places: {rounded_pi_2}", "error")

log("\n--- Type Conversion Functions ---", "error")

# int() - Convert to integer
string_number = "42"
float_number = 3.14
bool_number = true
int_from_string = int(string_number)
int_from_float = int(float_number)
int_from_bool = int(bool_number)
log(f"String '42' to int: {int_from_string}", "error")
log(f"Float 3.14 to int: {int_from_float}", "error")
log(f"Bool true to int: {int_from_bool}", "error")

# float() - Convert to float
int_value = 42
string_float = "3.14"
float_from_int = float(int_value)
float_from_string = float(string_float)
log(f"Int 42 to float: {float_from_int}", "error")
log(f"String '3.14' to float: {float_from_string}", "error")

# bool() - Convert to boolean
empty_string = ""
non_empty_string = "hello"
zero_value = 0
non_zero_value = 5
bool_from_empty = bool(empty_string)
bool_from_string = bool(non_empty_string)
bool_from_zero = bool(zero_value)
bool_from_number = bool(non_zero_value)
log(f"Empty string to bool: {bool_from_empty}", "error")
log(f"'hello' to bool: {bool_from_string}", "error")
log(f"Zero to bool: {bool_from_zero}", "error")
log(f"5 to bool: {bool_from_number}", "error")

log("\n--- Collection Processing Functions ---", "error")

# sorted() - Sort collections
unsorted_scores = [92, 78, 96, 85, 88]
sorted_scores = sorted(unsorted_scores)
log(f"Original scores: {unsorted_scores}", "error")
log(f"Sorted scores: {sorted_scores}", "error")

# all() and any() - Boolean logic on collections
all_true = [true, true, true]
some_true = [true, false, true]
all_false = [false, false, false]
all_result = all(all_true)
some_result = any(some_true)
none_result = any(all_false)
log(f"All true values: {all_result}", "error")
log(f"Any true in mixed: {some_result}", "error")
log(f"Any true in all false: {none_result}", "error")

log("\n--- Range Function ---", "error")

# range() - Generate sequences
small_range = range(5)
custom_range = range(2, 8)
step_range = range(0, 10, 2)
log(f"Range 5: {small_range}", "error")
log(f"Range 2 to 8: {custom_range}", "error")
log(f"Range 0 to 10 step 2: {step_range}", "error")

log("\n--- Practical Examples ---", "error")

# Calculate statistics
average_score = sum(scores) / len(scores)
score_range = max(scores) - min(scores)
log(f"Average score: {average_score}", "error")
log(f"Score range: {score_range}", "error")

# Data validation
# valid_scores = all([score >= 0 for score in scores])
# has_perfect_score = any([score >= 95 for score in scores])
# log(f"All scores valid (>= 0): {valid_scores}")
# log(f"Has perfect score (>= 95): {has_perfect_score}")

# Type conversion pipeline
string_numbers = ["1", "2", "3", "4", "5"]
# converted_numbers = [int(s) for s in string_numbers]
# total_converted = sum(converted_numbers)
log(f"String numbers: {string_numbers}", "error")
# log(f"Converted to ints: {converted_numbers}")
# log(f"Sum of converted: {total_converted}")

log("\n--- Advanced Usage ---", "error")

# Combining functions for data analysis
def analyze_dataset(data):
    count = len(data)
    total = sum(data)
    average = total / count
    maximum = max(data)
    minimum = min(data)
    sorted_data = sorted(data)
    
    return {
        "count": count,
        "sum": total,
        "average": average,
        "max": maximum,
        "min": minimum,
        "sorted": sorted_data
    }

# Analyze our score data
analysis = analyze_dataset(scores)
log(f"Dataset analysis: {analysis}", "error")

# Grade classification using built-ins
# def classify_grades(scores):
#     excellent = [score for score in scores if score >= 90]
#     good = [score for score in scores if score >= 80 and score < 90]
#     needs_improvement = [score for score in scores if score < 80]
#    
#     return {
#         "excellent_count": len(excellent),
#         "good_count": len(good),
#         "needs_improvement_count": len(needs_improvement),
#         "excellent_avg": sum(excellent) / len(excellent) if len(excellent) > 0 else 0,
#         "overall_avg": sum(scores) / len(scores)
#     }
#
# grade_analysis = classify_grades(scores)
# log(f"Grade classification: {grade_analysis}")

log("\n=== Demo Complete ===", "error")
log("All Pythonic built-in functions demonstrated successfully!", "error") 