# Test: Collections Indexing and Operations
# Purpose: Test list indexing, dictionary access, set operations, tuple operations, and collection slicing
# Category: Basic Syntax - Collections and Indexing

log("Starting Collections Indexing and Operations test")

# Test 1: List indexing - positive indices
numbers = [1, 2, 3, 4, 5]
assert numbers[0] == 1, f"Expected 1, got {numbers[0]}"
assert numbers[2] == 3, f"Expected 3, got {numbers[2]}"
assert numbers[4] == 5, f"Expected 5, got {numbers[4]}"
log("✅ List indexing with positive indices works")

# Test 2: List indexing - negative indices
assert numbers[-1] == 5, f"Expected 5, got {numbers[-1]}"
assert numbers[-3] == 3, f"Expected 3, got {numbers[-3]}"
assert numbers[-5] == 1, f"Expected 1, got {numbers[-5]}"
log("✅ List indexing with negative indices works")

# Test 3: List slicing - basic
sliced = numbers[1:4]
assert sliced == [2, 3, 4], f"Expected [2, 3, 4], got {sliced}"
log("✅ Basic list slicing works")

# Test 4: List slicing - with step
stepped = numbers[0:5:2]
assert stepped == [1, 3, 5], f"Expected [1, 3, 5], got {stepped}"
log("✅ List slicing with step works")

# Test 5: List slicing - negative step
reverse = numbers[::-1]
assert reverse == [5, 4, 3, 2, 1], f"Expected [5, 4, 3, 2, 1], got {reverse}"
log("✅ List slicing with negative step works")

# Test 6: List slicing - negative indices
negative_slice = numbers[-4:-1]
assert negative_slice == [2, 3, 4], f"Expected [2, 3, 4], got {negative_slice}"
log("✅ List slicing with negative indices works")

# Test 7: List slicing - edge cases
empty_slice = numbers[3:1]
assert empty_slice == [], f"Expected [], got {empty_slice}"
log("✅ List slicing edge cases work")

# Test 8: Dictionary key access
scores = {"alice": 100, "bob": 80, "charlie": 90}
assert scores["alice"] == 100, f"Expected 100, got {scores['alice']}"
assert scores["bob"] == 80, f"Expected 80, got {scores['bob']}"
log("✅ Dictionary key access works")

# Test 9: Dictionary methods
keys = list(scores.keys())
values = list(scores.values())
items = list(scores.items())
assert len(keys) == 3, f"Expected 3, got {len(keys)}"
assert len(values) == 3, f"Expected 3, got {len(values)}"
assert len(items) == 3, f"Expected 3, got {len(items)}"
log("✅ Dictionary methods work")

# Test 10: Dictionary get method
alice_score = scores.get("alice", 0)
dave_score = scores.get("dave", 0)
assert alice_score == 100, f"Expected 100, got {alice_score}"
assert dave_score == 0, f"Expected 0, got {dave_score}"
log("✅ Dictionary get method works")

# Test 11: Set operations - basic - [NOT SUPPORTED YET]
set1 = {1, 2, 3, 4, 5}
set2 = {4, 5, 6, 7, 8}
# union = set1 | set2
# intersection = set1 & set2
# difference = set1 - set2
# assert len(union) == 8, f"Expected 8, got {len(union)}"
# assert len(intersection) == 2, f"Expected 2, got {len(intersection)}"
# assert len(difference) == 3, f"Expected 3, got {len(difference)}"
# log("✅ Basic set operations work")

# Test 12: Set methods
set1.add(6)
set1.remove(1)
assert 6 in set1, f"Expected 6 in set, got {6 in set1}"
assert 1 not in set1, f"Expected 1 not in set, got {1 in set1}"
log("✅ Set methods work")

# Test 13: Tuple operations - indexing
coordinates = (10, 20, 30)
assert coordinates[0] == 10, f"Expected 10, got {coordinates[0]}"
assert coordinates[-1] == 30, f"Expected 30, got {coordinates[-1]}"
log("✅ Tuple indexing works")

# Test 14: Tuple operations - slicing
tuple_slice = coordinates[1:3]
assert tuple_slice == (20, 30), f"Expected (20, 30), got {tuple_slice}"
log("✅ Tuple slicing works")

# # Test 15: Tuple unpacking
# x, y, z = coordinates
# assert x == 10, f"Expected 10, got {x}"
# assert y == 20, f"Expected 20, got {y}"
# assert z == 30, f"Expected 30, got {z}"
# log("✅ Tuple unpacking works")

# # Test 16: Tuple unpacking with rest - [NOT SUPPORTED YET]
# first, *rest = coordinates
# assert first == 10, f"Expected 10, got {first}"
# assert rest == [20, 30], f"Expected [20, 30], got {rest}"
# log("✅ Tuple unpacking with rest works")

# Test 17: Advanced list slicing - step with negative indices
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
slice1 = numbers[-6:-1:2]
assert slice1 == [4, 6, 8], f"Expected [4, 6, 8], got {slice1}"
log("✅ Advanced list slicing with step and negative indices works")

# Test 18: Advanced list slicing - all negative
slice2 = numbers[-1:-6:-1]
assert slice2 == [9, 8, 7, 6, 5], f"Expected [9, 8, 7, 6, 5], got {slice2}"
log("✅ Advanced list slicing with all negative indices works")

# Test 19: Collection slicing - nested lists
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
row_slice = matrix[1:3]
assert row_slice == [[4, 5, 6], [7, 8, 9]], f"Expected [[4, 5, 6], [7, 8, 9]], got {row_slice}"
log("✅ Collection slicing with nested lists works")

# Test 20: Collection slicing - nested dictionaries
nested = {"level1": {"level2": {"level3": "value"}}}
level2 = nested["level1"]
level3 = level2["level2"]
assert level3["level3"] == "value", f"Expected 'value', got {level3['level3']}"
log("✅ Collection slicing with nested dictionaries works")

# Test 21: List comprehension with indexing
squares = [x**2 for x in range(5)]
assert squares[0] == 0, f"Expected 0, got {squares[0]}"
assert squares[2] == 4, f"Expected 4, got {squares[2]}"
log("✅ List comprehension with indexing works")

# Test 22: Dictionary comprehension with access
word_lengths = {(word: len(word)) for word in ["hello", "world", "python"]}
assert word_lengths["hello"] == 5, f"Expected 5, got {word_lengths['hello']}"
assert word_lengths["python"] == 6, f"Expected 6, got {word_lengths['python']}"
log("✅ Dictionary comprehension with access works")

# Test 23: Set comprehension with operations
unique_lengths = {len(word) for word in ["hello", "world", "python", "hello"]}
assert len(unique_lengths) == 2, f"Expected 2, got {len(unique_lengths)}"
assert 5 in unique_lengths, f"Expected 5 in set, got {5 in unique_lengths}"
log("✅ Set comprehension with operations works")

# Test 24: Tuple unpacking in loops
pairs = [(1, "one"), (2, "two"), (3, "three")]
numbers = []
words = []
for num, word in pairs:
    numbers.append(num)
    words.append(word)
assert numbers == [1, 2, 3], f"Expected [1, 2, 3], got {numbers}"
assert words == ["one", "two", "three"], f"Expected ['one', 'two', 'three'], got {words}"
log("✅ Tuple unpacking in loops works")

# Test 25: Advanced slicing with expressions
data = list(range(20))
step = 3
start = 2
end = 15
sliced_data = data[start:end:step]
assert len(sliced_data) == 5, f"Expected 5, got {len(sliced_data)}"
assert sliced_data[0] == 2, f"Expected 2, got {sliced_data[0]}"
log("✅ Advanced slicing with expressions works")

# Test 26: Collection indexing with function calls
def get_index():
    return 2

def get_value():
    return 42

numbers = [10, 20, 30, 40, 50]
index = get_index()
value = get_value()
numbers[index] = value
assert numbers[index] == value, f"Expected {value}, got {numbers[index]}"
log("✅ Collection indexing with function calls works")

# Test 27: Dictionary access with computed keys
base_key = "user"
user_id = 123
full_key = f"{base_key}_{user_id}"
data = {full_key: "John Doe"}
assert data[full_key] == "John Doe", f"Expected 'John Doe', got {data[full_key]}"
log("✅ Dictionary access with computed keys works")

# # Test 28: Set operations with multiple sets - [NOT SUPPORTED YET]
# set1 = {1, 2, 3}
# set2 = {3, 4, 5}
# set3 = {5, 6, 7}
# union_all = set1 | set2 | set3
# intersection_all = set1 & set2 & set3
# assert len(union_all) == 7, f"Expected 7, got {len(union_all)}"
# assert len(intersection_all) == 0, f"Expected 0, got {len(intersection_all)}"
# log("✅ Set operations with multiple sets work")

# Test 29: Tuple operations with mixed types
mixed_tuple = (1, "hello", 3.14, True, [1, 2, 3])
assert mixed_tuple[1] == "hello", f"Expected 'hello', got {mixed_tuple[1]}"
assert mixed_tuple[3] == True, f"Expected True, got {mixed_tuple[3]}"
assert len(mixed_tuple[4]) == 3, f"Expected 3, got {len(mixed_tuple[4])}"
log("✅ Tuple operations with mixed types work")

# Test 30: Collection slicing out of bounds - [NOT SUPPORTED YET]
# empty_list = []
# empty_slice = empty_list[0:0]
# assert empty_slice == [], f"Expected [], got {empty_slice}"

# out_of_bounds = numbers[100:200]
# assert out_of_bounds == [], f"Expected [], got {out_of_bounds}"
# log("✅ Collection slicing edge cases work")

log("Collections Indexing and Operations test completed successfully") 