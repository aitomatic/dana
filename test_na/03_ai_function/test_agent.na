# Test: Agent System Integration
# Purpose: Comprehensive test of Dana's agent system features including:
#   - Agent blueprints (reusable type definitions)
#   - Singleton agents (named instances)
#   - Memory operations with context
#   - Built-in AI methods (plan, solve, chat)
#   - Method overriding
#   - Agent templates (pre-built patterns)
#   - Cross-agent communication
# Category: Integration - Agent System
# Reference: See docs/primers/agent.md for detailed agent system documentation

log("Starting Agent System Integration test")

# Test setup - define core test agent blueprints
log("Setting up core test agent blueprints...")

agent_blueprint TestAgent:
    name: str = "test_agent"
    domain: str = "testing"
    expertise: str = "intermediate"
    active: bool = true
    memory_capacity: int = 1000

agent_blueprint CommunicationAgent:
    name: str = "comm_agent"
    role: str = "general"
    communication_log: list[dict] = []
    languages: list[str] = ["english"]

agent_blueprint PoolMember:
    id: str = "member"
    pool_id: str = "default_pool"
    status: str = "idle"
    workload: int = 0
    capabilities: list[str] = []

agent_blueprint PoolManager:
    name: str = "pool_manager"
    managed_pools: list[str] = []
    pool_registry: dict = {}
    load_balancing: bool = true

log("✓ Core test agents defined")

# Test 1: Agent Definition and Instantiation
log("Test 1: Agent Definition and Instantiation")

# Test basic agent creation - singleton agents
agent Agent1(TestAgent):
    name = "agent_1"
    domain = "manufacturing"
    expertise = "senior"

agent Agent2(TestAgent):
    name = "agent_2"
    domain = "quality"
    expertise = "expert"

assert Agent1.name == "agent_1", "Agent name should be set correctly"
assert Agent2.domain == "quality", "Agent domain should be set correctly"
assert Agent1.active == true, "Agent should be active by default"
log("✓ Basic agent instantiation working")

# Test default values with blueprint instantiation
default_agent = TestAgent()
assert default_agent.name == "test_agent", "Default name should be used"
assert default_agent.domain == "testing", "Default domain should be used"
log("✓ Default values working")

# Test minimal base agent
agent SimpleAgent
assert SimpleAgent is not null, "Minimal base agent should be created"
log("✓ Minimal base agent working")


# Test 2: Agent Memory and Conversation Operations
log("Test 2: Agent Memory and Conversation Operations")

# Create test agents
agent MemoryAgent1(TestAgent):
    name = "memory_test_1"
    domain = "testing"

agent MemoryAgent2(TestAgent):
    name = "memory_test_2"
    domain = "testing"

# Test structured memory storage and retrieval
MemoryAgent1.remember("config", {
    "preferences": {
        "language": "english",
        "notifications": true
    },
    "history": ["action1", "action2"]
})

MemoryAgent1.remember("metrics", {
    "accuracy": 0.95,
    "response_time": 200
})

config = MemoryAgent1.recall("config")
metrics = MemoryAgent1.recall("metrics")

assert config["preferences"]["language"] == "english", "Nested config should be retrieved"
assert metrics["accuracy"] == 0.95, "Metrics should be retrieved"
log("✓ Structured memory operations working")

# Test memory persistence with context
MemoryAgent1.plan("Test persistence", {"priority": "high"})
MemoryAgent1.solve("Test persistence", {"mode": "thorough"})

assert MemoryAgent1.recall("config")["preferences"]["language"] == "english", "Memory should persist after operations with context"
log("✓ Memory persistence with context working")

# Test memory isolation and conversation history
MemoryAgent1.remember("conversation_history", [
    {"role": "user", "content": "Hello"},
    {"role": "agent", "content": "Hi there!"}
])

MemoryAgent2.remember("conversation_history", [
    {"role": "user", "content": "Different conversation"},
    {"role": "agent", "content": "Different response"}
])

history1 = MemoryAgent1.recall("conversation_history")
history2 = MemoryAgent2.recall("conversation_history")

assert history1[0]["content"] == "Hello", "Agent 1 should have its own conversation history"
assert history2[0]["content"] == "Different conversation", "Agent 2 should have its own conversation history"
log("✓ Memory isolation and conversation history working")

# Test conversation with context management
response1 = MemoryAgent1.chat(
    "Let's discuss the test results",
    context={"metrics": metrics},
    max_context_turns=3
)

response2 = MemoryAgent1.chat(
    "What was the accuracy?",
    context={"previous_metrics": metrics},
    max_context_turns=3
)

assert response1 is not null, "Chat with context should work"
assert response2 is not null, "Follow-up chat should work"
log("✓ Contextual conversation working")

# Test 3: Agent Built-in Methods and Method Overriding
log("Test 3: Agent Built-in Methods and Method Overriding")

# Define custom method overrides
def (test_agent: TestAgent) plan(task: str) -> list[str]:
    steps = []
    if test_agent.domain == "manufacturing":
        steps.append("1. Analyze production line")
        steps.append("2. Identify bottlenecks")
    elif test_agent.domain == "quality":
        steps.append("1. Review quality metrics")
        steps.append("2. Check defect rates")
    
    if test_agent.expertise == "senior" or test_agent.expertise == "expert":
        steps.append("3. Senior review and approval")
    
    return steps

# Test custom method override
custom_plan = Agent1.plan("Optimize workflow")  # Agent1 is manufacturing/senior
assert len(custom_plan) == 3, "Custom plan should have 3 steps for senior manufacturing agent"
assert custom_plan[0] == "1. Analyze production line", "Custom plan should use manufacturing steps"
assert custom_plan[2] == "3. Senior review and approval", "Custom plan should include senior review"
log("✓ Custom method override working")

# Test built-in methods with context
plan_result = Agent2.plan("Optimize quality checks", {"batch_size": 1000, "defect_rate": 0.05})
assert plan_result is not null, "Plan method with context should return result"
log("✓ Plan method with context working")

solve_result = Agent2.solve("High defect rate", {"severity": "high", "affected_batches": 3})
assert solve_result is not null, "Solve method with context should return result"
log("✓ Solve method with context working")

# # Test 11: Agent Templates and Advanced Features - [NOT SUPPORTED YET]
# log("Test 11: Agent Templates and Advanced Features")

# # Import agent templates
# import agent_templates

# # Test customer service agent template
# cs_agent = agent_from_template(
#     "customer_service",
#     domain="billing",
#     response_style="friendly",
#     languages=["english", "spanish"]
# )

# assert cs_agent.domain == "billing", "Template agent should have correct domain"
# assert "spanish" in cs_agent.languages, "Template agent should support specified languages"
# log("✓ Customer service template working")

# # Test technical support agent template
# tech_agent = agent_from_template(
#     "technical_support",
#     expertise="networking",
#     troubleshooting_level="advanced",
#     tools=["diagnostics", "monitoring"]
# )

# assert tech_agent.expertise == "networking", "Template agent should have correct expertise"
# assert tech_agent.troubleshooting_level == "advanced", "Template agent should have correct level"
# log("✓ Technical support template working")

# # Test data analyst template
# data_agent = agent_from_template(
#     "data_analyst",
#     specialization="financial",
#     visualization_tools=["matplotlib", "plotly"]
# )

# assert data_agent.specialization == "financial", "Template agent should have correct specialization"
# assert "plotly" in data_agent.visualization_tools, "Template agent should have specified tools"
# log("✓ Data analyst template working")


# Notes for developers
log("")
log("NOTES:")
log("- Agent system provides comprehensive functionality for AI-powered applications")
log("- Memory operations are persistent and isolated between agent instances")
log("- Built-in methods (plan, solve, remember, recall, chat) support context parameters")
log("- Agent blueprints enable reusable agent type definitions")
log("- Singleton agents provide named instances with custom overrides")
log("- Method overriding allows custom behavior while maintaining AI capabilities")
# log("- Agent templates offer pre-built patterns for common use cases")
log("- The system supports both simple and complex multi-agent scenarios")
