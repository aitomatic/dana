<p align="center">
  <img src="https://cdn.prod.website-files.com/62a10970901ba826988ed5aa/62d942adcae82825089dabdb_aitomatic-logo-black.png" alt="Aitomatic Logo" width="400" style="border: 2px solid #666; border-radius: 10px; padding: 20px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);"/>
</p>

# DANA (Domain-Aware NeuroSymbolic Architecture)

## ðŸ§­ Vision

DANA is a universal program format and execution runtime that enables intelligent agents â€” human or machine â€” to reason, act, and collaborate through structured, interpretable programs.

It serves as the missing link between natural language objectives and tool-assisted, stateful action. DANA programs are concise, auditable, explainable, and can be authored by LLMs, domain experts, or both.

---

## ðŸ’¡ Motivation & Problem

Modern AI systems struggle with:

* âœ–ï¸ **Prompt chains are fragile** â€” hard to debug, hard to maintain
* âœ–ï¸ **Plans are opaque** â€” impossible to inspect or explain mid-flight
* âœ–ï¸ **Tool use is scattered** â€” logic is buried in code, not declarative programs
* âœ–ï¸ **State is implicit** â€” no shared memory model or traceable updates

Symbolic systems offer structure but lack adaptability. LLMs offer creativity but lack transparency. DANA bridges the two.

---

## âœ… Solution

DANA introduces a lightweight domain-aware program language and runtime. It allows:

* ðŸ§  **Programs as first-class reasoning artifacts**
* ðŸ“¦ **Shared state containers** (`agent`, `world`, `temp`, `execution`)
* ðŸ§© **Reusable logic units** via a structured Knowledge Base (KB)
* ðŸ§¾ **Declarative goals**, **imperative execution**
* ðŸ“œ **Bidirectional mapping to/from natural language**

DANA can:

* Be generated by a planning agent (like GMA)
* Be executed line-by-line by a runtime
* Interact with tools, LLMs, and memory
* Be stored, versioned, tested, and explained

---

## ðŸ” Execution Flow (Simplified)

1. **AgentRuntime** receives an objective and instantiates a `RuntimeContext`
2. **GMA** emits a DANA program â€” either fresh or retrieved from the KB
3. **Interpreter** walks the program step by step
4. **reason(...)** calls LLMs, **use(...)** calls KB/tools, **set(...)** modifies state
5. All logic runs against an auditable shared memory model

---

## ðŸ§± State Model

DANA programs operate over a shared `RuntimeContext`, which is composed of three standard memory scopes:

| Scope      | Description                                |
| ---------- | ------------------------------------------ |
| `private:` | Private to the agent, resource, or tool itself |
| `public:`  | Openly accessible world state (time, weather, etc.) |
| `system:`  | System-related mechanical state with controlled access |

The `RuntimeContext` enforces strict scope boundaries and provides controlled access to state variables through dot notation (e.g., `private.user.name`, `public.weather.temperature`, `system.status`).

### Security Design

**The `dana.runtime` module is the primary enforcer of security during the execution of a DANA program.** It manages the `RuntimeContext` for the duration of the execution and enforces access policies based on the defined scopes and program logic.

| Security Concern            | Enforced By              | Mechanism                                      |
| --------------------------- | ------------------------ | ---------------------------------------------- |
| Scope restrictions          | `dana.runtime`           | Limits visible/writable scopes during execution |
| State mutation permissions  | `dana.runtime`           | Controlled state updates via instructions      |
| Tool/API usage validation   | `dana.runtime`           | Ensures `use` targets are valid/allowed        |
| LLM output handling         | `dana.runtime`           | Manages `reason` call results and potential errors |
| Execution logging           | `dana.runtime`           | Tracks execution steps within the DANA context |
| Resource constraints        | `dana.runtime`           | (Optional) Limits execution steps, time, memory |

```python
if world.sensor.temp > 100:
    temp.result = reason("Is this overheating?")
    if temp.result == "yes":
        execution.alerts.append("Overheat detected")
```

---

## ðŸ—‚ File Structure Overview

```text
dana/
â”œâ”€â”€ runtime/         # Core execution engine
â”‚   â”œâ”€â”€ interpreter.py    # AST visitor-based interpreter
â”‚   â”œâ”€â”€ context.py        # Runtime state management
â”‚   â”œâ”€â”€ function_registry.py  # Tool/function registration
â”‚   â”œâ”€â”€ hooks.py          # Event system for extensibility
â”‚   â””â”€â”€ repl.py          # Interactive REPL implementation
â”œâ”€â”€ language/        # Language implementation
â”‚   â”œâ”€â”€ ast.py           # Abstract Syntax Tree nodes
â”‚   â”œâ”€â”€ parser.py        # Lark-based parser
â”‚   â”œâ”€â”€ type_checker.py  # Static type checking
â”‚   â”œâ”€â”€ visitor.py       # Visitor pattern implementation
â”‚   â”œâ”€â”€ types.py         # Type system definitions
â”‚   â””â”€â”€ transformers/    # Modular AST transformers
â”‚       â”œâ”€â”€ base_transformer.py    # Common utilities
â”‚       â”œâ”€â”€ statement_transformer.py # Statement parsing
â”‚       â”œâ”€â”€ expression_transformer.py # Expression parsing
â”‚       â””â”€â”€ fstring_transformer.py  # F-string parsing
â”œâ”€â”€ transcoder/      # NL â†” Code translation
â”‚   â”œâ”€â”€ transcoder.py    # Bidirectional translation
â”‚   â”œâ”€â”€ compiler.py      # NL to DANA compilation
â”‚   â””â”€â”€ templates/       # Translation templates
â”œâ”€â”€ io/              # I/O interfaces
â”œâ”€â”€ exceptions.py    # Error handling
â””â”€â”€ __init__.py     # Public API
```

## ðŸ”§ Architecture Notes

The DANA runtime uses a robust architecture combining several design patterns:

- **Visitor Pattern**: AST nodes are traversed using dedicated visit methods, allowing clean separation of node types and operations
- **Hook System**: Extensible event system for customizing behavior at key execution points (before/after program, statements, errors)
- **Context Management**: Hierarchical state management with namespaced scopes
- **Function Registry**: Dynamic registration of tools and functions
- **Type System**: Static type checking with runtime validation
- **Logging System**: Configurable logging with color-coded levels (DEBUG, INFO, WARN, ERROR)
- **Modular Transformers**: The parser uses specialized transformer components for different language constructs, improving maintainability and extensibility

Key Features:
- Asynchronous execution support
- F-string interpolation in log messages
- Error location tracking and formatting
- Execution ID tracking for debugging
- Comprehensive error handling with custom exceptions

> **Note**: The runtime is designed to be extensible through hooks and function registration, allowing for custom behavior without modifying core code.

---

## ðŸ“¦ Public API

Designed for use inside agentic systems:

```python
from opendxa.dana import run, compile_nl, explain
from opendxa.dana.sandbox.sandbox_context import SandboxContext
from opendxa.dana.sandbox.interpreter import Interpreter

# Basic usage
program = compile_nl("If X is drifting, flag it.")
ctx = RuntimeContext(agent=..., world=..., temp={})
run(program, ctx)

# Advanced usage with custom interpreter
interpreter = Interpreter(ctx)
interpreter.set_log_level(LogLevel.DEBUG)
interpreter.execute_program(program)
```

---

## ðŸ”— Benefits

* âœ… Uniform execution across agents, tools, LLMs
* âœ… Declarative planning, imperative acting
* âœ… Human-readable and explainable
* âœ… Reusable logic and modular KB
* âœ… Plug-and-play with OpenDXA or other agent frameworks

---

## ðŸ”„ Bidirectional Layer

DANA includes tools to:

* Convert NL to structured code (`compile_nl()`)
* Translate programs back to natural language (`explain()`)

This enables:

* Domain experts to author rules in English
* Systems to explain what they're doing
* Co-creation and trust in AI workflows

---

## ðŸ§© Example Use Cases

* Semiconductor diagnostics
* Financial credit assessment
* Predictive maintenance
* Maritime risk control
* Regulatory eligibility checks

---

## ðŸ¤ Relationship to OpenDXA

* DANA is embedded within OpenDXA as the **reasoning and execution layer**
* Agents emit or receive DANA programs to carry out goals
* Tool calls and reasoning steps all route through DANA
* The KB provides reusable domain logic to DXAs and GMAs

---

## ðŸ›  Status

DANA is under active development and currently embedded inside `OpenDXA` as a module. Refactoring and extraction to an independent package is supported by clean modular structure.

> Future direction includes formal spec, test suite, and runtime service for multi-agent environments.

---

## ðŸ“£ Contribute

Want to help shape how intelligent agents reason and act? Reach out or contribute to the `dana/` module inside the OpenDXA repository.


---
<p align="center">
Copyright Â© 2025 Aitomatic, Inc. Licensed under the <a href="../LICENSE.md">MIT License</a>.
<br/>
<a href="https://aitomatic.com">https://aitomatic.com</a>
</p>
