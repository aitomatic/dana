<p align="center">
  <img src="https://cdn.prod.website-files.com/62a10970901ba826988ed5aa/62d942adcae82825089dabdb_aitomatic-logo-black.png" alt="Aitomatic Logo" width="400" style="border: 2px solid #666; border-radius: 10px; padding: 20px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);"/>
</p>

# DANA (Domain-Aware NeuroSymbolic Architecture)

## 🧭 Vision

DANA is a universal program format and execution runtime that enables intelligent agents — human or machine — to reason, act, and collaborate through structured, interpretable programs.

It serves as the missing link between natural language objectives and tool-assisted, stateful action. DANA programs are concise, auditable, explainable, and can be authored by LLMs, domain experts, or both.

---

## 💡 Motivation & Problem

Modern AI systems struggle with:

* ✖️ **Prompt chains are fragile** — hard to debug, hard to maintain
* ✖️ **Plans are opaque** — impossible to inspect or explain mid-flight
* ✖️ **Tool use is scattered** — logic is buried in code, not declarative programs
* ✖️ **State is implicit** — no shared memory model or traceable updates

Symbolic systems offer structure but lack adaptability. LLMs offer creativity but lack transparency. DANA bridges the two.

---

## ✅ Solution

DANA introduces a lightweight domain-aware program language and runtime. It allows:

* 🧠 **Programs as first-class reasoning artifacts**
* 📦 **Shared state containers** (`agent`, `world`, `temp`, `execution`)
* 🧩 **Reusable logic units** via a structured Knowledge Base (KB)
* 🧾 **Declarative goals**, **imperative execution**
* 📜 **Bidirectional mapping to/from natural language**

DANA can:

* Be generated by a planning agent (like GMA)
* Be executed line-by-line by a runtime
* Interact with tools, LLMs, and memory
* Be stored, versioned, tested, and explained

---

## 🔁 Execution Flow (Simplified)

1. **AgentRuntime** receives an objective and instantiates a `RuntimeContext`
2. **GMA** emits a DANA program — either fresh or retrieved from the KB
3. **Interpreter** walks the program step by step
4. **reason(...)** calls LLMs, **use(...)** calls KB/tools, **set(...)** modifies state
5. All logic runs against an auditable shared memory model

---

## 🧱 State Model

DANA programs access shared memory via namespaced keys:

* `agent:` — beliefs, identity, preferences
* `world:` — sensed external state
* `execution:` — goals, status, logs
* `temp:` — ephemeral local memory

```python
if world.sensor.temp > 100:
    temp.result = reason("Is this overheating?")
    if temp.result == "yes":
        execution.alerts.append("Overheat detected")
```

---

## 🗂 File Structure Overview

```text
dana/
├── runtime/         # Interpreter, instructions, context
├── language/        # AST, parser, types, validation
├── kb/              # Knowledge base: entries, loader, registry
├── io/              # LLMs, tools, agent interfaces (pluggable)
├── transcoder/      # NL ↔ Code compiler/explainer
├── examples/        # Sample programs
```

## 🔧 Architecture Notes

The DANA runtime uses the **visitor pattern** for execution, which provides a more maintainable and extensible architecture:

- **Visitor Pattern**: AST nodes are traversed using dedicated visit methods, allowing clean separation of node types and operations
- **LLM Integration**: Direct access to AI reasoning via the `reason()` statement
- **Runtime Context**: Manages state across execution through structured scopes
- **Hook System**: Extensible event system for customizing behavior at key execution points

> **Note**: The legacy non-visitor interpreter implementation is deprecated and will be removed in a future release. All new development should use the visitor pattern implementation.

---

## 📦 Public API

Designed for use inside agentic systems:

```python
from dana import run, compile_nl, explain
from dana.runtime.context import RuntimeContext

program = compile_nl("If X is drifting, flag it.")
ctx = RuntimeContext(agent=..., world=..., temp={})
run(program, ctx)
```

---

## 🔗 Benefits

* ✅ Uniform execution across agents, tools, LLMs
* ✅ Declarative planning, imperative acting
* ✅ Human-readable and explainable
* ✅ Reusable logic and modular KB
* ✅ Plug-and-play with OpenDXA or other agent frameworks

---

## 🔄 Bidirectional Layer

DANA includes tools to:

* Convert NL to structured code (`compile_nl()`)
* Translate programs back to natural language (`explain()`)

This enables:

* Domain experts to author rules in English
* Systems to explain what they’re doing
* Co-creation and trust in AI workflows

---

## 🧩 Example Use Cases

* Semiconductor diagnostics
* Financial credit assessment
* Predictive maintenance
* Maritime risk control
* Regulatory eligibility checks

---

## 🤝 Relationship to OpenDXA

* DANA is embedded within OpenDXA as the **reasoning and execution layer**
* Agents emit or receive DANA programs to carry out goals
* Tool calls and reasoning steps all route through DANA
* The KB provides reusable domain logic to DXAs and GMAs

---

## 🛠 Status

DANA is under active development and currently embedded inside `OpenDXA` as a module. Refactoring and extraction to an independent package is supported by clean modular structure.

> Future direction includes formal spec, test suite, and runtime service for multi-agent environments.

---

## 📣 Contribute

Want to help shape how intelligent agents reason and act? Reach out or contribute to the `dana/` module inside the OpenDXA repository.


---
<p align="center">
Copyright © 2025 Aitomatic, Inc. Licensed under the <a href="../LICENSE.md">MIT License</a>.
<br/>
<a href="https://aitomatic.com">https://aitomatic.com</a>
</p> 