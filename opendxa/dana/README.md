<p align="center">
  <img src="https://cdn.prod.website-files.com/62a10970901ba826988ed5aa/62d942adcae82825089dabdb_aitomatic-logo-black.png" alt="Aitomatic Logo" width="400" style="border: 2px solid #666; border-radius: 10px; padding: 20px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);"/>
</p>

# Dana (Domain-Aware NeuroSymbolic Architecture)

## 🧭 Vision

Dana is a universal program format and execution runtime that enables intelligent agents — human or machine — to reason, act, and collaborate through structured, interpretable programs.

It serves as the missing link between natural language objectives and tool-assisted, stateful action. Dana programs are concise, auditable, explainable, and can be authored by LLMs, domain experts, or both.

---

## 💡 Motivation & Problem

Modern AI systems struggle with:

* ✖️ **Prompt chains are fragile** — hard to debug, hard to maintain
* ✖️ **Plans are opaque** — impossible to inspect or explain mid-flight
* ✖️ **Tool use is scattered** — logic is buried in code, not declarative programs
* ✖️ **State is implicit** — no shared memory model or traceable updates

Symbolic systems offer structure but lack adaptability. LLMs offer creativity but lack transparency. Dana bridges the two.

---

## ✅ Solution

Dana introduces a lightweight domain-aware program language and runtime. It allows:

* 🧠 **Programs as first-class reasoning artifacts**
* 📦 **Shared state containers** (`agent`, `world`, `temp`, `execution`)
* 🧩 **Reusable logic units** via a structured Knowledge Base (KB)
* 🧾 **Declarative goals**, **imperative execution**
* 📜 **Bidirectional mapping to/from natural language**

Dana can:

* Be generated by a planning agent (like GMA)
* Be executed line-by-line by a runtime
* Interact with tools, LLMs, and memory
* Be stored, versioned, tested, and explained

---

## 🔁 Execution Flow (Simplified)

1. **AgentRuntime** receives an objective and instantiates a `RuntimeContext`
2. **GMA** emits a Dana program — either fresh or retrieved from the KB
3. **Interpreter** walks the program step by step
4. **reason(...)** calls LLMs, **use(...)** calls KB/tools, **set(...)** modifies state
5. All logic runs against an auditable shared memory model

---

## 🧱 State Model

Dana programs operate over a shared `RuntimeContext`, which is composed of three standard memory scopes:

| Scope      | Description                                |
| ---------- | ------------------------------------------ |
| `private:` | Private to the agent, resource, or tool itself |
| `public:`  | Openly accessible world state (time, weather, etc.) |
| `system:`  | System-related mechanical state with controlled access |

The `RuntimeContext` enforces strict scope boundaries and provides controlled access to state variables through dot notation (e.g., `private.user.name`, `public.weather.temperature`, `system.status`).

### Security Design

**The `dana.runtime` module is the primary enforcer of security during the execution of a Dana program.** It manages the `RuntimeContext` for the duration of the execution and enforces access policies based on the defined scopes and program logic.

| Security Concern            | Enforced By              | Mechanism                                      |
| --------------------------- | ------------------------ | ---------------------------------------------- |
| Scope restrictions          | `dana.runtime`           | Limits visible/writable scopes during execution |
| State mutation permissions  | `dana.runtime`           | Controlled state updates via instructions      |
| Tool/API usage validation   | `dana.runtime`           | Ensures `use` targets are valid/allowed        |
| LLM output handling         | `dana.runtime`           | Manages `reason` call results and potential errors |
| Execution logging           | `dana.runtime`           | Tracks execution steps within the Dana context |
| Resource constraints        | `dana.runtime`           | (Optional) Limits execution steps, time, memory |

```python
if world.sensor.temp > 100:
    temp.result = reason("Is this overheating?")
    if temp.result == "yes":
        execution.alerts.append("Overheat detected")
```

---

## 🗂 File Structure Overview

```text
dana/
├── runtime/         # Core execution engine
│   ├── interpreter.py    # AST visitor-based interpreter
│   ├── context.py        # Runtime state management
│   ├── function_registry.py  # Tool/function registration
│   ├── hooks.py          # Event system for extensibility
│   └── repl.py          # Interactive REPL implementation
├── language/        # Language implementation
│   ├── ast.py           # Abstract Syntax Tree nodes
│   ├── parser.py        # Lark-based parser
│   ├── type_checker.py  # Static type checking
│   ├── visitor.py       # Visitor pattern implementation
│   ├── types.py         # Type system definitions
│   └── transformers/    # Modular AST transformers
│       ├── base_transformer.py    # Common utilities
│       ├── statement_transformer.py # Statement parsing
│       ├── expression_transformer.py # Expression parsing
│       └── fstring_transformer.py  # F-string parsing
├── transcoder/      # NL ↔ Code translation
│   ├── transcoder.py    # Bidirectional translation
│   ├── compiler.py      # NL to Dana compilation
│   └── templates/       # Translation templates
├── io/              # I/O interfaces
├── exceptions.py    # Error handling
└── __init__.py     # Public API
```

## 🔧 Architecture Notes

The Dana runtime uses a robust architecture combining several design patterns:

- **Visitor Pattern**: AST nodes are traversed using dedicated visit methods, allowing clean separation of node types and operations
- **Hook System**: Extensible event system for customizing behavior at key execution points (before/after program, statements, errors)
- **Context Management**: Hierarchical state management with namespaced scopes
- **Function Registry**: Dynamic registration of tools and functions
- **Type System**: Static type checking with runtime validation
- **Logging System**: Configurable logging with color-coded levels (DEBUG, INFO, WARN, ERROR)
- **Modular Transformers**: The parser uses specialized transformer components for different language constructs, improving maintainability and extensibility

Key Features:
- Asynchronous execution support
- F-string interpolation in log messages
- Error location tracking and formatting
- Execution ID tracking for debugging
- Comprehensive error handling with custom exceptions

> **Note**: The runtime is designed to be extensible through hooks and function registration, allowing for custom behavior without modifying core code.

---

## 📦 Public API

Designed for use inside agentic systems:

```python
from opendxa.dana import run, compile_nl, explain
from opendxa.dana.sandbox.sandbox_context import SandboxContext
from opendxa.dana.sandbox.interpreter import Interpreter

# Basic usage
program = compile_nl("If X is drifting, flag it.")
ctx = RuntimeContext(agent=..., world=..., temp={})
run(program, ctx)

# Advanced usage with custom interpreter
interpreter = Interpreter(ctx)
interpreter.set_log_level(LogLevel.DEBUG)
interpreter.execute_program(program)
```

---

## 🔗 Benefits

* ✅ Uniform execution across agents, tools, LLMs
* ✅ Declarative planning, imperative acting
* ✅ Human-readable and explainable
* ✅ Reusable logic and modular KB
* ✅ Plug-and-play with OpenDXA or other agent frameworks

---

## 🔄 Bidirectional Layer

Dana includes tools to:

* Convert NL to structured code (`compile_nl()`)
* Translate programs back to natural language (`explain()`)

This enables:

* Domain experts to author rules in English
* Systems to explain what they're doing
* Co-creation and trust in AI workflows

---

## 🧩 Example Use Cases

* Semiconductor diagnostics
* Financial credit assessment
* Predictive maintenance
* Maritime risk control
* Regulatory eligibility checks

---

## 🤝 Relationship to OpenDXA

* Dana is embedded within OpenDXA as the **reasoning and execution layer**
* Agents emit or receive Dana programs to carry out goals
* Tool calls and reasoning steps all route through Dana
* The KB provides reusable domain logic to DXAs and GMAs

---

## 🛠 Status

Dana is under active development and currently embedded inside `OpenDXA` as a module. Refactoring and extraction to an independent package is supported by clean modular structure.

> Future direction includes formal spec, test suite, and runtime service for multi-agent environments.

---

## 📣 Contribute

Want to help shape how intelligent agents reason and act? Reach out or contribute to the `dana/` module inside the OpenDXA repository.

# Interactive Development
You can also explore Dana interactively using the REPL:

```bash
# Start the Dana REPL
python -m opendxa.dana.sandbox.repl

# Try some commands
dana> name = "OpenDXA"
dana> log.info(f"Hello from {name}!")
dana> use("workflows.example")
```

---

## NEW: Object Method Calls & MCP Integration

Dana now supports object-oriented patterns with MCP (Model Context Protocol) and A2A (Agent-to-Agent) integration:

### MCP Resource Integration
```python
# Connect to MCP services
websearch = use("mcp", url="http://localhost:8880/websearch")
database = use("mcp.database", "https://db.company.com/mcp")

# Call methods on MCP resources
tools = websearch.list_tools()
search_results = websearch.search("Dana programming examples")
db_records = database.query("SELECT * FROM projects WHERE active = true")

# Use in control structures
if websearch.health_check():
    results = websearch.search(query)
    log.info(f"Found {len(results)} search results")
```

### A2A Agent Integration
```python
# Connect to specialized agents
analyst = use("a2a.research-agent", "https://agents.company.com")
planner = use("a2a.workflow-coordinator")

# Call agent methods (handles async automatically)
market_data = analyst.collect_data("tech sector")
analysis = analyst.analyze_trends(market_data)
workflow = planner.create_workflow(analysis)
```

### With Statement Resource Management

> **⚠️ Current Limitation**: `with` statements currently support only a single `as` clause. 
> Multiple resources require nested `with` statements.

```python
# Scoped resource management
with use("mcp.database") as database:
    users = database.query("SELECT * FROM users WHERE active = true")
    database.update_last_seen(users)
    # Database connection automatically cleaned up

# Multiple resources - use nested statements
with use("mcp", url="http://localhost:8880/websearch") as websearch:
    with use("mcp.database") as database:
        search_results = websearch.search("customer feedback")
        database.store_analysis(search_results)
```

---

## Architecture and Design

---

## 🛠 Status

Dana is under active development and currently embedded inside `OpenDXA` as a module. Refactoring and extraction to an independent package is supported by clean modular structure.

> Future direction includes formal spec, test suite, and runtime service for multi-agent environments.

---

## 📣 Contribute

Want to help shape how intelligent agents reason and act? Reach out or contribute to the `dana/` module inside the OpenDXA repository.


---
<p align="center">
Copyright © 2025 Aitomatic, Inc. Licensed under the <a href="../LICENSE.md">MIT License</a>.
<br/>
<a href="https://aitomatic.com">https://aitomatic.com</a>
</p>
