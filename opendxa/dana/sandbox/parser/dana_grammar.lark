//
// Copyright Â© 2025 Aitomatic, Inc.
//
// This source code is licensed under the license found in the LICENSE file in the root directory of this source tree
//
// DANA language grammar definition
//
// This grammar follows KISS/YAGNI principles for maximum LALR parser compatibility.
// It provides security scopes with colon syntax and property access via dot notation.

%import common.WS_INLINE
%import common.NUMBER
%import common.ESCAPED_STRING -> REGULAR_STRING
%import common.WS
%declare _INDENT _DEDENT

// ===== PROGRAM STRUCTURE =====
// The program is the top-level structure, consisting of a sequence of statements
// Optional newlines at the beginning and end make the grammar more forgiving

program: _NL* statements _NL*

// A sequence of one or more statements
statements: statement+

// A statement can be either compound (with block) or simple (single line)
statement: compound_stmt | simple_stmt _NL

// ===== COMPOUND STATEMENTS =====
compound_stmt: if_stmt
             | while_stmt
             | for_stmt
             | function_def
             | try_stmt

block: _NL _INDENT statements _DEDENT*

// ===== COMPOUND STATEMENT TYPES =====
// Simplified if statement structure to avoid LALR conflicts
if_stmt: "if" expr ":" block
       | "if" expr ":" block "else" ":" block
       | "if" expr ":" block elif_stmts
       | "if" expr ":" block elif_stmts "else" ":" block

elif_stmts: elif_stmt+
elif_stmt: "elif" expr ":" block

// Other compound statements
while_stmt: "while" expr ":" block
for_stmt: "for" NAME "in" expr ":" block
function_def: "def" NAME "(" [parameters] ")" ":" block
try_stmt: "try" ":" block "except" ["(" expr ")"] ":" block ["finally" ":" block]

// Function parameters
parameters: parameter ("," parameter)*
parameter: NAME ["=" expr]

// ===== SIMPLE STATEMENTS =====
simple_stmt: assignment
           | expr_stmt
           | return_stmt
           | break_stmt
           | continue_stmt
           | pass_stmt
           | import_stmt
           | raise_stmt
           | assert_stmt

assignment: target "=" expr
expr_stmt: expr
return_stmt: "return" [expr]
break_stmt: "break"
continue_stmt: "continue"
pass_stmt: "pass"
import_stmt: "import" module_path ["as" NAME]
           | "from" module_path "import" NAME ["as" NAME]
raise_stmt: "raise" [expr ["from" expr]]
assert_stmt: "assert" expr ["," expr]

// Module paths for imports
module_path: NAME ("." NAME)*

// ===== VARIABLES AND ACCESS =====
// Variable with optional scope prefix
variable: scoped_var    // Variable with explicit scope (private:x)
        | simple_name   // Variable with implicit local scope (x)
        | dotted_access // Property access chain (obj.prop.field)

// Simple variable name (without dots)
simple_name: NAME

// Property access chain
dotted_access: simple_name ("." NAME)+

// Scoped variable
scoped_var: scope_prefix ":" (simple_name | dotted_access)

// Scope prefixes
scope_prefix: PRIVATE | PUBLIC | LOCAL | SYSTEM

// Assignment targets
// Previous rule (commented out for easy reversal):
// target: variable                // Variable
//       | atom "[" expr "]"       // Indexing
// New rule: allow any atom as assignment target (enables arr[0] = 5, obj.x = 1, etc.)
target: atom

// ===== EXPRESSIONS =====
expr: or_expr

or_expr: and_expr ("or" and_expr)*

and_expr: not_expr ("and" not_expr)*

not_expr: "not" not_expr | comparison

comparison: sum_expr (comp_op sum_expr)*

comp_op: LT_OP | GT_OP | EQ_OP | GE_OP | LE_OP | NE_OP
       | IN_OP | NOT_IN_OP | IS_OP | IS_NOT_OP

LT_OP: "<"
GT_OP: ">"
EQ_OP: "=="
GE_OP: ">="
LE_OP: "<="
NE_OP: "!="
IN_OP: "in"
NOT_IN_OP: "not" "in"
IS_OP: "is"
IS_NOT_OP: "is" "not"

sum_expr: term (ADD_OP term)*
ADD_OP: "+" | "-"
term: factor (MUL_OP factor)*
MUL_OP: "*" | "/" | "//" | "%"

factor: ("+" | "-") factor | power

power: atom trailer* "^" factor
     | atom trailer*

trailer: "(" [arguments] ")"    // Function call
       | "[" expr "]"           // Indexing
       | "." NAME               // Property access

arguments: expr ("," expr)* [","]

// ===== F-STRING SUPPORT =====
// TODO: Implement full f-string expression support in the transformer.

// Define a custom token that matches both f"string" and f"{expr}" patterns
// We include the outer quotes in the pattern, then strip them in the transformer
F_STRING: /[fF]("([^"\\]|\\.|{{|}|}|\{[^}]*\})*"|'([^'\\]|\\.|{{|}|}|\{[^}]*\})*')/

// f-string rule is just this one token
fstring: F_STRING

// These rules are for AST transformation
fstring_expr: "{" expr "}"
fstring_text: /[^{}"']+/
ESCAPED_BRACE: "{{" | "}}"

// Add raw string support
raw_string: "r" REGULAR_STRING

// ===== BASIC VALUES =====
atom: variable trailer*
    | NUMBER
    | any_string
    | TRUE
    | FALSE
    | NONE
    | collection
    | "(" expr ")"

// String literals with support for regular, raw, and multiline strings
any_string: REGULAR_STRING
          | fstring
          | raw_string
          | multiline_string

// Triple quoted string for multiline text
TRIPLE_QUOTED_STRING: /""".*?"""/s | /'''.*?'''/s

// Define the multiline_string rule to connect to the token
multiline_string: TRIPLE_QUOTED_STRING

// ===== COLLECTIONS =====
collection: list | dict | tuple

list: "[" [list_items] "]"
dict: "{" [dict_items] "}"
tuple: "(" ")"
     | "(" expr "," [list_items] ")"

list_items: expr ("," expr)* [","]
dict_items: key_value_pair ("," key_value_pair)* [","]
key_value_pair: expr ":" expr

// ===== WHITESPACE AND COMMENTS =====
_NL: /(\r?\n[\t ]*)+/

%ignore WS_INLINE
%ignore /[ \t\f]+/
%ignore /#[^\n]*/

PRIVATE: "private"
PUBLIC: "public"
LOCAL: "local"
SYSTEM: "system"

// TRUE, FALSE, NONE tokens must be defined above NAME for precedence
TRUE: "True" | "true" | "TRUE"
FALSE: "False" | "false" | "FALSE"
NONE: "None" | "none" | "NONE" | "null" | "NULL"
// Custom NAME token that excludes reserved words and f when followed by a quote
NAME: /(?!(f["']|F["']|True|true|TRUE|False|false|FALSE|None|none|NONE|null|NULL|private|public|local|system|break|continue|pass|return|if|else|while|for|def|try|except|finally|raise|assert|import|from|as|with|lambda|yield|global|nonlocal|del|and|or|not|is|in)\b)[a-zA-Z_][a-zA-Z0-9_]*/