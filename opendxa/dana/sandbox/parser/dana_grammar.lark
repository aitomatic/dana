//
// Copyright Â© 2025 Aitomatic, Inc.
//
// This source code is licensed under the license found in the LICENSE file in the root directory of this source tree
//
// DANA language grammar definition
//
// This grammar follows KISS/YAGNI principles for maximum LALR parser compatibility.
// It provides security scopes with colon syntax and property access via dot notation.

%import common.WS_INLINE
%import common.NUMBER
%import common.ESCAPED_STRING -> REGULAR_STRING
%import common.WS
%declare _INDENT _DEDENT

// ===== PROGRAM STRUCTURE =====
// The program is the top-level structure, consisting of a sequence of statements
// Optional newlines at the beginning and end make the grammar more forgiving

program: _NL* statements _NL*

// A sequence of one or more statements, allowing empty lines
statements: statement+

// A statement can be either compound (with block) or simple (single line)
// Allow optional additional newlines between statements and inline comments
statement: compound_stmt _NL* | simple_stmt [COMMENT] _NL _NL*

// ===== COMPOUND STATEMENTS =====
compound_stmt: if_stmt
             | while_stmt
             | for_stmt
             | function_def
             | try_stmt

block: _NL _INDENT statements _DEDENT*

// ===== COMPOUND STATEMENT TYPES =====
// Simplified if statement structure to avoid LALR conflicts
// Allow optional comments after colons
if_stmt: "if" expr ":" [COMMENT] block
       | "if" expr ":" [COMMENT] block "else" ":" [COMMENT] block
       | "if" expr ":" [COMMENT] block elif_stmts
       | "if" expr ":" [COMMENT] block elif_stmts "else" ":" [COMMENT] block

elif_stmts: elif_stmt+
elif_stmt: "elif" expr ":" [COMMENT] block

// Other compound statements
while_stmt: "while" expr ":" [COMMENT] block
for_stmt: "for" NAME "in" expr ":" [COMMENT] block
function_def: "def" NAME "(" [parameters] ")" ["->" basic_type] ":" [COMMENT] block
try_stmt: "try" ":" [COMMENT] block "except" ["(" expr ")"] ":" [COMMENT] block ["finally" ":" [COMMENT] block]

// Function parameters
parameters: typed_parameter ("," typed_parameter)*
typed_parameter: NAME [":" basic_type] ["=" expr]

// ===== TYPE ANNOTATIONS =====
// Basic type annotation support for KISS implementation
basic_type: INT_TYPE | FLOAT_TYPE | STR_TYPE | BOOL_TYPE | LIST_TYPE | DICT_TYPE | TUPLE_TYPE | SET_TYPE | NONE_TYPE | ANY_TYPE

// Type tokens - must be defined before NAME for precedence
INT_TYPE: "int"
FLOAT_TYPE: "float"
STR_TYPE: "str"
BOOL_TYPE: "bool"
LIST_TYPE: "list"
DICT_TYPE: "dict"
TUPLE_TYPE: "tuple"
SET_TYPE: "set"
NONE_TYPE: "None"
ANY_TYPE: "any"

// ===== SIMPLE STATEMENTS =====
simple_stmt: assignment
           | expr_stmt
           | return_stmt
           | break_stmt
           | continue_stmt
           | pass_stmt
           | import_stmt
           | raise_stmt
           | assert_stmt
           | comment_stmt

comment_stmt: COMMENT

assignment: typed_assignment | simple_assignment
typed_assignment: target ":" basic_type "=" expr
simple_assignment: target "=" expr
expr_stmt: expr
return_stmt: "return" [expr]
break_stmt: "break"
continue_stmt: "continue"
pass_stmt: "pass"
import_stmt: simple_import | from_import
raise_stmt: "raise" [expr ["from" expr]]
assert_stmt: "assert" expr ["," expr]

// Module paths for imports
module_path: NAME ("." NAME)*

// ===== VARIABLES AND ACCESS =====
// Variable with optional scope prefix
variable: scoped_var    // Variable with explicit scope (private:x)
        | simple_name   // Variable with implicit local scope (x)
        | dotted_access // Property access chain (obj.prop.field)

// Simple variable name (without dots)
simple_name: NAME

// Property access chain
dotted_access: simple_name ("." NAME)+

// Scoped variable
scoped_var: scope_prefix ":" (simple_name | dotted_access)

// Scope prefixes
scope_prefix: PRIVATE | PUBLIC | LOCAL | SYSTEM

// Assignment targets
// Previous rule (commented out for easy reversal):
// target: variable                // Variable
//       | atom "[" expr "]"       // Indexing
// New rule: allow any atom as assignment target (enables arr[0] = 5, obj.x = 1, etc.)
target: atom

// ===== EXPRESSIONS =====
expr: pipe_expr

pipe_expr: or_expr (PIPE or_expr)*

or_expr: and_expr ("or" and_expr)*

and_expr: not_expr ("and" not_expr)*

not_expr: NOT_OP not_expr | comparison

comparison: sum_expr (comp_op sum_expr)*

comp_op: LT_OP | GT_OP | EQ_OP | GE_OP | LE_OP | NE_OP
       | IN_OP | NOT_IN_OP | IS_OP | IS_NOT_OP

LT_OP: "<"
GT_OP: ">"
EQ_OP: "=="
GE_OP: ">="
LE_OP: "<="
NE_OP: "!="
IN_OP: "in"
NOT_IN_OP: "not" "in"
IS_OP: /\bis\b/
IS_NOT_OP: /\bis\s+not\b/

// Define token patterns with explicit priorities (lexer specific)
// IMPORTANT: Define ** first, then * to avoid conflicts
POW: "**"  // Define POW as a distinct token separate from MUL
ADD: "+" 
SUB: "-"
MUL: "*"
DIV: "/"
FDIV: "//"
MOD: "%"
PIPE: "|"

// Expression precedence structure (lowest to highest)
sum_expr: product ((ADD | SUB) product)*
product: power ((MUL | DIV | FDIV | MOD) power)*

// Power is right-associative, so use recursion on the right side 
power: factor (POW power)?
factor: (ADD | SUB) factor | atom trailer*

trailer: "(" [arguments] ")"    // Function call
       | "[" expr "]"           // Indexing
       | "." NAME               // Property access

arguments: expr ("," expr)* [","]

// ===== STRING LITERALS =====
// Regular string literals, referenced from common
// any_string: REGULAR_STRING
//           | fstring
//           | raw_string
//           | multiline_string

// Special handling for f-strings - must be before NAME and MULTILINE_STRING to get precedence
F_STRING_TOKEN.10: /[fF]""".*?"""/s
                 | /[fF]'''.*?'''/s
                 | /[fF]["](([^"\\]|\\.|\{[^}]*\})*)["]/ 
                 | /[fF]['](([^'\\]|\\.|\{[^}]*\})*)[']/ 

// Raw string token - must be defined before NAME
RAW_STRING: /[rR]""".*?"""/s
          | /[rR]'''.*?'''/s
          | /[rR]["](([^"\\]|\\.)*)["]/
          | /[rR]['](([^'\\]|\\.)*)[']/

// Multiline string token - must be after F_STRING_TOKEN and RAW_STRING
MULTILINE_STRING: /""".*?"""/s | /'''.*?'''/s

// Define the NAME token to explicitly NOT match f" or f' or r" or r' or f""" or f'''
// Important: Added patterns to exclude 'f"', 'f'', 'r"', 'r'', 'f"""', 'f'''', etc. in proper regex format
// Fixed: Removed 'as' from the negative lookahead since it should be handled as a separate token
NAME.1: /(?!([fF]["']{1,3}|[rR]["']|True|true|TRUE|False|false|FALSE|None|none|NONE|null|NULL|private|public|local|system|break|continue|pass|return|if|else|elif|while|for|def|try|except|finally|raise|assert|import|from|with|lambda|yield|global|nonlocal|del|and|or|not|in|is)\b)([a-zA-Z_][a-zA-Z0-9_]*)/

// Basic string literals with f-strings
string_literal: REGULAR_STRING
              | F_STRING_TOKEN
              | RAW_STRING
              | MULTILINE_STRING

// F-string rule used by the transformer
fstring: F_STRING_TOKEN

// These rules are for parser transformer
fstring_expr: "{" expr "}"
fstring_text: /[^{}"']+/
ESCAPED_BRACE: "{{" | "}}"

// These rules are for transformer references
raw_string: RAW_STRING
multiline_string: MULTILINE_STRING

// ===== BASIC VALUES =====
atom: variable trailer*
    | NUMBER
    | string_literal
    | TRUE
    | FALSE
    | NONE
    | collection
    | "(" expr ")"

// ===== COLLECTIONS =====
collection: list | dict | tuple | set

list: "[" [list_items] "]"
dict: "{" [dict_items] "}"
tuple: "(" ")"
     | "(" expr "," [list_items] ")"
set: "{" list_items "}"

list_items: expr ("," expr)* [","]
dict_items: key_value_pair ("," key_value_pair)* [","]
key_value_pair: expr ":" expr

// ===== WHITESPACE AND COMMENTS =====
// Modified to handle comments and newlines better
// Include comments in the newline pattern to handle them together
_NL: /(\r?\n[\t ]*)+/

%ignore WS_INLINE
%ignore /[ \t\f]+/
// Don't ignore comments - handle them explicitly
// %ignore /#[^\n]*/
COMMENT: /#[^\n]*/

PRIVATE: "private"
PUBLIC: "public"
LOCAL: "local"
SYSTEM: "system"

// TRUE, FALSE, NONE tokens must be defined above NAME for precedence
TRUE: "True" | "true" | "TRUE"
FALSE: "False" | "false" | "FALSE"
NONE: "None" | "none" | "NONE" | "null" | "NULL"

NOT_OP: "not"

// AS token for import statements - defined as a separate token to avoid conflicts with variable names
AS: "as"

simple_import: "import" module_path [AS NAME]
from_import: "from" module_path "import" NAME [AS NAME]