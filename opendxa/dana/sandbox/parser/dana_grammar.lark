//
// Copyright Â© 2025 Aitomatic, Inc.
//
// This source code is licensed under the license found in the LICENSE file in the root directory of this source tree
//
// DANA language grammar definition
//
// This grammar follows KISS/YAGNI principles for maximum LALR parser compatibility.
// It provides security scopes with colon syntax and property access via dot notation.

%import common.WS_INLINE
%import common.NUMBER
%import common.ESCAPED_STRING -> REGULAR_STRING
%import common.WS
%declare _INDENT _DEDENT

// ===== PROGRAM STRUCTURE =====
// The program is the top-level structure, consisting of a sequence of statements
// Optional newlines at the beginning and end make the grammar more forgiving

program: _NL* statements _NL*

// A sequence of one or more statements
statements: statement+

// A statement can be either compound (with block) or simple (single line)
// Allow optional additional newlines between statements
statement: compound_stmt | simple_stmt _NL _NL*

// ===== COMPOUND STATEMENTS =====
compound_stmt: if_stmt
             | while_stmt
             | for_stmt
             | function_def
             | try_stmt

block: _NL _INDENT statements _DEDENT*

// ===== COMPOUND STATEMENT TYPES =====
// Simplified if statement structure to avoid LALR conflicts
if_stmt: "if" expr ":" block
       | "if" expr ":" block "else" ":" block
       | "if" expr ":" block elif_stmts
       | "if" expr ":" block elif_stmts "else" ":" block

elif_stmts: elif_stmt+
elif_stmt: "elif" expr ":" block

// Other compound statements
while_stmt: "while" expr ":" block
for_stmt: "for" NAME "in" expr ":" block
function_def: "def" NAME "(" [parameters] ")" ":" block
try_stmt: "try" ":" block "except" ["(" expr ")"] ":" block ["finally" ":" block]

// Function parameters
parameters: parameter ("," parameter)*
parameter: NAME ["=" expr]

// ===== SIMPLE STATEMENTS =====
simple_stmt: assignment
           | expr_stmt
           | return_stmt
           | break_stmt
           | continue_stmt
           | pass_stmt
           | import_stmt
           | raise_stmt
           | assert_stmt

assignment: target "=" expr
expr_stmt: expr
return_stmt: "return" [expr]
break_stmt: "break"
continue_stmt: "continue"
pass_stmt: "pass"
import_stmt: simple_import | from_import
raise_stmt: "raise" [expr ["from" expr]]
assert_stmt: "assert" expr ["," expr]

// Module paths for imports
module_path: NAME ("." NAME)*

// ===== VARIABLES AND ACCESS =====
// Variable with optional scope prefix
variable: scoped_var    // Variable with explicit scope (private:x)
        | simple_name   // Variable with implicit local scope (x)
        | dotted_access // Property access chain (obj.prop.field)

// Simple variable name (without dots)
simple_name: NAME

// Property access chain
dotted_access: simple_name ("." NAME)+

// Scoped variable
scoped_var: scope_prefix ":" (simple_name | dotted_access)

// Scope prefixes
scope_prefix: PRIVATE | PUBLIC | LOCAL | SYSTEM

// Assignment targets
// Previous rule (commented out for easy reversal):
// target: variable                // Variable
//       | atom "[" expr "]"       // Indexing
// New rule: allow any atom as assignment target (enables arr[0] = 5, obj.x = 1, etc.)
target: atom

// ===== EXPRESSIONS =====
expr: pipe_expr

pipe_expr: or_expr (PIPE or_expr)*

or_expr: and_expr ("or" and_expr)*

and_expr: not_expr ("and" not_expr)*

not_expr: NOT_OP not_expr | comparison

comparison: sum_expr (comp_op sum_expr)*

comp_op: LT_OP | GT_OP | EQ_OP | GE_OP | LE_OP | NE_OP
       | IN_OP | NOT_IN_OP | IS_OP | IS_NOT_OP

LT_OP: "<"
GT_OP: ">"
EQ_OP: "=="
GE_OP: ">="
LE_OP: "<="
NE_OP: "!="
IN_OP: "in"
NOT_IN_OP: "not" "in"
IS_OP: /\bis\b/
IS_NOT_OP: /\bis\s+not\b/

// Define token patterns with explicit priorities (lexer specific)
// IMPORTANT: Define ** first, then * to avoid conflicts
POW: "**"  // Define POW as a distinct token separate from MUL
ADD: "+" 
SUB: "-"
MUL: "*"
DIV: "/"
FDIV: "//"
MOD: "%"
PIPE: "|"

// Expression precedence structure (lowest to highest)
sum_expr: product ((ADD | SUB) product)*
product: power ((MUL | DIV | FDIV | MOD) power)*

// Power is right-associative, so use recursion on the right side 
power: atom (POW power)?
factor: (ADD | SUB) factor | atom trailer*

trailer: "(" [arguments] ")"    // Function call
       | "[" expr "]"           // Indexing
       | "." NAME               // Property access

arguments: expr ("," expr)* [","]

// ===== STRING LITERALS =====
// Regular string literals, referenced from common
// any_string: REGULAR_STRING
//           | fstring
//           | raw_string
//           | multiline_string

// Special handling for f-strings - must be before NAME to get precedence
F_STRING_TOKEN: /[fF]["](([^"\\]|\\.|\{[^}]*\})*)["]/ 
              | /[fF]['](([^'\\]|\\.|\{[^}]*\})*)[']/ 

// Raw string token - must be defined before NAME
RAW_STRING: /[rR]["](([^"\\]|\\.)*)["]/
          | /[rR]['](([^'\\]|\\.)*)[']/

// Multiline string token
MULTILINE_STRING: /""".*?"""/s | /'''.*?'''/s

// Define the NAME token to explicitly NOT match f" or f' or r" or r'
// Important: Added patterns to exclude 'f"', 'f'', 'r"', 'r'' in proper regex format
NAME: /(?!([fF]["']|[rR]["']|True|true|TRUE|False|false|FALSE|None|none|NONE|null|NULL|private|public|local|system|break|continue|pass|return|if|else|while|for|def|try|except|finally|raise|assert|import|from|as|with|lambda|yield|global|nonlocal|del|and|or|not)(\b|))([a-zA-Z_][a-zA-Z0-9_]*)/

// Basic string literals with f-strings
string_literal: REGULAR_STRING
              | F_STRING_TOKEN
              | RAW_STRING
              | MULTILINE_STRING

// F-string rule used by the transformer
fstring: F_STRING_TOKEN

// These rules are for parser transformer
fstring_expr: "{" expr "}"
fstring_text: /[^{}"']+/
ESCAPED_BRACE: "{{" | "}}"

// These rules are for transformer references
raw_string: RAW_STRING
multiline_string: MULTILINE_STRING

// ===== BASIC VALUES =====
atom: variable trailer*
    | NUMBER
    | string_literal
    | TRUE
    | FALSE
    | NONE
    | collection
    | "(" expr ")"

// ===== COLLECTIONS =====
collection: list | dict | tuple

list: "[" [list_items] "]"
dict: "{" [dict_items] "}"
tuple: "(" ")"
     | "(" expr "," [list_items] ")"

list_items: expr ("," expr)* [","]
dict_items: key_value_pair ("," key_value_pair)* [","]
key_value_pair: expr ":" expr

// ===== WHITESPACE AND COMMENTS =====
_NL: /(\r?\n[\t ]*)+/

%ignore WS_INLINE
%ignore /[ \t\f]+/
%ignore /#[^\n]*/

PRIVATE: "private"
PUBLIC: "public"
LOCAL: "local"
SYSTEM: "system"

// TRUE, FALSE, NONE tokens must be defined above NAME for precedence
TRUE: "True" | "true" | "TRUE"
FALSE: "False" | "false" | "FALSE"
NONE: "None" | "none" | "NONE" | "null" | "NULL"

NOT_OP: "not"

simple_import: "import" module_path ["as" NAME]
from_import: "from" module_path "import" NAME ["as" NAME]