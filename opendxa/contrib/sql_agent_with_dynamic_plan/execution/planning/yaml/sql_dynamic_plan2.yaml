name: SQL Planning
description: "SQL Planner to construct a SQL query to answer the question"

nodes:
  - id: UNDERSTAND
    to_llm: |
      You are a SQL Expert. Your goal is to generate complex SQL queries to answer user's question.
      Question: {{agent.plan.initial_objective}}
      
      Make sure you understand the question clearly by:
      - Clarify the question: Make sure you fully understand what data the user needs.
      - Determine the output: What should the final result look like? What fields? What format?
      - Identify the business logic: Know the rules behind filtering, aggregation, grouping, etc.
    from_llm:
      understanding: "agent.plan.understanding"
      requirements: "agent.plan.requirements"
    next: ANALYZE

  - id: ANALYZE
    to_llm: |
      You are a SQL Expert. Your goal is to generate complex SQL queries to answer user's question.
      Question: {{agent.plan.initial_objective}}
      Understanding: {{agent.plan.understanding}}
      
      Based on the question, analyze the database schema by using the tools provided:
      - Identify involved tables: Which tables contain the necessary data?
      - Understand relationships: Look at foreign keys, primary keys, and table joins.
      - Review constraints and indexes: Helps in understanding how best to filter or join.
    from_llm:
      schema_analysis: "agent.plan.schema_analysis"
      table_relationships: "agent.plan.table_relationships"
    next: BREAKDOWN

  - id: BREAKDOWN
    to_llm: |
      You are a SQL Expert. Your goal is to generate complex SQL queries to answer user's question.
      Question: {{agent.plan.initial_objective}}
      Understanding: {{agent.plan.understanding}}
      Schema Analysis: {{agent.plan.schema_analysis}}
      
      Break down the query by following these steps:
      1. Start with the base table: Choose the table with the core data.
      2. Start with smallest valid subquery, verifying each step produces correct intermediate results.
      3. Treat the query like a proof in logic: every clause should be justified.
      4. Layer joins step-by-step: Add related tables one at a time.
      5. Apply filters early: Helps reduce data volume and improves performance.
    from_llm:
      query_structure: "agent.plan.query_structure"
      join_strategy: "agent.plan.join_strategy"
    next: WRITE_DYNAMIC

  - id: WRITE_DYNAMIC
    to_llm: |
      You are a SQL Expert. Your goal is to generate complex SQL queries to answer user's question.
      Question: {{agent.plan.initial_objective}}
      Query Structure: {{agent.plan.query_structure}}
      Join Strategy: {{agent.plan.join_strategy}}
      
      Based on the breakdown, write the SQL query for the question following these rules:
      - Use CTEs (Common Table Expressions) or subqueries to simplify.
      - Start with smallest valid subquery, verifying each step produces correct intermediate results.
      - Alias everything: Helps in readability and reduces errors.
      - Use meaningful names for columns and derived fields.
      - Treat the query like a proof in logic: every clause should be justified.
    from_llm:
      sql_query: "agent.plan.sql_query"
      query_explanation: "agent.plan.query_explanation"
    next: OPTIMIZE

  - id: OPTIMIZE
    to_llm: |
      You are a SQL Expert. Your goal is to generate complex SQL queries to answer user's question.
      Question: {{agent.plan.initial_objective}}
      SQL Query: {{agent.plan.sql_query}}
      Query Explanation: {{agent.plan.query_explanation}}
      
      Optimize the SQL query for performance by following these rules:
      - Reduce nested subqueries or replace them with joins if more efficient.
      - Avoid SELECT * â€” always specify columns.
      - Consider indexing strategy for the query.
      - Analyze query execution plan for potential bottlenecks.
    from_llm:
      optimized_query: "agent.plan.final_query"
      optimization_notes: "agent.plan.optimization_notes"
    next: end

  - id: end
    type: end 