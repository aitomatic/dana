# Test: Lambda Receivers
# Purpose: Test lambda expressions with struct receivers and method calls
# Category: Advanced Syntax - Lambda Expressions

log("Starting Lambda Receivers test")

# Test 1: Basic struct receiver lambda
# Define a simple struct for testing
struct Person {
    name: str
    age: int
    
    def get_info(self) -> str {
        return f"{self.name} is {self.age} years old"
    }
    
    def is_adult(self) -> bool {
        return self.age >= 18
    }
}

# Lambda with struct receiver
get_person_info = lambda (person: Person) :: person.get_info()
person = Person("Alice", 25)
result = get_person_info(person)
assert result == "Alice is 25 years old", f"Expected 'Alice is 25 years old', got '{result}'"
log("✅ Basic struct receiver lambda works")

# Test 2: Lambda with struct receiver and property access
get_age = lambda (person: Person) :: person.age
result = get_age(person)
assert result == 25, f"Expected 25, got {result}"
log("✅ Lambda with struct receiver and property access works")

# Test 3: Lambda with struct receiver and boolean method
check_adult = lambda (person: Person) :: person.is_adult()
result1 = check_adult(person)
result2 = check_adult(Person("Bob", 16))
assert result1 == true, f"Expected true, got {result1}"
assert result2 == false, f"Expected false, got {result2}"
log("✅ Lambda with struct receiver and boolean method works")

# Test 4: Lambda with struct receiver and multiple operations
complex_person_op = lambda (person: Person) :: (person.name, person.age, person.is_adult())
result = complex_person_op(person)
assert result == ("Alice", 25, true), f"Expected ('Alice', 25, true), got {result}"
log("✅ Lambda with struct receiver and multiple operations works")

# Test 5: Lambda with struct receiver and conditional logic
age_category = lambda (person: Person) :: "adult" if person.age >= 18 else "minor"
result1 = age_category(person)
result2 = age_category(Person("Charlie", 15))
assert result1 == "adult", f"Expected 'adult', got '{result1}'"
assert result2 == "minor", f"Expected 'minor', got '{result2}'"
log("✅ Lambda with struct receiver and conditional logic works")

# Test 6: Lambda with struct receiver and string formatting
format_person = lambda (person: Person) :: f"Person: {person.name} ({person.age})"
result = format_person(person)
assert result == "Person: Alice (25)", f"Expected 'Person: Alice (25)', got '{result}'"
log("✅ Lambda with struct receiver and string formatting works")

# Test 7: Lambda with struct receiver and arithmetic operations
age_in_days = lambda (person: Person) :: person.age * 365
result = age_in_days(person)
assert result == 9125, f"Expected 9125, got {result}"
log("✅ Lambda with struct receiver and arithmetic operations works")

# Test 8: Lambda with struct receiver and list operations
person_to_list = lambda (person: Person) :: [person.name, person.age, person.is_adult()]
result = person_to_list(person)
assert result == ["Alice", 25, true], f"Expected ['Alice', 25, true], got {result}"
log("✅ Lambda with struct receiver and list operations works")

# Test 9: Lambda with struct receiver and dict operations
person_to_dict = lambda (person: Person) :: {"name": person.name, "age": person.age, "adult": person.is_adult()}
result = person_to_dict(person)
expected = {"name": "Alice", "age": 25, "adult": true}
assert result == expected, f"Expected {expected}, got {result}"
log("✅ Lambda with struct receiver and dict operations works")

# Test 10: Lambda with struct receiver and comparison operations
compare_age = lambda (person: Person), threshold: int :: person.age > threshold
result1 = compare_age(person, 20)
result2 = compare_age(person, 30)
assert result1 == true, f"Expected true, got {result1}"
assert result2 == false, f"Expected false, got {result2}"
log("✅ Lambda with struct receiver and comparison operations works")

# Test 11: Lambda with struct receiver and method chaining
# Add a method that returns the person object for chaining
struct Person {
    name: str
    age: int
    
    def get_info(self) -> str {
        return f"{self.name} is {self.age} years old"
    }
    
    def is_adult(self) -> bool {
        return self.age >= 18
    }
    
    def with_age(self, new_age: int) -> Person {
        return Person(self.name, new_age)
    }
}

chain_operation = lambda (person: Person) :: person.with_age(30).get_info()
result = chain_operation(person)
assert result == "Alice is 30 years old", f"Expected 'Alice is 30 years old', got '{result}'"
log("✅ Lambda with struct receiver and method chaining works")

# Test 12: Lambda with struct receiver and error handling
safe_age_access = lambda (person: Person) :: person.age if person else 0
result1 = safe_age_access(person)
result2 = safe_age_access(None)
assert result1 == 25, f"Expected 25, got {result1}"
assert result2 == 0, f"Expected 0, got {result2}"
log("✅ Lambda with struct receiver and error handling works")

# Test 13: Lambda with struct receiver and type checking
type_checker = lambda (person: Person) :: type(person) == Person
result = type_checker(person)
assert result == true, f"Expected true, got {result}"
log("✅ Lambda with struct receiver and type checking works")

# Test 14: Lambda with struct receiver and attribute existence check
has_attribute = lambda (person: Person) :: hasattr(person, "name") and hasattr(person, "age")
result = has_attribute(person)
assert result == true, f"Expected true, got {result}"
log("✅ Lambda with struct receiver and attribute existence check works")

# Test 15: Lambda with struct receiver and getattr usage
dynamic_access = lambda (person: Person), attr: str :: getattr(person, attr, None)
result1 = dynamic_access(person, "name")
result2 = dynamic_access(person, "age")
result3 = dynamic_access(person, "nonexistent")
assert result1 == "Alice", f"Expected 'Alice', got '{result1}'"
assert result2 == 25, f"Expected 25, got {result2}"
assert result3 == None, f"Expected None, got {result3}"
log("✅ Lambda with struct receiver and getattr usage works")

# Test 16: Lambda with struct receiver and setattr usage
setter_lambda = lambda (person: Person), attr: str, value: any :: setattr(person, attr, value) or person
result = setter_lambda(person, "age", 30)
assert result.age == 30, f"Expected 30, got {result.age}"
log("✅ Lambda with struct receiver and setattr usage works")

# Test 17: Lambda with struct receiver and multiple structs
struct Point {
    x: int
    y: int
    
    def distance_to(self, other: Point) -> float {
        dx = self.x - other.x
        dy = self.y - other.y
        return (dx * dx + dy * dy) ** 0.5
    }
}

distance_calculator = lambda (p1: Point), (p2: Point) :: p1.distance_to(p2)
point1 = Point(0, 0)
point2 = Point(3, 4)
result = distance_calculator(point1, point2)
assert result == 5.0, f"Expected 5.0, got {result}"
log("✅ Lambda with struct receiver and multiple structs works")

# Test 18: Lambda with struct receiver and inheritance
struct Animal {
    name: str
    
    def speak(self) -> str {
        return "Some sound"
    }
}

struct Dog extends Animal {
    def speak(self) -> str {
        return "Woof!"
    }
}

speak_lambda = lambda (animal: Animal) :: animal.speak()
dog = Dog("Rex")
result = speak_lambda(dog)
assert result == "Woof!", f"Expected 'Woof!', got '{result}'"
log("✅ Lambda with struct receiver and inheritance works")

# Test 19: Lambda with struct receiver and static methods
struct MathUtils {
    @staticmethod
    def add(a: int, b: int) -> int {
        return a + b
    }
    
    @staticmethod
    def multiply(a: int, b: int) -> int {
        return a * b
    }
}

static_method_lambda = lambda (utils: MathUtils) :: utils.add(5, 3)
math_utils = MathUtils()
result = static_method_lambda(math_utils)
assert result == 8, f"Expected 8, got {result}"
log("✅ Lambda with struct receiver and static methods works")

# Test 20: Lambda with struct receiver and complex nested operations
struct Address {
    street: str
    city: str
    country: str
    
    def full_address(self) -> str {
        return f"{self.street}, {self.city}, {self.country}"
    }
}

struct Employee extends Person {
    address: Address
    salary: float
    
    def get_full_info(self) -> str {
        return f"{self.get_info()} - {self.address.full_address()} - ${self.salary}"
    }
}

complex_employee_lambda = lambda (employee: Employee) :: {
    "name": employee.name,
    "age": employee.age,
    "address": employee.address.full_address(),
    "salary": employee.salary,
    "full_info": employee.get_full_info()
}

address = Address("123 Main St", "New York", "USA")
employee = Employee("John", 30)
employee.address = address
employee.salary = 50000.0

result = complex_employee_lambda(employee)
expected = {
    "name": "John",
    "age": 30,
    "address": "123 Main St, New York, USA",
    "salary": 50000.0,
    "full_info": "John is 30 years old - 123 Main St, New York, USA - $50000.0"
}
assert result == expected, f"Expected {expected}, got {result}"
log("✅ Lambda with struct receiver and complex nested operations works")

log("Lambda Receivers test completed successfully") 