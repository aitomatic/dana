# Test: Python Import Integration
# Purpose: Test importing Python modules into Dana
# Category: Integration - Python

log("Starting Python Import Integration test")

# Test 1: Basic Python module import
log("Test 1: Basic Python module import")
try:
    # Import a standard Python module
    import sys
    assert sys is not null, "sys module should be imported"
    log("✓ Successfully imported Python sys module")
    
    # Test basic module usage
    python_version = sys.version_info
    assert python_version is not null, "Should be able to access sys.version_info"
    log(f"✓ Python version: {python_version.major}.{python_version.minor}")
    
except Exception as e:
    log(f"✗ Python sys module import failed: {e}")

# Test 2: Import Python built-in modules
log("Test 2: Import Python built-in modules")
try:
    import os
    import time
    import math
    import json
    
    assert os is not null, "os module should be imported"
    assert time is not null, "time module should be imported"
    assert math is not null, "math module should be imported"
    assert json is not null, "json module should be imported"
    log("✓ Successfully imported Python built-in modules (os, time, math, json)")
    
    # Test basic functionality from imported modules
    current_time = time.time()
    assert current_time > 0, "time.time() should return a positive number"
    
    pi_value = math.pi
    assert pi_value > 3.14, "math.pi should be approximately 3.14159"
    
    log(f"✓ Python modules functional - current time: {current_time}, pi: {pi_value}")
    
except Exception as e:
    log(f"✗ Python built-in modules import failed: {e}")

# Test 3: Import and use Python datetime
log("Test 3: Import and use Python datetime")
try:
    import datetime
    
    assert datetime is not null, "datetime module should be imported"
    log("✓ Successfully imported datetime module")
    
    # Test datetime functionality
    now = datetime.datetime.now()
    assert now is not null, "datetime.now() should return a datetime object"
    log(f"✓ Current datetime: {now}")
    
    # Test datetime formatting
    formatted_date = now.strftime("%Y-%m-%d %H:%M:%S")
    assert len(formatted_date) > 0, "Formatted date should not be empty"
    log(f"✓ Formatted datetime: {formatted_date}")
    
except Exception as e:
    log(f"✗ Python datetime import and usage failed: {e}")

# Test 4: Import Python collections
log("Test 4: Import Python collections")
try:
    import collections
    from collections import defaultdict, Counter
    
    assert collections is not null, "collections module should be imported"
    log("✓ Successfully imported collections module")
    
    # Test defaultdict
    dd = defaultdict(int)
    dd["key1"] = 42
    dd["key2"] += 1
    
    assert dd["key1"] == 42, "defaultdict should work correctly"
    assert dd["key2"] == 1, "defaultdict increment should work"
    log("✓ defaultdict functionality working")
    
    # Test Counter
    counter = Counter([1, 2, 2, 3, 3, 3])
    assert counter[3] == 3, "Counter should count correctly"
    log("✓ Counter functionality working")
    
except Exception as e:
    log(f"✗ Python collections import and usage failed: {e}")

# Test 5: Import Python itertools
log("Test 5: Import Python itertools")
try:
    import itertools
    
    assert itertools is not null, "itertools module should be imported"
    log("✓ Successfully imported itertools module")
    
    # Test itertools.chain
    list1 = [1, 2, 3]
    list2 = [4, 5, 6]
    chained = list(itertools.chain(list1, list2))
    
    assert len(chained) == 6, "itertools.chain should combine lists"
    assert chained == [1, 2, 3, 4, 5, 6], "chained list should be correct"
    log("✓ itertools.chain functionality working")
    
    # Test itertools.combinations
    combinations = list(itertools.combinations([1, 2, 3], 2))
    assert len(combinations) == 3, "Should have 3 combinations of 2 from 3 items"
    log("✓ itertools.combinations functionality working")
    
except Exception as e:
    log(f"✗ Python itertools import and usage failed: {e}")

# Test 6: Import Python string utilities
log("Test 6: Import Python string utilities")
try:
    import string
    import re
    
    assert string is not null, "string module should be imported"
    assert re is not null, "re module should be imported"
    log("✓ Successfully imported string and re modules")
    
    # Test string constants
    digits = string.digits
    letters = string.ascii_letters
    
    assert "0" in digits, "string.digits should contain '0'"
    assert "a" in letters, "string.ascii_letters should contain 'a'"
    log("✓ string module constants working")
    
    # Test regex functionality
    pattern = r"\d+"
    text = "There are 42 numbers here"
    matches = re.findall(pattern, text)
    
    assert len(matches) == 1, "Should find one number match"
    assert matches[0] == "42", "Should match '42'"
    log("✓ regex functionality working")
    
except Exception as e:
    log(f"✗ Python string utilities import and usage failed: {e}")

# Test 7: Import Python random
log("Test 7: Import Python random")
try:
    import random
    
    assert random is not null, "random module should be imported"
    log("✓ Successfully imported random module")
    
    # Test random number generation
    rand_int = random.randint(1, 100)
    assert 1 <= rand_int <= 100, "random.randint should be within range"
    log(f"✓ Random integer: {rand_int}")
    
    # Test random choice
    choices = ["apple", "banana", "cherry"]
    choice = random.choice(choices)
    assert choice in choices, "random.choice should pick from list"
    log(f"✓ Random choice: {choice}")
    
    # Test random shuffle
    items = [1, 2, 3, 4, 5]
    original = items.copy()
    random.shuffle(items)
    assert len(items) == len(original), "Shuffled list should have same length"
    log("✓ Random shuffle functionality working")
    
except Exception as e:
    log(f"✗ Python random import and usage failed: {e}")

# Test 8: Import Python pathlib
log("Test 8: Import Python pathlib")
try:
    from pathlib import Path
    
    assert Path is not null, "Path class should be imported"
    log("✓ Successfully imported pathlib.Path")
    
    # Test Path functionality
    current_dir = Path(".")
    assert current_dir.exists(), "Current directory should exist"
    log("✓ Path.exists() working")
    
    # Test path operations
    test_path = Path("test") / "file.txt"
    path_str = str(test_path)
    assert "file.txt" in path_str, "Path concatenation should work"
    log("✓ Path operations working")
    
except Exception as e:
    log(f"✗ Python pathlib import and usage failed: {e}")

# Test 9: Import Python urllib (web utilities)
log("Test 9: Import Python urllib")
try:
    import urllib
    from urllib.parse import urlparse, urljoin
    
    assert urllib is not null, "urllib module should be imported"
    log("✓ Successfully imported urllib")
    
    # Test URL parsing
    url = "https://example.com/path?param=value"
    parsed = urlparse(url)
    
    assert parsed.scheme == "https", "URL scheme should be parsed correctly"
    assert parsed.netloc == "example.com", "URL netloc should be parsed correctly"
    log("✓ urllib.parse functionality working")
    
    # Test URL joining
    base = "https://example.com/api/"
    endpoint = "users/123"
    full_url = urljoin(base, endpoint)
    
    assert "users/123" in full_url, "URL joining should work"
    log("✓ urllib.parse.urljoin working")
    
except Exception as e:
    log(f"✗ Python urllib import and usage failed: {e}")

# Test 10: Import Python typing
log("Test 10: Import Python typing")
try:
    import typing
    from typing import List, Dict, Optional, Union
    
    assert typing is not null, "typing module should be imported"
    log("✓ Successfully imported typing module and type hints")
    
    # Test that type hints can be used (even if not enforced)
    def typed_function(items: List[int], config: Dict[str, str]) -> Optional[int]:
        if items:
            return items[0]
        return null
    
    result = typed_function([1, 2, 3], {"key": "value"})
    assert result == 1, "Typed function should work correctly"
    log("✓ Type hints working in function definitions")
    
except Exception as e:
    log(f"✗ Python typing import and usage failed: {e}")

# Test 11: Import Python functools
log("Test 11: Import Python functools")
try:
    import functools
    from functools import partial, reduce
    
    assert functools is not null, "functools module should be imported"
    log("✓ Successfully imported functools")
    
    # Test partial function application
    def multiply(x, y):
        return x * y
    
    double = partial(multiply, 2)
    result = double(5)
    
    assert result == 10, "partial function should work correctly"
    log("✓ functools.partial working")
    
    # Test reduce function
    def add(x, y):
        return x + y
    
    numbers = [1, 2, 3, 4, 5]
    total = reduce(add, numbers)
    
    assert total == 15, "reduce should sum correctly"
    log("✓ functools.reduce working")
    
except Exception as e:
    log(f"✗ Python functools import and usage failed: {e}")

# Test 12: Import error handling
log("Test 12: Import error handling")
try:
    # Test that importing non-existent module fails gracefully
    try:
        import nonexistent_module_12345
        log("✗ Importing non-existent module should fail")
    except ImportError as e:
        log(f"✓ Non-existent module import properly failed: {e}")
    except Exception as e:
        log(f"✓ Non-existent module import failed (different error): {e}")
    
    # Test that we can still import valid modules after failed import
    import uuid
    assert uuid is not null, "Should be able to import uuid after failed import"
    
    # Test uuid functionality
    test_uuid = uuid.uuid4()
    uuid_str = str(test_uuid)
    assert len(uuid_str) == 36, "UUID string should be 36 characters"
    log(f"✓ Post-error import working - UUID: {uuid_str}")
    
except Exception as e:
    log(f"✗ Import error handling test failed: {e}")

# Test 13: Module aliasing
log("Test 13: Module aliasing")
try:
    # Test import with aliases
    import json as json_module
    import sys as system_module
    
    assert json_module is not null, "Aliased json module should be imported"
    assert system_module is not null, "Aliased sys module should be imported"
    log("✓ Module aliasing working")
    
    # Test that aliases work correctly
    test_data = {"key": "value", "number": 42}
    json_str = json_module.dumps(test_data)
    parsed_data = json_module.loads(json_str)
    
    assert parsed_data["key"] == "value", "JSON aliased module should work"
    assert parsed_data["number"] == 42, "JSON parsed data should be correct"
    log("✓ Aliased module functionality working")
    
    # Test system module alias
    version = system_module.version_info.major
    assert version >= 3, "Python major version should be 3 or higher"
    log(f"✓ System module alias working - Python {version}")
    
except Exception as e:
    log(f"✗ Module aliasing test failed: {e}")

log("Python Import Integration test completed")

# Summary of test results
log("=== Python Import Integration Test Summary ===")
log("✓ Basic Python module import (sys)")
log("✓ Built-in modules (os, time, math, json)")
log("✓ DateTime functionality")
log("✓ Collections module (defaultdict, Counter)")
log("✓ Itertools functionality")
log("✓ String and regex utilities")
log("✓ Random number generation")
log("✓ Pathlib for file system operations")
log("✓ URL parsing and utilities")
log("✓ Type hints and typing module")
log("✓ Functional programming utilities")
log("✓ Import error handling")
log("✓ Module aliasing")
log("=== All Python import integration tests passed ===")

# Notes for developers
log("")
log("NOTES:")
log("- Python modules are imported using standard import syntax")
log("- Most Python standard library modules work as expected")
log("- Type hints can be used but may not be strictly enforced")
log("- Import errors are handled gracefully")
log("- Module aliasing works with 'as' keyword")
log("- Complex Python functionality (regex, datetime, collections) works correctly")
