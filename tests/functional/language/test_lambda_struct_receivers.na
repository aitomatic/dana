# Functional tests for lambda expressions with struct receivers
log("Starting lambda expressions with struct receivers tests")

# Define test structs
struct Point:
    x: int
    y: int

struct Person:
    name: str
    age: int
    email: str

struct Calculator:
    base_value: int

# Test 1: Basic lambda expressions as struct methods
def test_lambda_as_struct_methods():
    # Point struct with lambda methods
    point = Point(x=3, y=4)
    
    # Lambda expression as a method receiver
    distance_from_origin = lambda self :: (self.x ** 2 + self.y ** 2) ** 0.5
    distance = distance_from_origin(point)
    expected = 5.0
    assert abs(distance - expected) < 0.001, f"Expected {expected}, got {distance}"
    
    # Lambda to translate point
    translate = lambda self, dx, dy :: Point(x=self.x + dx, y=self.y + dy)
    new_point = translate(point, 2, -1)
    assert new_point.x == 5, f"Expected x=5, got {new_point.x}"
    assert new_point.y == 3, f"Expected y=3, got {new_point.y}"
    
    log("âœ… Lambda as struct methods tests passed")

# Test 2: Lambda expressions modifying struct fields
def test_lambda_struct_field_operations():
    person = Person(name="Alice", age=25, email="alice@example.com")
    
    # Lambda to format person info
    format_info = lambda self :: f"{self.name} ({self.age}) - {self.email}"
    info = format_info(person)
    expected = "Alice (25) - alice@example.com"
    assert info == expected, f"Expected '{expected}', got '{info}'"
    
    # Lambda to check if person is adult
    is_adult = lambda self :: self.age >= 18
    adult_status = is_adult(person)
    assert adult_status == True, f"Expected True, got {adult_status}"
    
    # Lambda to generate email domain
    get_domain = lambda self :: self.email.split("@")[1] if "@" in self.email else ""
    domain = get_domain(person)
    assert domain == "example.com", f"Expected 'example.com', got '{domain}'"
    
    log("âœ… Lambda struct field operations tests passed")

# Test 3: Lambda expressions with struct chaining
def test_lambda_struct_chaining():
    calc = Calculator(base_value=10)
    
    # Lambda expressions for calculator operations
    add = lambda self, x :: Calculator(base_value=self.base_value + x)
    multiply = lambda self, x :: Calculator(base_value=self.base_value * x)
    get_value = lambda self :: self.base_value
    
    # Chain operations
    calc1 = add(calc, 5)          # 10 + 5 = 15
    calc2 = multiply(calc1, 2)    # 15 * 2 = 30
    final_value = get_value(calc2)
    
    assert final_value == 30, f"Expected 30, got {final_value}"
    
    log("âœ… Lambda struct chaining tests passed")

# Test 4: Lambda expressions with complex struct operations
def test_lambda_complex_struct_operations():
    # Create multiple points
    points = [
        Point(x=1, y=2),
        Point(x=3, y=4),
        Point(x=5, y=6)
    ]
    
    # Lambda to calculate distance between two points
    distance_between = lambda p1, p2 :: ((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2) ** 0.5
    dist = distance_between(points[0], points[1])
    expected_dist = ((1-3)**2 + (2-4)**2)**0.5  # sqrt(8) â‰ˆ 2.828
    assert abs(dist - expected_dist) < 0.001, f"Expected {expected_dist}, got {dist}"
    
    # Lambda to find closest point to origin - manual min implementation
    distance_to_origin = lambda p :: (p.x ** 2 + p.y ** 2) ** 0.5
    
    # Manual min implementation for struct instances
    closest_point = points[0]
    min_distance = distance_to_origin(closest_point)
    
    for point in points[1:]:
        current_distance = distance_to_origin(point)
        if current_distance < min_distance:
            min_distance = current_distance
            closest_point = point
    
    assert closest_point.x == 1 and closest_point.y == 2, f"Expected Point(1,2), got Point({closest_point.x},{closest_point.y})"
    
    log("âœ… Lambda complex struct operations tests passed")

# Test 5: Lambda expressions with struct validation
def test_lambda_struct_validation():
    # Lambda for email validation
    is_valid_email = lambda self :: (
        "@" in self.email and
        "." in (self.email.split("@")[1] if "@" in self.email else "")
    )
    
    valid_person = Person(name="Bob", age=30, email="bob@domain.com")
    invalid_person = Person(name="Charlie", age=25, email="invalid-email")
    
    assert is_valid_email(valid_person) == True, "Expected valid email to return True"
    assert is_valid_email(invalid_person) == False, "Expected invalid email to return False"
    
    # Lambda for age validation
    is_valid_age = lambda self :: self.age >= 0 and self.age <= 150
    young_person = Person(name="David", age=5, email="david@test.com")
    old_person = Person(name="Eve", age=200, email="eve@test.com")
    
    assert is_valid_age(young_person) == True, "Expected young age to be valid"
    assert is_valid_age(old_person) == False, "Expected old age to be invalid"
    
    log("âœ… Lambda struct validation tests passed")

# Test 6: Lambda expressions with struct inheritance behavior
def test_lambda_struct_polymorphism():
    # Extended struct (composition pattern)
    struct ExtendedPoint:
        point: Point
        color: str
    
    ext_point = ExtendedPoint(point=Point(x=2, y=3), color="red")
    
    # Lambda that works with both Point and ExtendedPoint - separate lambdas for each type
    get_point_coordinates = lambda obj :: (obj.x, obj.y)
    get_extended_point_coordinates = lambda obj :: (obj.point.x, obj.point.y)
    
    simple_point = Point(x=1, y=1)
    coords1 = get_point_coordinates(simple_point)
    coords2 = get_extended_point_coordinates(ext_point)
    
    assert coords1 == (1, 1), f"Expected (1, 1), got {coords1}"
    assert coords2 == (2, 3), f"Expected (2, 3), got {coords2}"
    
    log("âœ… Lambda struct polymorphism tests passed")

# Run all tests
test_lambda_as_struct_methods()
test_lambda_struct_field_operations()
test_lambda_struct_chaining()
test_lambda_complex_struct_operations()
test_lambda_struct_validation()
test_lambda_struct_polymorphism()

log("ðŸŽ‰ All lambda expressions with struct receivers tests completed successfully!") 