# User-Defined Method Chaining Tests
# ===================================
# PURPOSE: Test method chaining with user-defined Dana structs and functions
# AUDIENCE: Developers creating chainable APIs and fluent interfaces in Dana
# LEARNING: How to create and use custom structs with functions that support method chaining
# ===================================

print("=== User-Defined Method Chaining Tests ===")

# FLUENT BUILDER PATTERN WITH STRUCTS
# ===================================
print("Testing fluent builder pattern with structs...")

# Define a struct for string building
struct FluentStringBuilder:
    parts: list

# Functions that operate on FluentStringBuilder and return modified instances
def create_builder() -> FluentStringBuilder:
    """Create a new FluentStringBuilder"""
    return FluentStringBuilder(parts=[])

def add(builder: FluentStringBuilder, text: str) -> FluentStringBuilder:
    """Add text to the builder"""
    builder.parts.append(text)
    return builder

def add_upper(builder: FluentStringBuilder, text: str) -> FluentStringBuilder:
    """Add uppercased text to the builder"""
    builder.parts.append(text.upper())
    return builder

def add_lower(builder: FluentStringBuilder, text: str) -> FluentStringBuilder:
    """Add lowercased text to the builder"""
    builder.parts.append(text.lower())
    return builder

def add_separator(builder: FluentStringBuilder, sep: str = ", ") -> FluentStringBuilder:
    """Add a separator to the builder"""
    if len(builder.parts) > 0:  # Only add separator if there are parts
        builder.parts.append(sep)
    return builder

def build(builder: FluentStringBuilder) -> str:
    """Build the final string"""
    return "".join(builder.parts)

def clear_builder(builder: FluentStringBuilder) -> FluentStringBuilder:
    """Clear the builder"""
    builder.parts = []
    return builder

# Test fluent builder with Dana struct method syntax
builder = create_builder()
builder = add(builder, "Hello")
builder = add_separator(builder, ", ")
builder = add_upper(builder, "world")
builder = add_separator(builder, ", ")
builder = add_lower(builder, "DANA")
result1 = build(builder)
assert result1 == "Hello, WORLD, dana"
print(f"✅ Fluent builder with Dana syntax: {result1}")

# Test builder clearing and reuse
builder2 = create_builder()
builder2 = add(builder2, "New")
builder2 = add_separator(builder2, "-")
builder2 = add(builder2, "Chain")
result2 = build(builder2)
assert result2 == "New-Chain"
print(f"✅ Builder operations: {result2}")

# MATHEMATICAL OPERATIONS WITH STRUCT CHAINING
# ============================================
print("\nTesting mathematical operations with struct chaining...")

# Define a calculator struct
struct FluentCalculator:
    value: float

# Calculator functions
def create_calculator(initial_value: float = 0.0) -> FluentCalculator:
    """Create a new calculator"""
    return FluentCalculator(value=initial_value)

def add_calc(calc: FluentCalculator, n: float) -> FluentCalculator:
    """Add a number to the calculator"""
    calc.value = calc.value + n
    return calc

def multiply_calc(calc: FluentCalculator, n: float) -> FluentCalculator:
    """Multiply the calculator value"""
    calc.value = calc.value * n
    return calc

def subtract_calc(calc: FluentCalculator, n: float) -> FluentCalculator:
    """Subtract from the calculator value"""
    calc.value = calc.value - n
    return calc

def divide_calc(calc: FluentCalculator, n: float) -> FluentCalculator:
    """Divide the calculator value"""
    if n != 0:
        calc.value = calc.value / n
    return calc

def get_result(calc: FluentCalculator) -> float:
    """Get the calculator result"""
    return calc.value

def reset_calc(calc: FluentCalculator, new_value: float = 0.0) -> FluentCalculator:
    """Reset the calculator"""
    calc.value = new_value
    return calc

# Test mathematical operations using Dana struct method syntax
calc = create_calculator(10.0)
calc = add_calc(calc, 5)
calc = multiply_calc(calc, 2)
calc = subtract_calc(calc, 5)
result3 = get_result(calc)
assert result3 == 25.0  # (10 + 5) * 2 - 5 = 25
print(f"✅ Mathematical operations: 10 + 5 * 2 - 5 = {result3}")

# Test operations with reset
calc2 = create_calculator(10.0)
calc2 = reset_calc(calc2, 3)
calc2 = add_calc(calc2, 1)
calc2 = multiply_calc(calc2, 3)
result4 = get_result(calc2)
assert result4 == 12.0  # (3 + 1) * 3 = 12
print(f"✅ Calculator reset and operations: (3 + 1) * 3 = {result4}")

# DATA TRANSFORMATION WITH STRUCT CHAINING
# ========================================
print("\nTesting data transformation with struct chaining...")

# Define a data processor struct
struct FluentDataProcessor:
    data: list

# Data processing functions
def create_processor(initial_data: list) -> FluentDataProcessor:
    """Create a new data processor"""
    return FluentDataProcessor(data=initial_data[:])  # Make a copy

def filter_even_data(processor: FluentDataProcessor) -> FluentDataProcessor:
    """Filter to keep only even numbers"""
    filtered = []
    for item in processor.data:
        if item % 2 == 0:
            filtered.append(item)
    processor.data = filtered
    return processor

def filter_odd_data(processor: FluentDataProcessor) -> FluentDataProcessor:
    """Filter to keep only odd numbers"""
    filtered = []
    for item in processor.data:
        if item % 2 == 1:
            filtered.append(item)
    processor.data = filtered
    return processor

def double_data(processor: FluentDataProcessor) -> FluentDataProcessor:
    """Double all values"""
    doubled = []
    for item in processor.data:
        doubled.append(item * 2)
    processor.data = doubled
    return processor

def add_value_to_data(processor: FluentDataProcessor, value: int) -> FluentDataProcessor:
    """Add a value to all elements"""
    result = []
    for item in processor.data:
        result.append(item + value)
    processor.data = result
    return processor

def take_first_n(processor: FluentDataProcessor, n: int) -> FluentDataProcessor:
    """Take first n elements"""
    processor.data = processor.data[:n]
    return processor

def sort_data(processor: FluentDataProcessor) -> FluentDataProcessor:
    """Sort the data"""
    processor.data.sort()
    return processor

def get_data(processor: FluentDataProcessor) -> list:
    """Get the processed data"""
    return processor.data

def get_sum_data(processor: FluentDataProcessor) -> int:
    """Get the sum of the data"""
    return sum(processor.data)

# Test data processing operations
processor = create_processor([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
processor = filter_even_data(processor)
processor = double_data(processor)
processor = take_first_n(processor, 3)
result5 = get_data(processor)
assert result5 == [4, 8, 12]  # Even numbers: [2,4,6,8,10] -> doubled: [4,8,12,16,20] -> first 3: [4,8,12]
print(f"✅ Data processing operations: [1-10] -> filter even -> double -> take 3 = {result5}")

# Test another data processing sequence
processor2 = create_processor([5, 1, 9, 3, 7])
processor2 = filter_odd_data(processor2)
processor2 = add_value_to_data(processor2, 10)
processor2 = sort_data(processor2)
result6 = get_sum_data(processor2)
assert result6 == 75  # [5,1,9,3,7] -> all odd -> +10 each: [15,11,19,13,17] -> sorted: [11,13,15,17,19] -> sum = 75
print(f"✅ Data processing with sum: [5,1,9,3,7] -> odd -> +10 -> sort -> sum = {result6}")

# STRING MANIPULATION WITH STRUCT CHAINING
# ========================================
print("\nTesting string manipulation with struct chaining...")

# Define a string processor struct
struct FluentStringProcessor:
    text: str

# String processing functions
def create_string_processor(initial_text: str) -> FluentStringProcessor:
    """Create a new string processor"""
    return FluentStringProcessor(text=initial_text)

def upper_text(processor: FluentStringProcessor) -> FluentStringProcessor:
    """Convert text to uppercase"""
    processor.text = processor.text.upper()
    return processor

def lower_text(processor: FluentStringProcessor) -> FluentStringProcessor:
    """Convert text to lowercase"""
    processor.text = processor.text.lower()
    return processor

def replace_text(processor: FluentStringProcessor, old: str, new: str) -> FluentStringProcessor:
    """Replace text"""
    processor.text = processor.text.replace(old, new)
    return processor

def strip_text(processor: FluentStringProcessor) -> FluentStringProcessor:
    """Strip whitespace"""
    processor.text = processor.text.strip()
    return processor

def add_prefix_text(processor: FluentStringProcessor, prefix: str) -> FluentStringProcessor:
    """Add prefix to text"""
    processor.text = prefix + processor.text
    return processor

def add_suffix_text(processor: FluentStringProcessor, suffix: str) -> FluentStringProcessor:
    """Add suffix to text"""
    processor.text = processor.text + suffix
    return processor

def get_text(processor: FluentStringProcessor) -> str:
    """Get the processed text"""
    return processor.text

def get_text_length(processor: FluentStringProcessor) -> int:
    """Get the length of the text"""
    return len(processor.text)

# Test string processing operations
str_proc = create_string_processor("  hello world  ")
str_proc = strip_text(str_proc)
str_proc = upper_text(str_proc)
str_proc = replace_text(str_proc, " ", "_")
str_proc = add_prefix_text(str_proc, "GREETING_")
str_proc = add_suffix_text(str_proc, "_END")
result7 = get_text(str_proc)
assert result7 == "GREETING_HELLO_WORLD_END"
print(f"✅ String processing operations: '  hello world  ' -> {result7}")

# CONFIGURATION BUILDER WITH STRUCT CHAINING
# ===========================================
print("\nTesting configuration builder with struct chaining...")

# Define a config struct
struct FluentConfig:
    config: dict

# Config functions
def create_config() -> FluentConfig:
    """Create a new configuration"""
    return FluentConfig(config={})

def set_host(config: FluentConfig, host: str) -> FluentConfig:
    """Set the host"""
    config.config["host"] = host
    return config

def set_port(config: FluentConfig, port: int) -> FluentConfig:
    """Set the port"""
    config.config["port"] = port
    return config

def set_timeout(config: FluentConfig, timeout: int) -> FluentConfig:
    """Set the timeout"""
    config.config["timeout"] = timeout
    return config

def enable_ssl(config: FluentConfig) -> FluentConfig:
    """Enable SSL"""
    config.config["ssl"] = true
    return config

def add_header(config: FluentConfig, key: str, value: str) -> FluentConfig:
    """Add a header"""
    if "headers" in config.config:
        config.config["headers"][key] = value
    else:
        config.config["headers"] = {key: value}
    return config

def build_config(config: FluentConfig) -> dict:
    """Build the final configuration"""
    return config.config

# Test configuration builder
config = create_config()
config = set_host(config, "api.example.com")
config = set_port(config, 443)
config = enable_ssl(config)
config = set_timeout(config, 30)
config = add_header(config, "User-Agent", "Dana/1.0")
result8 = build_config(config)
expected_config = {
    "host": "api.example.com",
    "port": 443,
    "ssl": true,
    "timeout": 30,
    "headers": {"User-Agent": "Dana/1.0"}
}
assert result8 == expected_config
print(f"✅ Configuration builder operations: {result8}")

# ERROR HANDLING WITH STRUCT CHAINING
# ===================================
print("\nTesting error handling with struct chaining...")

# Define a safe calculator struct
struct SafeFluentCalculator:
    value: float
    error_msg: str

# Safe calculator functions
def create_safe_calculator(initial_value: float = 0.0) -> SafeFluentCalculator:
    """Create a new safe calculator"""
    return SafeFluentCalculator(value=initial_value, error_msg="")

def safe_add(calc: SafeFluentCalculator, n: float) -> SafeFluentCalculator:
    """Safely add a number"""
    if calc.error_msg == "":
        calc.value = calc.value + n
    return calc

def safe_divide(calc: SafeFluentCalculator, n: float) -> SafeFluentCalculator:
    """Safely divide"""
    if calc.error_msg == "":
        if n == 0:
            calc.error_msg = "Division by zero"
        else:
            calc.value = calc.value / n
    return calc

def safe_multiply(calc: SafeFluentCalculator, n: float) -> SafeFluentCalculator:
    """Safely multiply"""
    if calc.error_msg == "":
        calc.value = calc.value * n
    return calc

def get_safe_result(calc: SafeFluentCalculator) -> float:
    """Get the safe result"""
    if calc.error_msg == "":
        return calc.value
    else:
        return -1.0  # Error indicator

def get_safe_error(calc: SafeFluentCalculator) -> str:
    """Get the error message"""
    return calc.error_msg

def is_safe_valid(calc: SafeFluentCalculator) -> bool:
    """Check if the calculation is valid"""
    return calc.error_msg == ""

# Test error handling
safe_calc = create_safe_calculator(10.0)
safe_calc = safe_add(safe_calc, 5)
safe_calc = safe_divide(safe_calc, 0)
safe_calc = safe_multiply(safe_calc, 2)
result10 = get_safe_result(safe_calc)
assert result10 == -1.0  # Should be -1.0 due to division by zero
assert get_safe_error(safe_calc) == "Division by zero"
print(f"✅ Error handling in operations: division by zero handled gracefully")

# Test successful operations
safe_calc2 = create_safe_calculator(10.0)
safe_calc2 = safe_add(safe_calc2, 5)
safe_calc2 = safe_divide(safe_calc2, 3)
safe_calc2 = safe_multiply(safe_calc2, 2)
result11 = get_safe_result(safe_calc2)
expected_result = (10.0 + 5.0) / 3.0 * 2.0  # = 10.0
assert abs(result11 - expected_result) < 0.0001
assert is_safe_valid(safe_calc2) == true
print(f"✅ Successful safe calculation operations: {result11}")

print("\n=== All User-Defined Method Chaining Tests Passed! ===") 