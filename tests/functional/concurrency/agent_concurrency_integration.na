# Functional tests for agent system integration with Promise[T] concurrency
# Copyright © 2025 Aitomatic, Inc.

# Test agent method calls with deliver/return
def test_agent_deliver_return():
    agent DataProcessor:
        name: str = "DataProcessor"
        
        def (self) process_immediately(data):
            deliver {"processed": data, "timestamp": "now"}
        
        def (self) process_lazily(data):
            return {"processed": data, "timestamp": "deferred"}
    
    processor = DataProcessor()
    
    # Test eager agent method
    immediate_result = processor.process_immediately([1, 2, 3])
    assert immediate_result["processed"] == [1, 2, 3]
    assert immediate_result["timestamp"] == "now"
    
    # Test lazy agent method  
    lazy_result = processor.process_lazily([4, 5, 6])
    assert lazy_result["processed"] == [4, 5, 6]
    assert lazy_result["timestamp"] == "deferred"
    
    print("✓ Agent methods with deliver/return work")

# Test concurrent agent operations
def test_concurrent_agent_operations():
    agent APIClient:
        base_url: str = "https:#api.example.com"
        
        def (self) fetch_users():
            return [{"id": 1, "name": "Alice"}, {"id": 2, "name": "Bob"}]
        
        def (self) fetch_posts():
            return [{"id": 101, "title": "Post 1"}, {"id": 102, "title": "Post 2"}]
        
        def (self) fetch_comments():
            return [{"id": 201, "text": "Comment 1"}, {"id": 202, "text": "Comment 2"}]
    
    client = APIClient()
    
    # Start multiple concurrent operations
    users_promise = client.fetch_users()
    posts_promise = client.fetch_posts()
    comments_promise = client.fetch_comments()
    
    # Combine results
    dashboard_data = {
        "users": users_promise,
        "posts": posts_promise,
        "comments": comments_promise
    }
    
    # Verify results
    assert len(dashboard_data["users"]) == 2
    assert len(dashboard_data["posts"]) == 2
    assert len(dashboard_data["comments"]) == 2
    assert dashboard_data["users"][0]["name"] == "Alice"
    
    print("✓ Concurrent agent operations work")

# Test agent communication with Promise[T]
def test_agent_communication():
    agent ResearchAgent:
        expertise: str = "research"
        
        def (self) research_topic(topic: str):
            return f"Research results for: {topic}"
        
        def (self) quick_summary(topic: str):
            deliver f"Quick summary: {topic}"
    
    agent AnalysisAgent:
        expertise: str = "analysis"
        
        def (self) analyze_data(data: str):
            return f"Analysis of: {data}"
        
        def (self) rapid_insight(data: str):
            deliver f"Rapid insight: {data}"
    
    agent OrchestratorAgent:
        name: str = "orchestrator"
        
        def (self) coordinate_research(topic: str):
            researcher = ResearchAgent()
            analyzer = AnalysisAgent()
            
            # Mix of eager and lazy agent communication
            quick_info = researcher.quick_summary(topic)  # Eager
            detailed_research = researcher.research_topic(topic)  # Lazy
            analysis = analyzer.analyze_data(detailed_research)  # Lazy, depends on research
            
            return {
                "quick": quick_info,
                "detailed": detailed_research,
                "analysis": analysis
            }
    
    orchestrator = OrchestratorAgent()
    result = orchestrator.coordinate_research("AI Ethics")
    
    # Verify coordinated results
    assert "Quick summary: AI Ethics" in result["quick"]
    assert "Research results for: AI Ethics" in result["detailed"]
    assert "Analysis of: Research results for: AI Ethics" in result["analysis"]
    
    print("✓ Agent communication with Promise[T] works")

# Test conditional agent execution
def test_conditional_agent_execution():
    agent ComputeAgent:
        power_level: str = "standard"
        
        def (self) light_computation(data):
            deliver len(data) * 2
        
        def (self) heavy_computation(data):
            # Expensive operation - only run when needed
            return sum(x * x for x in data)
    
    agent TaskCoordinator:
        name: str = "coordinator"
        
        def (self) process_workload(data, complexity: str):
            compute_agent = ComputeAgent()
            
            # Always do light computation
            basic_result = compute_agent.light_computation(data)
            
            if complexity == "high":
                # Heavy computation only when needed
                heavy_result = compute_agent.heavy_computation(data)
                return {"basic": basic_result, "heavy": heavy_result}
            else:
                return {"basic": basic_result}
    
    coordinator = TaskCoordinator()
    
    # Test low complexity - no heavy computation
    simple_result = coordinator.process_workload([1, 2, 3], "low")
    assert simple_result["basic"] == 6  # len([1,2,3]) * 2
    assert "heavy" not in simple_result
    
    # Test high complexity - includes heavy computation
    complex_result = coordinator.process_workload([1, 2, 3], "high")
    assert complex_result["basic"] == 6
    assert complex_result["heavy"] == 14  # 1^2 + 2^2 + 3^2
    
    print("✓ Conditional agent execution works")

# Test agent pipeline with Promise[T]
def test_agent_pipeline():
    agent DataIngestionAgent:
        source: str = "database"
        
        def (self) ingest_data():
            return {"raw_data": [10, 20, 30, 40, 50]}
    
    agent DataCleaningAgent:
        rules: str = "standard"
        
        def (self) clean_data(raw_data):
            return {"clean_data": [x for x in raw_data["raw_data"] if x > 15]}
    
    agent DataAnalysisAgent:
        model: str = "statistical"
        
        def (self) analyze(clean_data):
            data = clean_data["clean_data"]
            return {
                "analysis": {
                    "mean": sum(data) / len(data),
                    "max": max(data),
                    "min": min(data),
                    "count": len(data)
                }
            }
    
    agent PipelineCoordinator:
        name: str = "pipeline"
        
        def (self) run_pipeline():
            ingestion = DataIngestionAgent()
            cleaning = DataCleaningAgent()
            analysis = DataAnalysisAgent()
            
            # Chain operations with Promise[T]
            raw_data = ingestion.ingest_data()
            clean_data = cleaning.clean_data(raw_data)
            final_analysis = analysis.analyze(clean_data)
            
            return final_analysis
    
    coordinator = PipelineCoordinator()
    result = coordinator.run_pipeline()
    
    # Verify pipeline results
    analysis = result["analysis"]
    assert analysis["count"] == 4  # [20, 30, 40, 50]
    assert analysis["mean"] == 35.0
    assert analysis["max"] == 50
    assert analysis["min"] == 20
    
    print("✓ Agent pipeline with Promise[T] works")

# Test error handling in agent concurrency
def test_agent_error_handling():
    agent FlakyService:
        reliability: str = "low"
        
        def (self) reliable_operation():
            deliver "success"
        
        def (self) unreliable_operation():
            return 1 / 0  # This will fail
    
    agent ErrorHandler:
        name: str = "handler"
        
        def (self) safe_operations():
            service = FlakyService()
            
            # One reliable, one unreliable
            safe_result = service.reliable_operation()
            risky_result = service.unreliable_operation()
            
            try:
                # This should work
                assert safe_result == "success"
                
                # This should fail when accessed
                _ = risky_result
                return {"status": "unexpected_success"}
            except:
                return {"status": "handled_error", "safe": safe_result}
    
    handler = ErrorHandler()
    result = handler.safe_operations()
    
    # Verify error handling
    assert result["status"] == "handled_error"
    assert result["safe"] == "success"
    
    print("✓ Agent error handling with Promise[T] works")

# Test agent resource management with Promise[T]
def test_agent_resource_management():
    agent DatabaseAgent:
        connection_pool: str = "main"
        
        def (self) query_users():
            return [{"id": 1, "name": "Alice"}, {"id": 2, "name": "Bob"}]
        
        def (self) query_orders():
            return [{"id": 101, "user_id": 1}, {"id": 102, "user_id": 2}]
    
    agent CacheAgent:
        cache_type: str = "redis"
        
        def (self) get_cached_data(key: str):
            return f"cached_{key}"
        
        def (self) expensive_computation():
            return "computed_result"
    
    agent ResourceCoordinator:
        name: str = "coordinator"
        
        def (self) load_dashboard():
            db = DatabaseAgent()
            cache = CacheAgent()
            
            # Mix of database and cache operations
            users = db.query_users()
            orders = db.query_orders()
            cached_stats = cache.get_cached_data("stats")
            
            # Expensive operation only if needed
            computed_data = cache.expensive_computation()
            
            return {
                "users": users,
                "orders": orders,
                "stats": cached_stats,
                "computed": computed_data
            }
    
    coordinator = ResourceCoordinator()
    dashboard = coordinator.load_dashboard()
    
    # Verify resource coordination
    assert len(dashboard["users"]) == 2
    assert len(dashboard["orders"]) == 2
    assert dashboard["stats"] == "cached_stats"
    assert dashboard["computed"] == "computed_result"
    
    print("✓ Agent resource management with Promise[T] works")

# Run all agent integration tests
test_agent_deliver_return()
test_concurrent_agent_operations()
test_agent_communication()
test_conditional_agent_execution()
test_agent_pipeline()
test_agent_error_handling()
test_agent_resource_management()

print("All agent concurrency integration tests passed!")