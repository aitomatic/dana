# Agent Blueprint Methods Tests
# Tests for built-in agent methods and method-related functionality

log_level("INFO")

# Test agent for methods testing
agent_blueprint MethodsTestAgent:
    name: str = "MethodsTest"
    role: str = "tester"

# Test 1: Built-in agent methods
def test_builtin_agent_methods():
    agent_instance = MethodsTestAgent()
    
    # Test plan method
    plan_result = agent_instance.plan("analyze code quality")
    if "planning" not in plan_result.lower():
        return "âŒ Agent plan method not working"
    if "MethodsTest" not in plan_result:
        return "âŒ Agent name not in plan result"
    
    # Test solve method
    solve_result = agent_instance.solve("fix bug in module")
    if "solving" not in solve_result.lower():
        return "âŒ Agent solve method not working"
    if "MethodsTest" not in solve_result:
        return "âŒ Agent name not in solve result"
    
    # Test memory methods
    remember_result = agent_instance.remember("bug_location", "line 42")
    if remember_result != true:
        return "âŒ Agent remember method not working"
    
    recall_result = agent_instance.recall("bug_location")
    if recall_result != "line 42":
        return "âŒ Agent recall method not working"
    
    return "âœ… Built-in agent methods work"

# Test 2: Agent method chaining
def test_agent_method_chaining():
    agent_instance = MethodsTestAgent()
    
    # Test that built-in methods work correctly
    plan_result = agent_instance.plan("complex task")
    solve_result = agent_instance.solve("complex problem")
    
    if "planning" not in plan_result.lower():
        return "âŒ Plan method chaining failed"
    if "solving" not in solve_result.lower():
        return "âŒ Solve method chaining failed"
    
    return "âœ… Agent method chaining works"

# Test 3: Agent memory isolation
def test_agent_memory_isolation():
    agent1 = MethodsTestAgent()
    agent2 = MethodsTestAgent()
    
    # Store different values in each agent's memory
    agent1.remember("shared_key", "value1")
    agent2.remember("shared_key", "value2")
    
    # Check that memories are isolated
    if agent1.recall("shared_key") != "value1":
        return "âŒ Agent 1 memory isolation failed"
    if agent2.recall("shared_key") != "value2":
        return "âŒ Agent 2 memory isolation failed"
    
    return "âœ… Agent memory isolation works"

# Test 4: Agent error handling
def test_agent_error_handling():
    agent_instance = MethodsTestAgent()
    
    # Test memory operations with missing keys
    missing_result = agent_instance.recall("nonexistent_key")
    if missing_result != None:
        return "âŒ Agent recall with missing key should return None"
    
    # Test that agent methods handle errors gracefully
    try:
        plan_result = agent_instance.plan("test task")
        if "planning" not in plan_result.lower():
            return "âŒ Agent plan method error handling failed"
    except Exception as e:
        return f"âŒ Agent plan method threw unexpected error: {e}"
    
    return "âœ… Agent error handling works"

# Test 5: Method return values
def test_method_return_values():
    agent_instance = MethodsTestAgent()
    
    # Test plan method returns expected result
    plan_result = agent_instance.plan("test task")
    if "planning" not in str(plan_result).lower():
        return "âŒ Plan method should return planning result"
    
    # Test solve method returns expected result
    solve_result = agent_instance.solve("test problem")
    if "solving" not in str(solve_result).lower():
        return "âŒ Solve method should return solving result"
    
    # Test remember method returns boolean
    remember_result = agent_instance.remember("key", "value")
    if remember_result != true:
        return "âŒ Remember method should return true"
    
    # Test recall method returns stored value
    recall_result = agent_instance.recall("key")
    if recall_result != "value":
        return "âŒ Recall method should return stored value"
    
    return "âœ… Method return values are correct"

# Test 6: Method parameter handling
def test_method_parameter_handling():
    agent_instance = MethodsTestAgent()
    
    # Test plan with different task types
    plan1 = agent_instance.plan("simple task")
    plan2 = agent_instance.plan("complex multi-step task")
    
    if "planning" not in plan1.lower():
        return "âŒ Plan method failed with simple task"
    if "planning" not in plan2.lower():
        return "âŒ Plan method failed with complex task"
    
    # Test solve with different problem types
    solve1 = agent_instance.solve("simple problem")
    solve2 = agent_instance.solve("complex problem with constraints")
    
    if "solving" not in solve1.lower():
        return "âŒ Solve method failed with simple problem"
    if "solving" not in solve2.lower():
        return "âŒ Solve method failed with complex problem"
    
    return "âœ… Method parameter handling works"

# Test 7: Memory persistence
def test_memory_persistence():
    agent_instance = MethodsTestAgent()
    
    # Store multiple values
    agent_instance.remember("key1", "value1")
    agent_instance.remember("key2", "value2")
    agent_instance.remember("key3", "value3")
    
    # Recall all values
    if agent_instance.recall("key1") != "value1":
        return "âŒ Memory persistence failed for key1"
    if agent_instance.recall("key2") != "value2":
        return "âŒ Memory persistence failed for key2"
    if agent_instance.recall("key3") != "value3":
        return "âŒ Memory persistence failed for key3"
    
    return "âœ… Memory persistence works"

# Test 8: Method call order independence
def test_method_call_order_independence():
    agent_instance = MethodsTestAgent()
    
    # Call methods in different orders
    agent_instance.remember("order_test", "value")
    plan_result = agent_instance.plan("test task")
    recall_result = agent_instance.recall("order_test")
    solve_result = agent_instance.solve("test problem")
    
    # All should work regardless of order
    if recall_result != "value":
        return "âŒ Method call order independence failed for recall"
    if "planning" not in plan_result.lower():
        return "âŒ Method call order independence failed for plan"
    if "solving" not in solve_result.lower():
        return "âŒ Method call order independence failed for solve"
    
    return "âœ… Method call order independence works"

# Test 9: Method with empty parameters
def test_method_with_empty_parameters():
    agent_instance = MethodsTestAgent()
    
    # Test methods with empty strings
    plan_result = agent_instance.plan("")
    solve_result = agent_instance.solve("")
    
    # Should handle gracefully
    if "planning" not in plan_result.lower():
        return "âŒ Plan method failed with empty parameter"
    if "solving" not in solve_result.lower():
        return "âŒ Solve method failed with empty parameter"
    
    return "âœ… Methods handle empty parameters"

# Test 10: Method performance
def test_method_performance():
    agent_instance = MethodsTestAgent()
    
    # Test multiple rapid method calls
    for i in range(10):
        plan_result = agent_instance.plan(f"task {i}")
        solve_result = agent_instance.solve(f"problem {i}")
        agent_instance.remember(f"key{i}", f"value{i}")
        recall_result = agent_instance.recall(f"key{i}")
        
        if "planning" not in plan_result.lower():
            return f"âŒ Plan method failed on iteration {i}"
        if "solving" not in solve_result.lower():
            return f"âŒ Solve method failed on iteration {i}"
        if recall_result != f"value{i}":
            return f"âŒ Memory method failed on iteration {i}"
    
    return "âœ… Method performance is stable"

# Run methods tests
log("=== Agent Blueprint Methods Tests ===")

tests = [
    test_builtin_agent_methods,
    test_agent_method_chaining,
    test_agent_memory_isolation,
    test_agent_error_handling,
    test_method_return_values,
    test_method_parameter_handling,
    test_memory_persistence,
    test_method_call_order_independence,
    test_method_with_empty_parameters,
    test_method_performance
]

passed = 0
failed = 0

for i in range(len(tests)):
    test = tests[i]
    test_num = i + 1
    
    try:
        result = test()
        if result.startswith("âœ…"):
            log(f"âœ… Test {test_num}: {result}")
            passed += 1
        else:
            log(f"âŒ Test {test_num}: {result}")
            failed += 1
    except Exception as e:
        log(f"âŒ Test {test_num}: Exception - {e}")
        failed += 1

log(f"\n=== Methods Tests Summary ===")
log(f"Passed: {passed}")
log(f"Failed: {failed}")
log(f"Total: {len(tests)}")

if failed == 0:
    log("ğŸ‰ All methods tests passed!")
else:
    log(f"âš ï¸  {failed} methods tests failed")

{
    "passed": passed,
    "failed": failed,
    "total": len(tests)
}
